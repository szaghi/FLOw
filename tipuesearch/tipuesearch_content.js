var tipuesearch = {"pages":[{"text":"FLOw FLOw FLOw, Fortran fLuid Object A KISS pure Fortran Library providing a Fluid Object designed for building CFD codes: FLOw is a pure Fortran (KISS) library providing a Fluid Object designed for building CFD codes; FLOw is Fortran 2008+ standard compliant; FLOw is OOP designed; FLOw is TDD developed; FLOw is a Free, Open Source Project. A taste of FLOw use flow type ( fluid_object ) :: state call state % initialize ( pressure = 1 , density = 0.125 , cp = 1024 , cv = 712 ) ... To be completed. Issues Compiler Support What is FLOw? | Main features | Copyrights | Download | Compilation | Documentation | References What is FLOw? FLOw is a modern Fortran library providing a Fluid Object designed for building CFD codes. To be completed. How to use To be written. Go to Top Main features To be written. Any feature request is welcome. Go to Top Copyrights FLOw is a Free and Open Source Software (FOSS), it is distributed under a very permissive multi-licensing system: selectable licenses are GPLv3 , BSD2-Clause , BSD3-Clause and MIT , feel free to select the license that best matches your workflow. Anyone is interest to use, to develop or to contribute to FLOw is welcome. More details can be found on wiki . Go to Top Download To be written. Go to Top Compilation To be written. Documentation Besides this README file the FLOw documentation is contained into its own wiki . Detailed documentation of the API is contained into the GitHub Pages that can also be created locally by means of ford tool . Go to Top Developer Info Stefano Zaghi","tags":"","loc":"index.html","title":" FLOw "},{"text":"FLOw, Fortran fLuid Object This File Depends On sourcefile~~flow.f90~~EfferentGraph sourcefile~flow.f90 flow.f90 sourcefile~flow_eos_compressible.f90 flow_eos_compressible.f90 sourcefile~flow_eos_compressible.f90->sourcefile~flow.f90 sourcefile~flow_field_scalar_vectorial.f90 flow_field_scalar_vectorial.f90 sourcefile~flow_field_scalar_vectorial.f90->sourcefile~flow.f90 sourcefile~flow_primitive_object.f90 flow_primitive_object.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow.f90 sourcefile~flow_primitive_compressible.f90 flow_primitive_compressible.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_primitive_compressible_multispecie.f90 flow_primitive_compressible_multispecie.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_conservative_compressible.f90 flow_conservative_compressible.f90 sourcefile~flow_conservative_compressible.f90->sourcefile~flow.f90 sourcefile~flow_compressible_transformations.f90 flow_compressible_transformations.f90 sourcefile~flow_conservative_compressible.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_primitive_compressible.f90->sourcefile~flow.f90 sourcefile~flow_primitive_compressible.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_conservative_object.f90 flow_conservative_object.f90 sourcefile~flow_conservative_object.f90->sourcefile~flow.f90 sourcefile~flow_conservative_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_primitive_compressible_multispecie.f90->sourcefile~flow.f90 sourcefile~flow_eos_object.f90 flow_eos_object.f90 sourcefile~flow_eos_object.f90->sourcefile~flow.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_eos_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_field_object.f90 flow_field_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow.f90 sourcefile~flow_field_object.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_field_object.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_compressible_transformations.f90->sourcefile~flow.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~flow_eos_compressible.f90 sourcefile~penf.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~penf.f90->sourcefile~flow_primitive_object.f90 sourcefile~penf.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~penf.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~penf.f90->sourcefile~flow_conservative_object.f90 sourcefile~penf.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~penf.f90->sourcefile~flow_eos_object.f90 sourcefile~penf.f90->sourcefile~flow_field_object.f90 sourcefile~penf.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~vecfor.f90 vecfor.F90 sourcefile~vecfor.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_object.f90 sourcefile~vecfor.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~vecfor.f90->sourcefile~flow_conservative_object.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~vecfor.f90->sourcefile~flow_compressible_transformations.f90 var pansourcefileflowf90EfferentGraph = svgPanZoom('#sourcefileflowf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~flow.f90~~AfferentGraph sourcefile~flow.f90 flow.f90 sourcefile~flow_test_primitive_compressible_sub.f90 flow_test_primitive_compressible_sub.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_sub.f90 sourcefile~flow_test_conservative_compressible_assign.f90 flow_test_conservative_compressible_assign.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_assign.f90 sourcefile~flow_test_conservative_compressible_add.f90 flow_test_conservative_compressible_add.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_add.f90 sourcefile~flow_test_conservative_compressible_div.f90 flow_test_conservative_compressible_div.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_div.f90 sourcefile~flow_test_conservative_compressible_eq.f90 flow_test_conservative_compressible_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_eq.f90 sourcefile~flow_test_conservative_compressible_mul.f90 flow_test_conservative_compressible_mul.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_mul.f90 sourcefile~flow_test_conservative_compressible_not_eq.f90 flow_test_conservative_compressible_not_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_not_eq.f90 sourcefile~flow_test_conservative_compressible_pow.f90 flow_test_conservative_compressible_pow.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_pow.f90 sourcefile~flow_test_conservative_compressible_sub.f90 flow_test_conservative_compressible_sub.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_sub.f90 sourcefile~flow_test_eos_compressible.f90 flow_test_eos_compressible.f90 sourcefile~flow.f90->sourcefile~flow_test_eos_compressible.f90 sourcefile~flow_test_primitive_compressible_add.f90 flow_test_primitive_compressible_add.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_add.f90 sourcefile~flow_test_primitive_compressible_assign.f90 flow_test_primitive_compressible_assign.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_assign.f90 sourcefile~flow_test_primitive_compressible_div.f90 flow_test_primitive_compressible_div.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_div.f90 sourcefile~flow_test_primitive_compressible_eq.f90 flow_test_primitive_compressible_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_eq.f90 sourcefile~flow_test_primitive_compressible_mul.f90 flow_test_primitive_compressible_mul.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_mul.f90 sourcefile~flow_test_primitive_compressible_multispecie_add.f90 flow_test_primitive_compressible_multispecie_add.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_add.f90 sourcefile~flow_test_primitive_compressible_multispecie_assign.f90 flow_test_primitive_compressible_multispecie_assign.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_assign.f90 sourcefile~flow_test_primitive_compressible_multispecie_div.f90 flow_test_primitive_compressible_multispecie_div.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_div.f90 sourcefile~flow_test_primitive_compressible_multispecie_eq.f90 flow_test_primitive_compressible_multispecie_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_eq.f90 sourcefile~flow_test_primitive_compressible_multispecie_mul.f90 flow_test_primitive_compressible_multispecie_mul.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_mul.f90 sourcefile~flow_test_primitive_compressible_multispecie_not_eq.f90 flow_test_primitive_compressible_multispecie_not_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_not_eq.f90 sourcefile~flow_test_primitive_compressible_multispecie_pow.f90 flow_test_primitive_compressible_multispecie_pow.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_pow.f90 sourcefile~flow_test_primitive_compressible_multispecie_sub.f90 flow_test_primitive_compressible_multispecie_sub.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_sub.f90 sourcefile~flow_test_primitive_compressible_not_eq.f90 flow_test_primitive_compressible_not_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_not_eq.f90 sourcefile~flow_test_primitive_compressible_pow.f90 flow_test_primitive_compressible_pow.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_pow.f90 sourcefile~flow_test_compressible_transformations.f90 flow_test_compressible_transformations.f90 sourcefile~flow.f90->sourcefile~flow_test_compressible_transformations.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules flow Source Code flow.f90 Source Code !< FLOw, Fortran fLuid Object module flow !< FLOw, Fortran fLuid Object use flow_compressible_transformations , only : conservative_to_primitive_compressible , primitive_to_conservative_compressible use flow_conservative_compressible , only : conservative_compressible , conservative_compressible_pointer use flow_conservative_object , only : conservative_object use flow_eos_compressible , only : eos_compressible use flow_eos_object , only : eos_object use flow_field_object , only : field_object use flow_field_scalar_vectorial , only : field_scalar , field_vectorial use flow_primitive_compressible , only : primitive_compressible , primitive_compressible_pointer use flow_primitive_compressible_multispecie , only : primitive_compressible_multispecie use flow_primitive_object , only : primitive_object implicit none private public :: conservative_to_primitive_compressible , primitive_to_conservative_compressible public :: conservative_compressible , conservative_compressible_pointer public :: conservative_object public :: eos_compressible public :: eos_object public :: field_object public :: field_scalar public :: field_vectorial public :: primitive_compressible , primitive_compressible_pointer public :: primitive_compressible_multispecie public :: primitive_object endmodule flow","tags":"","loc":"sourcefile/flow.f90.html","title":"flow.f90 – FLOw"},{"text":"FLOw compressible variables transformations. This File Depends On sourcefile~~flow_compressible_transformations.f90~~EfferentGraph sourcefile~flow_compressible_transformations.f90 flow_compressible_transformations.f90 sourcefile~flow_conservative_compressible.f90 flow_conservative_compressible.f90 sourcefile~flow_conservative_compressible.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~vecfor.f90 vecfor.F90 sourcefile~vecfor.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~vecfor.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_primitive_compressible.f90 flow_primitive_compressible.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_conservative_object.f90 flow_conservative_object.f90 sourcefile~vecfor.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_primitive_object.f90 flow_primitive_object.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_object.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~penf.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_eos_object.f90 flow_eos_object.f90 sourcefile~penf.f90->sourcefile~flow_eos_object.f90 sourcefile~penf.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_field_object.f90 flow_field_object.f90 sourcefile~penf.f90->sourcefile~flow_field_object.f90 sourcefile~penf.f90->sourcefile~flow_conservative_object.f90 sourcefile~penf.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_primitive_compressible.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_field_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_field_object.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_conservative_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow_primitive_compressible.f90 var pansourcefileflow_compressible_transformationsf90EfferentGraph = svgPanZoom('#sourcefileflow_compressible_transformationsf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~flow_compressible_transformations.f90~~AfferentGraph sourcefile~flow_compressible_transformations.f90 flow_compressible_transformations.f90 sourcefile~flow.f90 flow.f90 sourcefile~flow_compressible_transformations.f90->sourcefile~flow.f90 sourcefile~flow_test_primitive_compressible_sub.f90 flow_test_primitive_compressible_sub.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_sub.f90 sourcefile~flow_test_conservative_compressible_assign.f90 flow_test_conservative_compressible_assign.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_assign.f90 sourcefile~flow_test_conservative_compressible_add.f90 flow_test_conservative_compressible_add.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_add.f90 sourcefile~flow_test_conservative_compressible_div.f90 flow_test_conservative_compressible_div.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_div.f90 sourcefile~flow_test_conservative_compressible_eq.f90 flow_test_conservative_compressible_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_eq.f90 sourcefile~flow_test_conservative_compressible_mul.f90 flow_test_conservative_compressible_mul.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_mul.f90 sourcefile~flow_test_conservative_compressible_not_eq.f90 flow_test_conservative_compressible_not_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_not_eq.f90 sourcefile~flow_test_conservative_compressible_pow.f90 flow_test_conservative_compressible_pow.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_pow.f90 sourcefile~flow_test_conservative_compressible_sub.f90 flow_test_conservative_compressible_sub.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_sub.f90 sourcefile~flow_test_eos_compressible.f90 flow_test_eos_compressible.f90 sourcefile~flow.f90->sourcefile~flow_test_eos_compressible.f90 sourcefile~flow_test_primitive_compressible_add.f90 flow_test_primitive_compressible_add.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_add.f90 sourcefile~flow_test_primitive_compressible_assign.f90 flow_test_primitive_compressible_assign.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_assign.f90 sourcefile~flow_test_primitive_compressible_div.f90 flow_test_primitive_compressible_div.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_div.f90 sourcefile~flow_test_primitive_compressible_eq.f90 flow_test_primitive_compressible_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_eq.f90 sourcefile~flow_test_primitive_compressible_mul.f90 flow_test_primitive_compressible_mul.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_mul.f90 sourcefile~flow_test_primitive_compressible_multispecie_add.f90 flow_test_primitive_compressible_multispecie_add.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_add.f90 sourcefile~flow_test_primitive_compressible_multispecie_assign.f90 flow_test_primitive_compressible_multispecie_assign.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_assign.f90 sourcefile~flow_test_primitive_compressible_multispecie_div.f90 flow_test_primitive_compressible_multispecie_div.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_div.f90 sourcefile~flow_test_primitive_compressible_multispecie_eq.f90 flow_test_primitive_compressible_multispecie_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_eq.f90 sourcefile~flow_test_primitive_compressible_multispecie_mul.f90 flow_test_primitive_compressible_multispecie_mul.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_mul.f90 sourcefile~flow_test_primitive_compressible_multispecie_not_eq.f90 flow_test_primitive_compressible_multispecie_not_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_not_eq.f90 sourcefile~flow_test_primitive_compressible_multispecie_pow.f90 flow_test_primitive_compressible_multispecie_pow.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_pow.f90 sourcefile~flow_test_primitive_compressible_multispecie_sub.f90 flow_test_primitive_compressible_multispecie_sub.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_sub.f90 sourcefile~flow_test_primitive_compressible_not_eq.f90 flow_test_primitive_compressible_not_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_not_eq.f90 sourcefile~flow_test_primitive_compressible_pow.f90 flow_test_primitive_compressible_pow.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_pow.f90 sourcefile~flow_test_compressible_transformations.f90 flow_test_compressible_transformations.f90 sourcefile~flow.f90->sourcefile~flow_test_compressible_transformations.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules flow_compressible_transformations Source Code flow_compressible_transformations.f90 Source Code !< FLOw compressible variables transformations. module flow_compressible_transformations !< FLOw compressible variables transformations. use flow_conservative_compressible , only : conservative_compressible use flow_eos_object , only : eos_object use flow_primitive_compressible , only : primitive_compressible use penf , only : R8P use vecfor , only : vector implicit none private public :: conservative_to_primitive_compressible public :: primitive_to_conservative_compressible contains ! public procedures elemental function conservative_to_primitive_compressible ( conservative , eos ) result ( primitive_ ) !< Return a [[primitive_compressible]] state transforming a given [[conservative_compressible]] state. type ( conservative_compressible ), intent ( in ) :: conservative !< Conservative state. class ( eos_object ), intent ( in ) :: eos !< Equation of state. type ( primitive_compressible ) :: primitive_ !< Primitive state. primitive_ % density = conservative % density primitive_ % velocity = conservative % velocity () primitive_ % pressure = conservative % pressure ( eos = eos ) endfunction conservative_to_primitive_compressible elemental function primitive_to_conservative_compressible ( primitive , eos ) result ( conservative_ ) !< Return a [[conservative_compressible]] state transforming a given [[primitive_compressible]] state. type ( primitive_compressible ), intent ( in ) :: primitive !< Primitive state. class ( eos_object ), intent ( in ) :: eos !< Equation of state. type ( conservative_compressible ) :: conservative_ !< Conservative state. conservative_ % density = primitive % density conservative_ % momentum = primitive % momentum () conservative_ % energy = primitive % energy ( eos = eos ) endfunction primitive_to_conservative_compressible endmodule flow_compressible_transformations","tags":"","loc":"sourcefile/flow_compressible_transformations.f90.html","title":"flow_compressible_transformations.f90 – FLOw"},{"text":"FLOw conservative compressible object. This File Depends On sourcefile~~flow_conservative_compressible.f90~~EfferentGraph sourcefile~flow_conservative_compressible.f90 flow_conservative_compressible.f90 sourcefile~flow_field_object.f90 flow_field_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_conservative_object.f90 flow_conservative_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow_conservative_object.f90 sourcefile~vecfor.f90 vecfor.F90 sourcefile~vecfor.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~vecfor.f90->sourcefile~flow_conservative_object.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~penf.f90->sourcefile~flow_field_object.f90 sourcefile~flow_eos_object.f90 flow_eos_object.f90 sourcefile~penf.f90->sourcefile~flow_eos_object.f90 sourcefile~penf.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_conservative_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 var pansourcefileflow_conservative_compressiblef90EfferentGraph = svgPanZoom('#sourcefileflow_conservative_compressiblef90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~flow_conservative_compressible.f90~~AfferentGraph sourcefile~flow_conservative_compressible.f90 flow_conservative_compressible.f90 sourcefile~flow_compressible_transformations.f90 flow_compressible_transformations.f90 sourcefile~flow_conservative_compressible.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow.f90 flow.f90 sourcefile~flow_conservative_compressible.f90->sourcefile~flow.f90 sourcefile~flow_compressible_transformations.f90->sourcefile~flow.f90 sourcefile~flow_test_primitive_compressible_sub.f90 flow_test_primitive_compressible_sub.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_sub.f90 sourcefile~flow_test_conservative_compressible_assign.f90 flow_test_conservative_compressible_assign.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_assign.f90 sourcefile~flow_test_conservative_compressible_add.f90 flow_test_conservative_compressible_add.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_add.f90 sourcefile~flow_test_conservative_compressible_div.f90 flow_test_conservative_compressible_div.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_div.f90 sourcefile~flow_test_conservative_compressible_eq.f90 flow_test_conservative_compressible_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_eq.f90 sourcefile~flow_test_conservative_compressible_mul.f90 flow_test_conservative_compressible_mul.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_mul.f90 sourcefile~flow_test_conservative_compressible_not_eq.f90 flow_test_conservative_compressible_not_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_not_eq.f90 sourcefile~flow_test_conservative_compressible_pow.f90 flow_test_conservative_compressible_pow.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_pow.f90 sourcefile~flow_test_conservative_compressible_sub.f90 flow_test_conservative_compressible_sub.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_sub.f90 sourcefile~flow_test_eos_compressible.f90 flow_test_eos_compressible.f90 sourcefile~flow.f90->sourcefile~flow_test_eos_compressible.f90 sourcefile~flow_test_primitive_compressible_add.f90 flow_test_primitive_compressible_add.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_add.f90 sourcefile~flow_test_primitive_compressible_assign.f90 flow_test_primitive_compressible_assign.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_assign.f90 sourcefile~flow_test_primitive_compressible_div.f90 flow_test_primitive_compressible_div.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_div.f90 sourcefile~flow_test_primitive_compressible_eq.f90 flow_test_primitive_compressible_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_eq.f90 sourcefile~flow_test_primitive_compressible_mul.f90 flow_test_primitive_compressible_mul.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_mul.f90 sourcefile~flow_test_primitive_compressible_multispecie_add.f90 flow_test_primitive_compressible_multispecie_add.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_add.f90 sourcefile~flow_test_primitive_compressible_multispecie_assign.f90 flow_test_primitive_compressible_multispecie_assign.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_assign.f90 sourcefile~flow_test_primitive_compressible_multispecie_div.f90 flow_test_primitive_compressible_multispecie_div.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_div.f90 sourcefile~flow_test_primitive_compressible_multispecie_eq.f90 flow_test_primitive_compressible_multispecie_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_eq.f90 sourcefile~flow_test_primitive_compressible_multispecie_mul.f90 flow_test_primitive_compressible_multispecie_mul.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_mul.f90 sourcefile~flow_test_primitive_compressible_multispecie_not_eq.f90 flow_test_primitive_compressible_multispecie_not_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_not_eq.f90 sourcefile~flow_test_primitive_compressible_multispecie_pow.f90 flow_test_primitive_compressible_multispecie_pow.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_pow.f90 sourcefile~flow_test_primitive_compressible_multispecie_sub.f90 flow_test_primitive_compressible_multispecie_sub.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_sub.f90 sourcefile~flow_test_primitive_compressible_not_eq.f90 flow_test_primitive_compressible_not_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_not_eq.f90 sourcefile~flow_test_primitive_compressible_pow.f90 flow_test_primitive_compressible_pow.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_pow.f90 sourcefile~flow_test_compressible_transformations.f90 flow_test_compressible_transformations.f90 sourcefile~flow.f90->sourcefile~flow_test_compressible_transformations.f90 var pansourcefileflow_conservative_compressiblef90AfferentGraph = svgPanZoom('#sourcefileflow_conservative_compressiblef90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules flow_conservative_compressible Source Code flow_conservative_compressible.f90 Source Code !< FLOw **conservative** compressible object. module flow_conservative_compressible !< FLOw **conservative** compressible object. !< !< [[conservative_compressible]] is a class that handles compressible conservative fluid dynamic variables. use , intrinsic :: iso_fortran_env , only : stderr => error_unit use flow_eos_object , only : eos_object use flow_field_object , only : field_object use flow_conservative_object , only : conservative_object use penf , only : I4P , R8P , str use vecfor , only : vector implicit none private public :: conservative_compressible public :: conservative_compressible_pointer type , extends ( conservative_object ) :: conservative_compressible !< **Conservative** compressible multispecie object. real ( R8P ) :: density = 0._R8P !< Density, `rho`. type ( vector ) :: momentum !< Momentum, `rho * v`, `rho` being the density and `v` the velocity vector. real ( R8P ) :: energy = 0._R8P !< Energy, `rho * E`, `rho` being the density and `E` the specific energy. contains ! public methods procedure , pass ( self ) :: compute_fluxes_from_primitive !< Compute conservative fluxes from primitives at interface. ! deferred methods procedure , pass ( self ) :: array !< Return serialized array of field. procedure , pass ( self ) :: compute_fluxes !< Compute conservative fluxes. procedure , pass ( self ) :: description !< Return pretty-printed object description. procedure , pass ( self ) :: destroy !< Destroy conservative. procedure , pass ( self ) :: initialize !< Initialize conservative. procedure , pass ( self ) :: pressure !< Return pressure value. procedure , pass ( self ) :: velocity !< Return velocity vector. ! deferred operators procedure , pass ( lhs ) :: assign_field !< Operator `=`. procedure , pass ( lhs ) :: assign_real !< Operator `field = real`. procedure , pass ( self ) :: positive !< Unary operator `+ field`. procedure , pass ( lhs ) :: add !< Operator `+`. procedure , pass ( lhs ) :: div !< Operator `/`. procedure , pass ( lhs ) :: div_integer !< Operator `field / integer`. procedure , pass ( lhs ) :: div_real !< Operator `field / real`. procedure , pass ( lhs ) :: mul !< Operator `*`. procedure , pass ( lhs ) :: mul_integer !< Operator `field * integer`. procedure , pass ( rhs ) :: integer_mul !< Operator `integer * field`. procedure , pass ( lhs ) :: mul_real !< Operator `field * real`. procedure , pass ( rhs ) :: real_mul !< Operator `real * field`. procedure , pass ( self ) :: negative !< Unary operator `- field`. procedure , pass ( lhs ) :: sub !< Operator `-`. procedure , pass ( lhs ) :: pow_integer !< Operator `field ** integer`. procedure , pass ( lhs ) :: pow_real !< Operator `field ** real`. procedure , pass ( lhs ) :: eq !< Operator `=='. procedure , pass ( lhs ) :: not_eq !< Operator `/='. endtype conservative_compressible interface conservative_compressible !< Overload [[conservative_compressible]] name with its constructor. module procedure conservative_compressible_instance endinterface contains ! public non TBP function conservative_compressible_pointer ( to , error_message ) result ( pointer_ ) !< Return [[conservative_compressible]] pointer associated to [[conservative_object]] or its extensions until !< [[conservative_compressible]] included. !< !< @note A type-guard check is performed and error stop is raised if necessary. class ( conservative_object ), intent ( in ), target :: to !< Target of associate. character ( * ), intent ( in ), optional :: error_message !< Auxiliary error message. class ( conservative_compressible ), pointer :: pointer_ !< Associated pointer. select type ( to ) type is ( conservative_compressible ) pointer_ => to class default write ( stderr , '(A)' ) 'error: cast conservative_object to conservative_compressible failed!' if ( present ( error_message )) write ( stderr , '(A)' ) error_message stop endselect endfunction conservative_compressible_pointer ! public methods elemental subroutine compute_fluxes_from_primitive ( self , eos , p , r , u , normal ) !< Compute conservative fluxes from primitives at interface. class ( conservative_compressible ), intent ( inout ) :: self !< Conservative. class ( eos_object ), intent ( in ) :: eos !< Equation of state. real ( R8P ), intent ( in ) :: p !< Pressure at interface. real ( R8P ), intent ( in ) :: r !< Density at interface. real ( R8P ), intent ( in ) :: u !< Velocity (normal component) at interface. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. self % density = r * u self % momentum = ( r * u * u + p ) * normal self % energy = ( r * eos % internal_energy ( density = r , pressure = p ) + r * u * u * 0.5_R8P + p ) * u endsubroutine compute_fluxes_from_primitive ! deferred methods pure function array ( self ) result ( array_ ) !< Return serialized array of field. class ( conservative_compressible ), intent ( in ) :: self !< Conservative. real ( R8P ), allocatable :: array_ (:) !< Serialized array of field. allocate ( array_ ( 1 : 5 )) array_ ( 1 ) = self % density array_ ( 2 ) = self % momentum % x array_ ( 3 ) = self % momentum % y array_ ( 4 ) = self % momentum % z array_ ( 5 ) = self % energy endfunction array subroutine compute_fluxes ( self , eos , normal , fluxes ) !< Compute conservative fluxes. class ( conservative_compressible ), intent ( in ) :: self !< Conservative. class ( eos_object ), intent ( in ) :: eos !< Equation of state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. class ( conservative_object ), intent ( out ) :: fluxes !< Conservative fluxes. real ( R8P ) :: pressure_ !< Pressure value. type ( vector ) :: velocity_ !< Velocity vector. real ( R8P ) :: velocity_normal_ !< Velocity component parallel to given normal. select type ( fluxes ) class is ( conservative_compressible ) pressure_ = self % pressure ( eos = eos ) velocity_ = self % velocity () velocity_normal_ = velocity_ . dot . normal fluxes % density = self % momentum . dot . normal fluxes % momentum = self % density * velocity_ * velocity_normal_ + pressure_ * normal fluxes % energy = ( self % energy + pressure_ ) * velocity_normal_ endselect endsubroutine compute_fluxes pure function description ( self , prefix ) result ( desc ) !< Return a pretty-formatted object description. class ( conservative_compressible ), intent ( in ) :: self !< Conservative. character ( * ), intent ( in ), optional :: prefix !< Prefixing string. character ( len = :), allocatable :: prefix_ !< Prefixing string, local variable. character ( len = :), allocatable :: desc !< Description. character ( len = 1 ), parameter :: NL = new_line ( 'a' ) !< New line character. prefix_ = '' ; if ( present ( prefix )) prefix_ = prefix desc = '' desc = desc // prefix_ // 'density  = ' // trim ( str ( n = self % density )) // NL desc = desc // prefix_ // 'momentum = ' // trim ( str ( n = [ self % momentum % x , self % momentum % y , self % momentum % z ])) // NL desc = desc // prefix_ // 'energy   = ' // trim ( str ( n = self % energy )) endfunction description elemental subroutine destroy ( self ) !< Destroy conservative. class ( conservative_compressible ), intent ( inout ) :: self !< Conservative. type ( conservative_compressible ) :: fresh !< Fresh instance of conservative object. self = fresh endsubroutine destroy subroutine initialize ( self , initial_state ) !< Initialize conservative. class ( conservative_compressible ), intent ( inout ) :: self !< conservative. class ( conservative_object ), intent ( in ), optional :: initial_state !< Initial state. call self % destroy if ( present ( initial_state )) then select type ( initial_state ) class is ( conservative_compressible ) self = initial_state endselect endif endsubroutine initialize elemental function pressure ( self , eos ) result ( pressure_ ) !< Return pressure value. class ( conservative_compressible ), intent ( in ) :: self !< Conservative. class ( eos_object ), intent ( in ) :: eos !< Equation of state. real ( R8P ) :: pressure_ !< Pressure value. type ( vector ) :: velocity_ !< Velocity vector. velocity_ = self % velocity () pressure_ = ( eos % g () - 1._R8P ) * ( self % energy - 0.5_R8P * self % density * velocity_ % sq_norm ()) endfunction pressure elemental function velocity ( self ) result ( velocity_ ) !< Return velocity vector. class ( conservative_compressible ), intent ( in ) :: self !< Conservative. type ( vector ) :: velocity_ !< Velocity vector. velocity_ = self % momentum / self % density endfunction velocity ! deferred oprators elemental subroutine assign_field ( lhs , rhs ) !< Operator `=`. class ( conservative_compressible ), intent ( inout ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. select type ( rhs ) class is ( conservative_compressible ) lhs % density = rhs % density lhs % momentum = rhs % momentum lhs % energy = rhs % energy endselect endsubroutine assign_field elemental subroutine assign_real ( lhs , rhs ) !< Operator `field = real`. class ( conservative_compressible ), intent ( inout ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. lhs % density = rhs lhs % momentum = rhs lhs % energy = rhs endsubroutine assign_real function positive ( self ) result ( opr ) !< Unary operator `+ field`. class ( conservative_compressible ), intent ( in ) :: self !< conservative. class ( field_object ), allocatable :: opr !< Operator result. allocate ( conservative_compressible :: opr ) select type ( opr ) class is ( conservative_compressible ) opr % density = + self % density opr % momentum = + self % momentum opr % energy = + self % energy endselect endfunction positive elemental function add ( lhs , rhs ) result ( opr ) !< Operator `+`. class ( conservative_compressible ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( conservative_compressible :: opr ) select type ( opr ) class is ( conservative_compressible ) select type ( rhs ) class is ( conservative_compressible ) opr % density = lhs % density + rhs % density opr % momentum = lhs % momentum + rhs % momentum opr % energy = lhs % energy + rhs % energy endselect endselect endfunction add elemental function div ( lhs , rhs ) result ( opr ) !< Operator `/`. class ( conservative_compressible ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( conservative_compressible :: opr ) select type ( opr ) class is ( conservative_compressible ) select type ( rhs ) class is ( conservative_compressible ) opr % density = lhs % density / rhs % density opr % momentum = lhs % momentum / rhs % momentum opr % energy = lhs % energy / rhs % energy endselect endselect endfunction div elemental function div_integer ( lhs , rhs ) result ( opr ) !< Operator `field / integer`. class ( conservative_compressible ), intent ( in ) :: lhs !< Left hand side. integer ( I4P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( conservative_compressible :: opr ) select type ( opr ) class is ( conservative_compressible ) opr % density = lhs % density / rhs opr % momentum = lhs % momentum / rhs opr % energy = lhs % energy / rhs endselect endfunction div_integer elemental function div_real ( lhs , rhs ) result ( opr ) !< Operator `field / real`. class ( conservative_compressible ), intent ( in ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( conservative_compressible :: opr ) select type ( opr ) class is ( conservative_compressible ) opr % density = lhs % density / rhs opr % momentum = lhs % momentum / rhs opr % energy = lhs % energy / rhs endselect endfunction div_real elemental function mul ( lhs , rhs ) result ( opr ) !< Operator `*`. class ( conservative_compressible ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( conservative_compressible :: opr ) select type ( opr ) class is ( conservative_compressible ) select type ( rhs ) class is ( conservative_compressible ) opr % density = lhs % density * rhs % density opr % momentum = lhs % momentum * rhs % momentum opr % energy = lhs % energy * rhs % energy endselect endselect endfunction mul elemental function mul_integer ( lhs , rhs ) result ( opr ) !< Operator `field * integer`. class ( conservative_compressible ), intent ( in ) :: lhs !< Left hand side. integer ( I4P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( conservative_compressible :: opr ) select type ( opr ) class is ( conservative_compressible ) opr % density = lhs % density * rhs opr % momentum = lhs % momentum * rhs opr % energy = lhs % energy * rhs endselect endfunction mul_integer elemental function integer_mul ( lhs , rhs ) result ( opr ) !< Operator `integer * field`. integer ( I4P ), intent ( in ) :: lhs !< Left hand side. class ( conservative_compressible ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( conservative_compressible :: opr ) select type ( opr ) class is ( conservative_compressible ) opr % density = lhs * rhs % density opr % momentum = lhs * rhs % momentum opr % energy = lhs * rhs % energy endselect endfunction integer_mul elemental function mul_real ( lhs , rhs ) result ( opr ) !< Operator `field * real`. class ( conservative_compressible ), intent ( in ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( conservative_compressible :: opr ) select type ( opr ) class is ( conservative_compressible ) opr % density = lhs % density * rhs opr % momentum = lhs % momentum * rhs opr % energy = lhs % energy * rhs endselect endfunction mul_real elemental function real_mul ( lhs , rhs ) result ( opr ) !< Operator `real * field`. real ( R8P ), intent ( in ) :: lhs !< Left hand side. class ( conservative_compressible ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( conservative_compressible :: opr ) select type ( opr ) class is ( conservative_compressible ) opr % density = lhs * rhs % density opr % momentum = lhs * rhs % momentum opr % energy = lhs * rhs % energy endselect endfunction real_mul function negative ( self ) result ( opr ) !< Unary operator `- field`. class ( conservative_compressible ), intent ( in ) :: self !< conservative. class ( field_object ), allocatable :: opr !< Operator result. allocate ( conservative_compressible :: opr ) select type ( opr ) class is ( conservative_compressible ) opr % density = - self % density opr % momentum = - self % momentum opr % energy = - self % energy endselect endfunction negative elemental function sub ( lhs , rhs ) result ( opr ) !< Operator `-`. class ( conservative_compressible ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( conservative_compressible :: opr ) select type ( opr ) class is ( conservative_compressible ) select type ( rhs ) class is ( conservative_compressible ) opr % density = lhs % density - rhs % density opr % momentum = lhs % momentum - rhs % momentum opr % energy = lhs % energy - rhs % energy endselect endselect endfunction sub elemental function pow_integer ( lhs , rhs ) result ( opr ) !< Operator `field ** integer`. class ( conservative_compressible ), intent ( in ) :: lhs !< Left hand side. integer ( I4P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( conservative_compressible :: opr ) select type ( opr ) class is ( conservative_compressible ) opr % density = lhs % density ** rhs opr % momentum % x = lhs % momentum % x ** rhs opr % momentum % y = lhs % momentum % y ** rhs opr % momentum % z = lhs % momentum % z ** rhs opr % energy = lhs % energy ** rhs endselect endfunction pow_integer elemental function pow_real ( lhs , rhs ) result ( opr ) !< Operator `field ** real`. class ( conservative_compressible ), intent ( in ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( conservative_compressible :: opr ) select type ( opr ) class is ( conservative_compressible ) opr % density = lhs % density ** rhs opr % momentum % x = lhs % momentum % x ** rhs opr % momentum % y = lhs % momentum % y ** rhs opr % momentum % z = lhs % momentum % z ** rhs opr % energy = lhs % energy ** rhs endselect endfunction pow_real elemental function eq ( lhs , rhs ) result ( opr ) !< Operator `=='. class ( conservative_compressible ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. logical :: opr !< Operator result. select type ( rhs ) class is ( conservative_compressible ) opr = lhs % density == rhs % density if ( opr ) opr = lhs % momentum == rhs % momentum if ( opr ) opr = lhs % energy == rhs % energy endselect endfunction eq elemental function not_eq ( lhs , rhs ) result ( opr ) !< Operator `/='. class ( conservative_compressible ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. logical :: opr !< Operator result. opr = . not .( lhs % eq ( rhs = rhs )) endfunction not_eq ! private non TBP pure function conservative_compressible_instance ( density , velocity , pressure ) result ( instance ) !< Return and instance of [[conservative_compressible]]. !< !< @note This procedure is used for overloading [[conservative_compressible]] name. real ( R8P ), intent ( in ), optional :: density !< Density field. type ( vector ), intent ( in ), optional :: velocity !< Velocity field. real ( R8P ), intent ( in ), optional :: pressure !< Pressure field. type ( conservative_compressible ) :: instance !< Instance of [[conservative_compressible]]. if ( present ( density )) instance % density = density if ( present ( velocity )) instance % momentum = velocity if ( present ( pressure )) instance % energy = pressure endfunction conservative_compressible_instance endmodule flow_conservative_compressible","tags":"","loc":"sourcefile/flow_conservative_compressible.f90.html","title":"flow_conservative_compressible.f90 – FLOw"},{"text":"FLOw conservative abstract object. This File Depends On sourcefile~~flow_conservative_object.f90~~EfferentGraph sourcefile~flow_conservative_object.f90 flow_conservative_object.f90 sourcefile~flow_field_object.f90 flow_field_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow_conservative_object.f90 sourcefile~vecfor.f90 vecfor.F90 sourcefile~vecfor.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_eos_object.f90 flow_eos_object.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_conservative_object.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~flow_conservative_object.f90 sourcefile~penf.f90->sourcefile~flow_field_object.f90 sourcefile~penf.f90->sourcefile~flow_eos_object.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 var pansourcefileflow_conservative_objectf90EfferentGraph = svgPanZoom('#sourcefileflow_conservative_objectf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~flow_conservative_object.f90~~AfferentGraph sourcefile~flow_conservative_object.f90 flow_conservative_object.f90 sourcefile~flow_conservative_compressible.f90 flow_conservative_compressible.f90 sourcefile~flow_conservative_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow.f90 flow.f90 sourcefile~flow_conservative_object.f90->sourcefile~flow.f90 sourcefile~flow_conservative_compressible.f90->sourcefile~flow.f90 sourcefile~flow_compressible_transformations.f90 flow_compressible_transformations.f90 sourcefile~flow_conservative_compressible.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_test_primitive_compressible_sub.f90 flow_test_primitive_compressible_sub.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_sub.f90 sourcefile~flow_test_conservative_compressible_assign.f90 flow_test_conservative_compressible_assign.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_assign.f90 sourcefile~flow_test_conservative_compressible_add.f90 flow_test_conservative_compressible_add.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_add.f90 sourcefile~flow_test_conservative_compressible_div.f90 flow_test_conservative_compressible_div.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_div.f90 sourcefile~flow_test_conservative_compressible_eq.f90 flow_test_conservative_compressible_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_eq.f90 sourcefile~flow_test_conservative_compressible_mul.f90 flow_test_conservative_compressible_mul.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_mul.f90 sourcefile~flow_test_conservative_compressible_not_eq.f90 flow_test_conservative_compressible_not_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_not_eq.f90 sourcefile~flow_test_conservative_compressible_pow.f90 flow_test_conservative_compressible_pow.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_pow.f90 sourcefile~flow_test_conservative_compressible_sub.f90 flow_test_conservative_compressible_sub.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_sub.f90 sourcefile~flow_test_eos_compressible.f90 flow_test_eos_compressible.f90 sourcefile~flow.f90->sourcefile~flow_test_eos_compressible.f90 sourcefile~flow_test_primitive_compressible_add.f90 flow_test_primitive_compressible_add.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_add.f90 sourcefile~flow_test_primitive_compressible_assign.f90 flow_test_primitive_compressible_assign.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_assign.f90 sourcefile~flow_test_primitive_compressible_div.f90 flow_test_primitive_compressible_div.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_div.f90 sourcefile~flow_test_primitive_compressible_eq.f90 flow_test_primitive_compressible_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_eq.f90 sourcefile~flow_test_primitive_compressible_mul.f90 flow_test_primitive_compressible_mul.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_mul.f90 sourcefile~flow_test_primitive_compressible_multispecie_add.f90 flow_test_primitive_compressible_multispecie_add.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_add.f90 sourcefile~flow_test_primitive_compressible_multispecie_assign.f90 flow_test_primitive_compressible_multispecie_assign.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_assign.f90 sourcefile~flow_test_primitive_compressible_multispecie_div.f90 flow_test_primitive_compressible_multispecie_div.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_div.f90 sourcefile~flow_test_primitive_compressible_multispecie_eq.f90 flow_test_primitive_compressible_multispecie_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_eq.f90 sourcefile~flow_test_primitive_compressible_multispecie_mul.f90 flow_test_primitive_compressible_multispecie_mul.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_mul.f90 sourcefile~flow_test_primitive_compressible_multispecie_not_eq.f90 flow_test_primitive_compressible_multispecie_not_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_not_eq.f90 sourcefile~flow_test_primitive_compressible_multispecie_pow.f90 flow_test_primitive_compressible_multispecie_pow.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_pow.f90 sourcefile~flow_test_primitive_compressible_multispecie_sub.f90 flow_test_primitive_compressible_multispecie_sub.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_sub.f90 sourcefile~flow_test_primitive_compressible_not_eq.f90 flow_test_primitive_compressible_not_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_not_eq.f90 sourcefile~flow_test_primitive_compressible_pow.f90 flow_test_primitive_compressible_pow.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_pow.f90 sourcefile~flow_test_compressible_transformations.f90 flow_test_compressible_transformations.f90 sourcefile~flow.f90->sourcefile~flow_test_compressible_transformations.f90 sourcefile~flow_compressible_transformations.f90->sourcefile~flow.f90 var pansourcefileflow_conservative_objectf90AfferentGraph = svgPanZoom('#sourcefileflow_conservative_objectf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules flow_conservative_object Source Code flow_conservative_object.f90 Source Code !< FLOw **conservative** abstract object. module flow_conservative_object !< FLOw **conservative** abstract object. !< !< [[conservative_object]] is a class that handles conservative fluid dynamic variables. use flow_eos_object , only : eos_object use flow_field_object , only : field_object use penf , only : R8P use vecfor , only : vector implicit none private public :: conservative_object type , extends ( field_object ), abstract :: conservative_object !< **conservative** object. contains ! deferred methods procedure ( compute_fluxes_interface ), pass ( self ), deferred :: compute_fluxes !< Compute conservative fluxes. procedure ( destroy_interface ), pass ( self ), deferred :: destroy !< Destroy conservative. procedure ( initialize_interface ), pass ( self ), deferred :: initialize !< Initialize conservative. procedure ( pressure_interface ), pass ( self ), deferred :: pressure !< Return pressure value. procedure ( velocity_interface ), pass ( self ), deferred :: velocity !< Return velocity vector. endtype conservative_object abstract interface !< Abstract interfaces of deferred methods of [[conservative_object]]. subroutine compute_fluxes_interface ( self , eos , normal , fluxes ) !< Compute conservative fluxes. import :: conservative_object , eos_object , vector class ( conservative_object ), intent ( in ) :: self !< Conservative. class ( eos_object ), intent ( in ) :: eos !< Equation of state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. class ( conservative_object ), intent ( out ) :: fluxes !< Conservative fluxes. endsubroutine compute_fluxes_interface elemental subroutine destroy_interface ( self ) !< Destroy conservative. import :: conservative_object class ( conservative_object ), intent ( inout ) :: self !< conservative. endsubroutine destroy_interface subroutine initialize_interface ( self , initial_state ) !< Initialize conservative. import :: conservative_object class ( conservative_object ), intent ( inout ) :: self !< conservative. class ( conservative_object ), optional , intent ( in ) :: initial_state !< Initial state. endsubroutine initialize_interface elemental function pressure_interface ( self , eos ) result ( pressure_ ) !< Return pressure value. import :: conservative_object , eos_object , R8P class ( conservative_object ), intent ( in ) :: self !< Conservative. class ( eos_object ), intent ( in ) :: eos !< Equation of state. real ( R8P ) :: pressure_ !< Pressure value. endfunction pressure_interface elemental function velocity_interface ( self ) result ( velocity_ ) !< Return velocity vector. import :: conservative_object , vector class ( conservative_object ), intent ( in ) :: self !< Conservative. type ( vector ) :: velocity_ !< Velocity vector. endfunction velocity_interface endinterface endmodule flow_conservative_object","tags":"","loc":"sourcefile/flow_conservative_object.f90.html","title":"flow_conservative_object.f90 – FLOw"},{"text":"FLOw EOS (Equation of State) of ideal compressible fluid object. This File Depends On sourcefile~~flow_eos_compressible.f90~~EfferentGraph sourcefile~flow_eos_compressible.f90 flow_eos_compressible.f90 sourcefile~flow_eos_object.f90 flow_eos_object.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_eos_compressible.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~flow_eos_compressible.f90 sourcefile~penf.f90->sourcefile~flow_eos_object.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 var pansourcefileflow_eos_compressiblef90EfferentGraph = svgPanZoom('#sourcefileflow_eos_compressiblef90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~flow_eos_compressible.f90~~AfferentGraph sourcefile~flow_eos_compressible.f90 flow_eos_compressible.f90 sourcefile~flow.f90 flow.f90 sourcefile~flow_eos_compressible.f90->sourcefile~flow.f90 sourcefile~flow_test_primitive_compressible_sub.f90 flow_test_primitive_compressible_sub.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_sub.f90 sourcefile~flow_test_conservative_compressible_assign.f90 flow_test_conservative_compressible_assign.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_assign.f90 sourcefile~flow_test_conservative_compressible_add.f90 flow_test_conservative_compressible_add.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_add.f90 sourcefile~flow_test_conservative_compressible_div.f90 flow_test_conservative_compressible_div.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_div.f90 sourcefile~flow_test_conservative_compressible_eq.f90 flow_test_conservative_compressible_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_eq.f90 sourcefile~flow_test_conservative_compressible_mul.f90 flow_test_conservative_compressible_mul.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_mul.f90 sourcefile~flow_test_conservative_compressible_not_eq.f90 flow_test_conservative_compressible_not_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_not_eq.f90 sourcefile~flow_test_conservative_compressible_pow.f90 flow_test_conservative_compressible_pow.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_pow.f90 sourcefile~flow_test_conservative_compressible_sub.f90 flow_test_conservative_compressible_sub.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_sub.f90 sourcefile~flow_test_eos_compressible.f90 flow_test_eos_compressible.f90 sourcefile~flow.f90->sourcefile~flow_test_eos_compressible.f90 sourcefile~flow_test_primitive_compressible_add.f90 flow_test_primitive_compressible_add.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_add.f90 sourcefile~flow_test_primitive_compressible_assign.f90 flow_test_primitive_compressible_assign.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_assign.f90 sourcefile~flow_test_primitive_compressible_div.f90 flow_test_primitive_compressible_div.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_div.f90 sourcefile~flow_test_primitive_compressible_eq.f90 flow_test_primitive_compressible_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_eq.f90 sourcefile~flow_test_primitive_compressible_mul.f90 flow_test_primitive_compressible_mul.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_mul.f90 sourcefile~flow_test_primitive_compressible_multispecie_add.f90 flow_test_primitive_compressible_multispecie_add.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_add.f90 sourcefile~flow_test_primitive_compressible_multispecie_assign.f90 flow_test_primitive_compressible_multispecie_assign.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_assign.f90 sourcefile~flow_test_primitive_compressible_multispecie_div.f90 flow_test_primitive_compressible_multispecie_div.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_div.f90 sourcefile~flow_test_primitive_compressible_multispecie_eq.f90 flow_test_primitive_compressible_multispecie_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_eq.f90 sourcefile~flow_test_primitive_compressible_multispecie_mul.f90 flow_test_primitive_compressible_multispecie_mul.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_mul.f90 sourcefile~flow_test_primitive_compressible_multispecie_not_eq.f90 flow_test_primitive_compressible_multispecie_not_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_not_eq.f90 sourcefile~flow_test_primitive_compressible_multispecie_pow.f90 flow_test_primitive_compressible_multispecie_pow.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_pow.f90 sourcefile~flow_test_primitive_compressible_multispecie_sub.f90 flow_test_primitive_compressible_multispecie_sub.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_sub.f90 sourcefile~flow_test_primitive_compressible_not_eq.f90 flow_test_primitive_compressible_not_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_not_eq.f90 sourcefile~flow_test_primitive_compressible_pow.f90 flow_test_primitive_compressible_pow.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_pow.f90 sourcefile~flow_test_compressible_transformations.f90 flow_test_compressible_transformations.f90 sourcefile~flow.f90->sourcefile~flow_test_compressible_transformations.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules flow_eos_compressible Source Code flow_eos_compressible.f90 Source Code !< FLOw **EOS** (Equation of State) of ideal compressible fluid object. module flow_eos_compressible !< FLOw **EOS** (Equation of State) of ideal compressible fluid object. use flow_eos_object , only : eos_object use penf , only : R8P , str implicit none private public :: eos_compressible type , extends ( eos_object ) :: eos_compressible !< Equation of state (EOS) of ideal compressible object class. private real ( R8P ) :: cp_ = 0._R8P !< Specific heat at constant pressure `cp`. real ( R8P ) :: cv_ = 0._R8P !< Specific heat at constant volume `cv`. real ( R8P ) :: g_ = 0._R8P !< Specific heats ratio `gamma = cp / cv`. real ( R8P ) :: R_ = 0._R8P !< Fluid constant `R = cp - cv`. real ( R8P ) :: gm1_ = 0._R8P !< `gamma - 1`. real ( R8P ) :: gp1_ = 0._R8P !< `gamma + 1`. real ( R8P ) :: delta_ = 0._R8P !< `(gamma - 1) / 2`. real ( R8P ) :: eta_ = 0._R8P !< `2 * gamma / (gamma - 1)`. contains ! public methods procedure , pass ( self ) :: compute_derivate !< Compute derivate quantities (from `cp` and `cv`). ! deferred methods procedure , pass ( self ) :: cp !< Return specific heat at constant pressure. procedure , pass ( self ) :: cv !< Return specific heat at constant volume. procedure , pass ( self ) :: delta !< Return `(gamma - 1) / 2`. procedure , pass ( self ) :: density !< Return density. procedure , pass ( self ) :: description !< Return pretty-printed object description. procedure , pass ( lhs ) :: eos_assign_eos !< Operator `=`. procedure , pass ( self ) :: eta !< Return `2 * gamma / (gamma - 1)`. procedure , pass ( self ) :: g !< Return specific heats ratio `gamma=cp/cv`. procedure , pass ( self ) :: gm1 !< Return `gamma - 1`. procedure , pass ( self ) :: gp1 !< Return `gamma + 1`. procedure , pass ( self ) :: internal_energy !< Return specific internal energy. procedure , pass ( self ) :: pressure !< Return pressure. procedure , pass ( self ) :: R !< Return fluid constant `R=cp-cv`. procedure , pass ( self ) :: speed_of_sound !< Return speed of sound. procedure , pass ( self ) :: temperature !< Return temperature. procedure , pass ( self ) :: total_entalpy !< Return total specific entalpy. endtype eos_compressible interface eos_compressible !< Overload [[eos_compressible]] name with its constructor. module procedure eos_compressible_instance endinterface contains ! public methods elemental subroutine compute_derivate ( self ) !< Compute derivate quantities (from `cp` and `cv`). class ( eos_compressible ), intent ( inout ) :: self !< Equation of state. self % g_ = self % cp_ / self % cv_ self % R_ = self % cp_ - self % cv_ self % gm1_ = self % g_ - 1._R8P self % gp1_ = self % g_ + 1._R8P self % delta_ = ( self % g_ - 1._R8P ) * 0.5_R8P self % eta_ = 2._R8P * self % g_ / ( self % g_ - 1._R8P ) endsubroutine compute_derivate ! deferred methods elemental function cp ( self ) result ( cp_ ) !< Return specific heat at constant pressure. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ) :: cp_ !< `cp` value. cp_ = self % cp_ endfunction cp elemental function cv ( self ) result ( cv_ ) !< Return specific heat at constant volume. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ) :: cv_ !< `cv` value. cv_ = self % cv_ endfunction cv elemental function delta ( self ) result ( delta_ ) !< Return `(gamma - 1) / 2`. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ) :: delta_ !< `(gamma - 1) / 2` value. delta_ = self % delta_ endfunction delta elemental function density ( self , pressure , speed_of_sound ) result ( density_ ) !< Return density. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ), intent ( in ) :: pressure !< Pressure value. real ( R8P ), intent ( in ) :: speed_of_sound !< Speed of sound value. real ( R8P ) :: density_ !< Density value. density_ = self % g_ * pressure / ( speed_of_sound * speed_of_sound ) endfunction density pure function description ( self , prefix ) result ( desc ) !< Return a pretty-formatted object description. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. character ( * ), intent ( in ), optional :: prefix !< Prefixing string. character ( len = :), allocatable :: desc !< Description. character ( len = :), allocatable :: prefix_ !< Prefixing string, local variable. character ( len = 1 ), parameter :: NL = new_line ( 'a' ) !< New line character. prefix_ = '' ; if ( present ( prefix )) prefix_ = prefix desc = '' desc = desc // prefix_ // 'cp  = ' // trim ( str ( n = self % cp_ )) // NL desc = desc // prefix_ // 'cv  = ' // trim ( str ( n = self % cv_ )) endfunction description elemental function eta ( self ) result ( eta_ ) !< Return `2 * gamma / (gamma - 1)`. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ) :: eta_ !< `2 * gamma / (gamma - 1)` value. eta_ = self % eta_ endfunction eta elemental function g ( self ) result ( g_ ) !< Return specific heats ratio `gamma=cp/cv`. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ) :: g_ !< Specific heats ratio value. g_ = self % g_ endfunction g elemental function gm1 ( self ) result ( gm1_ ) !< Return `gamma - 1`. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ) :: gm1_ !< `gamma - 1` value. gm1_ = self % gm1_ endfunction gm1 elemental function gp1 ( self ) result ( gp1_ ) !< Return `gamma + 1`. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ) :: gp1_ !< `gamma + 1` value. gp1_ = self % gp1_ endfunction gp1 elemental function internal_energy ( self , density , pressure , temperature ) result ( energy_ ) !< Return specific internal energy. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ), intent ( in ), optional :: density !< Density value. real ( R8P ), intent ( in ), optional :: pressure !< Pressure value. real ( R8P ), intent ( in ), optional :: temperature !< Temperature value. real ( R8P ) :: energy_ !< Energy value. energy_ = 0._R8P if ( present ( density ). and . present ( pressure )) then energy_ = pressure / (( self % g_ - 1._R8P ) * density ) elseif ( present ( temperature )) then energy_ = self % cv () * temperature endif endfunction internal_energy elemental function pressure ( self , density , energy , temperature ) result ( pressure_ ) !< Return pressure. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ), intent ( in ), optional :: density !< Density value. real ( R8P ), intent ( in ), optional :: energy !< Specific internal energy value. real ( R8P ), intent ( in ), optional :: temperature !< Temperature value. real ( R8P ) :: pressure_ !< Pressure value. pressure_ = 0._R8P if ( present ( density ). and . present ( energy )) then pressure_ = density * ( self % g_ - 1._R8P ) * energy elseif ( present ( density ). and . present ( temperature )) then pressure_ = density * self % R_ * temperature endif endfunction pressure elemental function R ( self ) result ( R_ ) !< Return fluid constant `R=cp-cv`. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ) :: R_ !< Fluid constant value. R_ = self % R_ endfunction R elemental function speed_of_sound ( self , density , pressure ) result ( speed_of_sound_ ) !< Return speed of sound. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ), intent ( in ) :: density !< Density value. real ( R8P ), intent ( in ) :: pressure !< Pressure value. real ( R8P ) :: speed_of_sound_ !< Speed of sound value. speed_of_sound_ = sqrt ( self % g_ * pressure / density ) endfunction speed_of_sound elemental function temperature ( self , density , energy , pressure ) result ( temperature_ ) !< Return temperature. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ), intent ( in ), optional :: density !< Density value. real ( R8P ), intent ( in ), optional :: energy !< Specific internal energy value. real ( R8P ), intent ( in ), optional :: pressure !< Pressure value. real ( R8P ) :: temperature_ !< Temperature value. temperature_ = 0._R8P if ( present ( density ). and . present ( pressure )) then temperature_ = pressure / ( self % R_ * density ) elseif ( present ( energy )) then temperature_ = energy / self % cv () endif endfunction temperature elemental function total_entalpy ( self , density , pressure , velocity_sq_norm ) result ( entalpy_ ) !< Return total specific entalpy. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ), intent ( in ) :: density !< Density value. real ( R8P ), intent ( in ) :: pressure !< Pressure value. real ( R8P ), intent ( in ) :: velocity_sq_norm !< Velocity vector square norm `||velocity||&#94;2`. real ( R8P ) :: entalpy_ !< Total specific entalpy (per unit of mass). entalpy_ = self % g_ * pressure / ( self % gm1_ * density ) + 0.5_R8P * velocity_sq_norm endfunction total_entalpy ! operators pure subroutine eos_assign_eos ( lhs , rhs ) !< Operator `=`. class ( eos_compressible ), intent ( inout ) :: lhs !< Left hand side. class ( eos_object ), intent ( in ) :: rhs !< Right hand side. select type ( rhs ) class is ( eos_compressible ) lhs % cp_ = rhs % cp_ lhs % cv_ = rhs % cv_ lhs % g_ = rhs % g_ lhs % R_ = rhs % R_ lhs % delta_ = rhs % delta_ lhs % eta_ = rhs % eta_ lhs % gm1_ = rhs % gm1_ lhs % gp1_ = rhs % gp1_ endselect endsubroutine eos_assign_eos ! private non TBP elemental function eos_compressible_instance ( cp , cv , gam , R ) result ( instance ) !< Return and instance of [[eos_compressible]]. !< !< @note This procedure is used for overloading [[eos_compressible]] name. real ( R8P ), intent ( in ), optional :: cp !< Specific heat at constant pressure `cp` value. real ( R8P ), intent ( in ), optional :: cv !< Specific heat at constant volume `cv` value. real ( R8P ), intent ( in ), optional :: gam !< Specific heats ratio `gamma=cp/cv` value. real ( R8P ), intent ( in ), optional :: R !< Fluid constant `R=cp-cv` value. type ( eos_compressible ) :: instance !< Instance of [[eos_compressible]]. if ( present ( cp ). and . present ( cv )) then instance % cp_ = cp instance % cv_ = cv elseif ( present ( gam ). and . present ( R )) then instance % cv_ = R / ( gam - 1._R8P ) instance % cp_ = gam * instance % cv_ elseif ( present ( gam ). and . present ( cp )) then instance % cp_ = cp instance % cv_ = cp / gam elseif ( present ( gam ). and . present ( cv )) then instance % cp_ = gam * cv instance % cv_ = cv elseif ( present ( R ). and . present ( cp )) then instance % cp_ = cp instance % cv_ = cp - R elseif ( present ( R ). and . present ( cv )) then instance % cp_ = cv + R instance % cv_ = cv endif call instance % compute_derivate endfunction eos_compressible_instance endmodule flow_eos_compressible","tags":"","loc":"sourcefile/flow_eos_compressible.f90.html","title":"flow_eos_compressible.f90 – FLOw"},{"text":"FLOw EOS (Equation of State) object. This File Depends On sourcefile~~flow_eos_object.f90~~EfferentGraph sourcefile~flow_eos_object.f90 flow_eos_object.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~flow_eos_object.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 var pansourcefileflow_eos_objectf90EfferentGraph = svgPanZoom('#sourcefileflow_eos_objectf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~flow_eos_object.f90~~AfferentGraph sourcefile~flow_eos_object.f90 flow_eos_object.f90 sourcefile~flow_eos_compressible.f90 flow_eos_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_eos_compressible.f90 sourcefile~flow.f90 flow.f90 sourcefile~flow_eos_object.f90->sourcefile~flow.f90 sourcefile~flow_primitive_compressible_multispecie.f90 flow_primitive_compressible_multispecie.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_conservative_compressible.f90 flow_conservative_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_primitive_compressible.f90 flow_primitive_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_compressible_transformations.f90 flow_compressible_transformations.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_primitive_object.f90 flow_primitive_object.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_conservative_object.f90 flow_conservative_object.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_eos_compressible.f90->sourcefile~flow.f90 sourcefile~flow_test_primitive_compressible_sub.f90 flow_test_primitive_compressible_sub.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_sub.f90 sourcefile~flow_test_conservative_compressible_assign.f90 flow_test_conservative_compressible_assign.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_assign.f90 sourcefile~flow_test_conservative_compressible_add.f90 flow_test_conservative_compressible_add.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_add.f90 sourcefile~flow_test_conservative_compressible_div.f90 flow_test_conservative_compressible_div.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_div.f90 sourcefile~flow_test_conservative_compressible_eq.f90 flow_test_conservative_compressible_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_eq.f90 sourcefile~flow_test_conservative_compressible_mul.f90 flow_test_conservative_compressible_mul.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_mul.f90 sourcefile~flow_test_conservative_compressible_not_eq.f90 flow_test_conservative_compressible_not_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_not_eq.f90 sourcefile~flow_test_conservative_compressible_pow.f90 flow_test_conservative_compressible_pow.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_pow.f90 sourcefile~flow_test_conservative_compressible_sub.f90 flow_test_conservative_compressible_sub.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_sub.f90 sourcefile~flow_test_eos_compressible.f90 flow_test_eos_compressible.f90 sourcefile~flow.f90->sourcefile~flow_test_eos_compressible.f90 sourcefile~flow_test_primitive_compressible_add.f90 flow_test_primitive_compressible_add.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_add.f90 sourcefile~flow_test_primitive_compressible_assign.f90 flow_test_primitive_compressible_assign.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_assign.f90 sourcefile~flow_test_primitive_compressible_div.f90 flow_test_primitive_compressible_div.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_div.f90 sourcefile~flow_test_primitive_compressible_eq.f90 flow_test_primitive_compressible_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_eq.f90 sourcefile~flow_test_primitive_compressible_mul.f90 flow_test_primitive_compressible_mul.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_mul.f90 sourcefile~flow_test_primitive_compressible_multispecie_add.f90 flow_test_primitive_compressible_multispecie_add.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_add.f90 sourcefile~flow_test_primitive_compressible_multispecie_assign.f90 flow_test_primitive_compressible_multispecie_assign.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_assign.f90 sourcefile~flow_test_primitive_compressible_multispecie_div.f90 flow_test_primitive_compressible_multispecie_div.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_div.f90 sourcefile~flow_test_primitive_compressible_multispecie_eq.f90 flow_test_primitive_compressible_multispecie_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_eq.f90 sourcefile~flow_test_primitive_compressible_multispecie_mul.f90 flow_test_primitive_compressible_multispecie_mul.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_mul.f90 sourcefile~flow_test_primitive_compressible_multispecie_not_eq.f90 flow_test_primitive_compressible_multispecie_not_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_not_eq.f90 sourcefile~flow_test_primitive_compressible_multispecie_pow.f90 flow_test_primitive_compressible_multispecie_pow.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_pow.f90 sourcefile~flow_test_primitive_compressible_multispecie_sub.f90 flow_test_primitive_compressible_multispecie_sub.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_sub.f90 sourcefile~flow_test_primitive_compressible_not_eq.f90 flow_test_primitive_compressible_not_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_not_eq.f90 sourcefile~flow_test_primitive_compressible_pow.f90 flow_test_primitive_compressible_pow.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_pow.f90 sourcefile~flow_test_compressible_transformations.f90 flow_test_compressible_transformations.f90 sourcefile~flow.f90->sourcefile~flow_test_compressible_transformations.f90 sourcefile~flow_primitive_compressible_multispecie.f90->sourcefile~flow.f90 sourcefile~flow_conservative_compressible.f90->sourcefile~flow.f90 sourcefile~flow_conservative_compressible.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_primitive_compressible.f90->sourcefile~flow.f90 sourcefile~flow_primitive_compressible.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_compressible_transformations.f90->sourcefile~flow.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_conservative_object.f90->sourcefile~flow.f90 sourcefile~flow_conservative_object.f90->sourcefile~flow_conservative_compressible.f90 var pansourcefileflow_eos_objectf90AfferentGraph = svgPanZoom('#sourcefileflow_eos_objectf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules flow_eos_object Source Code flow_eos_object.f90 Source Code !< FLOw **EOS** (Equation of State) object. module flow_eos_object !< FLOw **EOS** (Equation of State) object. use penf , only : R8P implicit none private public :: eos_object type , abstract :: eos_object !< Equation of State (EOS) object class. contains ! deferred methods procedure ( scalar_interface ), pass ( self ), deferred :: cp !< Return specific heat at constant pressure. procedure ( scalar_interface ), pass ( self ), deferred :: cv !< Return specific heat at constant volume. procedure ( density_interface ), pass ( self ), deferred :: density !< Return density. procedure ( scalar_interface ), pass ( self ), deferred :: delta !< Return `(gamma - 1) / 2`. procedure ( description_interface ), pass ( self ), deferred :: description !< Return pretty-printed object description. procedure ( assignment_interface ), pass ( lhs ), deferred :: eos_assign_eos !< Operator `=`. procedure ( scalar_interface ), pass ( self ), deferred :: eta !< Return `2 * gamma / (gamma - 1)`. procedure ( scalar_interface ), pass ( self ), deferred :: g !< Return specific heats ratio `gamma=cp/cv`. procedure ( scalar_interface ), pass ( self ), deferred :: gm1 !< Return `gamma - 1`. procedure ( scalar_interface ), pass ( self ), deferred :: gp1 !< Return `gamma + 1`. procedure ( internal_energy_interface ), pass ( self ), deferred :: internal_energy !< Return specific internal energy. procedure ( pressure_interface ), pass ( self ), deferred :: pressure !< Return pressure. procedure ( scalar_interface ), pass ( self ), deferred :: R !< Return fluid constant `R=cp-cv`. procedure ( speed_of_sound_interface ), pass ( self ), deferred :: speed_of_sound !< Return speed of sound. procedure ( temperature_interface ), pass ( self ), deferred :: temperature !< Return temperature. procedure ( total_entalpy_interface ), pass ( self ), deferred :: total_entalpy !< Return total specific entalpy. ! operators generic :: assignment ( = ) => eos_assign_eos !< Overload `=`. endtype eos_object abstract interface !< Abstract interfaces of deferred methods of [[eos_object]]. pure subroutine assignment_interface ( lhs , rhs ) !< Operator `=`. import :: eos_object class ( eos_object ), intent ( inout ) :: lhs !< Left hand side. class ( eos_object ), intent ( in ) :: rhs !< Right hand side. endsubroutine assignment_interface elemental function density_interface ( self , pressure , speed_of_sound ) result ( density_ ) !< Return density. import :: eos_object , R8P class ( eos_object ), intent ( in ) :: self !< Equation of state. real ( R8P ), intent ( in ) :: pressure !< Pressure value. real ( R8P ), intent ( in ) :: speed_of_sound !< Speed of sound value. real ( R8P ) :: density_ !< Density value. endfunction density_interface pure function description_interface ( self , prefix ) result ( desc ) !< Return a pretty-formatted object description. import :: eos_object class ( eos_object ), intent ( in ) :: self !< Equation of state. character ( * ), intent ( in ), optional :: prefix !< Prefixing string. character ( len = :), allocatable :: desc !< Description. endfunction description_interface elemental function internal_energy_interface ( self , density , pressure , temperature ) result ( energy_ ) !< Return specific internal energy. import :: eos_object , R8P class ( eos_object ), intent ( in ) :: self !< Equation of state. real ( R8P ), intent ( in ), optional :: density !< Density value. real ( R8P ), intent ( in ), optional :: pressure !< Pressure value. real ( R8P ), intent ( in ), optional :: temperature !< Temperature value. real ( R8P ) :: energy_ !< Energy value. endfunction internal_energy_interface elemental function pressure_interface ( self , density , energy , temperature ) result ( pressure_ ) !< Return pressure. import :: eos_object , R8P class ( eos_object ), intent ( in ) :: self !< Equation of state. real ( R8P ), intent ( in ), optional :: density !< Density value. real ( R8P ), intent ( in ), optional :: energy !< Specific internal energy value. real ( R8P ), intent ( in ), optional :: temperature !< Temperature value. real ( R8P ) :: pressure_ !< Pressure value. endfunction pressure_interface elemental function scalar_interface ( self ) result ( scalar_ ) !< Return a scalar real value by only `self` data. import :: eos_object , R8P class ( eos_object ), intent ( in ) :: self !< Equation of state. real ( R8P ) :: scalar_ !< Scalar value. endfunction scalar_interface elemental function speed_of_sound_interface ( self , density , pressure ) result ( speed_of_sound_ ) !< Return speed of sound. import :: eos_object , R8P class ( eos_object ), intent ( in ) :: self !< Equation of state. real ( R8P ), intent ( in ) :: density !< Density value. real ( R8P ), intent ( in ) :: pressure !< Pressure value. real ( R8P ) :: speed_of_sound_ !< Speed of sound value. endfunction speed_of_sound_interface elemental function temperature_interface ( self , density , energy , pressure ) result ( temperature_ ) !< Return temperature. import :: eos_object , R8P class ( eos_object ), intent ( in ) :: self !< Equation of state. real ( R8P ), intent ( in ), optional :: density !< Density value. real ( R8P ), intent ( in ), optional :: energy !< Specific internal energy value. real ( R8P ), intent ( in ), optional :: pressure !< Pressure value. real ( R8P ) :: temperature_ !< Temperature value. endfunction temperature_interface elemental function total_entalpy_interface ( self , density , pressure , velocity_sq_norm ) result ( entalpy_ ) !< Return total specific entalpy. import :: eos_object , R8P class ( eos_object ), intent ( in ) :: self !< Equation of state. real ( R8P ), intent ( in ) :: density !< Density value. real ( R8P ), intent ( in ) :: pressure !< Pressure value. real ( R8P ), intent ( in ) :: velocity_sq_norm !< Velocity vector square norm `||velocity||&#94;2`. real ( R8P ) :: entalpy_ !< Total specific entalpy (per unit of mass). endfunction total_entalpy_interface endinterface endmodule flow_eos_object","tags":"","loc":"sourcefile/flow_eos_object.f90.html","title":"flow_eos_object.f90 – FLOw"},{"text":"FLOw field abstract object. This File Depends On sourcefile~~flow_field_object.f90~~EfferentGraph sourcefile~flow_field_object.f90 flow_field_object.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~flow_field_object.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 var pansourcefileflow_field_objectf90EfferentGraph = svgPanZoom('#sourcefileflow_field_objectf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~flow_field_object.f90~~AfferentGraph sourcefile~flow_field_object.f90 flow_field_object.f90 sourcefile~flow_field_scalar_vectorial.f90 flow_field_scalar_vectorial.f90 sourcefile~flow_field_object.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~flow_primitive_compressible_multispecie.f90 flow_primitive_compressible_multispecie.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_conservative_compressible.f90 flow_conservative_compressible.f90 sourcefile~flow_field_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow.f90 flow.f90 sourcefile~flow_field_object.f90->sourcefile~flow.f90 sourcefile~flow_primitive_compressible.f90 flow_primitive_compressible.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_primitive_object.f90 flow_primitive_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_conservative_object.f90 flow_conservative_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_field_scalar_vectorial.f90->sourcefile~flow.f90 sourcefile~flow_primitive_compressible_multispecie.f90->sourcefile~flow.f90 sourcefile~flow_conservative_compressible.f90->sourcefile~flow.f90 sourcefile~flow_compressible_transformations.f90 flow_compressible_transformations.f90 sourcefile~flow_conservative_compressible.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_test_primitive_compressible_sub.f90 flow_test_primitive_compressible_sub.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_sub.f90 sourcefile~flow_test_conservative_compressible_assign.f90 flow_test_conservative_compressible_assign.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_assign.f90 sourcefile~flow_test_conservative_compressible_add.f90 flow_test_conservative_compressible_add.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_add.f90 sourcefile~flow_test_conservative_compressible_div.f90 flow_test_conservative_compressible_div.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_div.f90 sourcefile~flow_test_conservative_compressible_eq.f90 flow_test_conservative_compressible_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_eq.f90 sourcefile~flow_test_conservative_compressible_mul.f90 flow_test_conservative_compressible_mul.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_mul.f90 sourcefile~flow_test_conservative_compressible_not_eq.f90 flow_test_conservative_compressible_not_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_not_eq.f90 sourcefile~flow_test_conservative_compressible_pow.f90 flow_test_conservative_compressible_pow.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_pow.f90 sourcefile~flow_test_conservative_compressible_sub.f90 flow_test_conservative_compressible_sub.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_sub.f90 sourcefile~flow_test_eos_compressible.f90 flow_test_eos_compressible.f90 sourcefile~flow.f90->sourcefile~flow_test_eos_compressible.f90 sourcefile~flow_test_primitive_compressible_add.f90 flow_test_primitive_compressible_add.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_add.f90 sourcefile~flow_test_primitive_compressible_assign.f90 flow_test_primitive_compressible_assign.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_assign.f90 sourcefile~flow_test_primitive_compressible_div.f90 flow_test_primitive_compressible_div.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_div.f90 sourcefile~flow_test_primitive_compressible_eq.f90 flow_test_primitive_compressible_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_eq.f90 sourcefile~flow_test_primitive_compressible_mul.f90 flow_test_primitive_compressible_mul.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_mul.f90 sourcefile~flow_test_primitive_compressible_multispecie_add.f90 flow_test_primitive_compressible_multispecie_add.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_add.f90 sourcefile~flow_test_primitive_compressible_multispecie_assign.f90 flow_test_primitive_compressible_multispecie_assign.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_assign.f90 sourcefile~flow_test_primitive_compressible_multispecie_div.f90 flow_test_primitive_compressible_multispecie_div.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_div.f90 sourcefile~flow_test_primitive_compressible_multispecie_eq.f90 flow_test_primitive_compressible_multispecie_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_eq.f90 sourcefile~flow_test_primitive_compressible_multispecie_mul.f90 flow_test_primitive_compressible_multispecie_mul.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_mul.f90 sourcefile~flow_test_primitive_compressible_multispecie_not_eq.f90 flow_test_primitive_compressible_multispecie_not_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_not_eq.f90 sourcefile~flow_test_primitive_compressible_multispecie_pow.f90 flow_test_primitive_compressible_multispecie_pow.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_pow.f90 sourcefile~flow_test_primitive_compressible_multispecie_sub.f90 flow_test_primitive_compressible_multispecie_sub.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_sub.f90 sourcefile~flow_test_primitive_compressible_not_eq.f90 flow_test_primitive_compressible_not_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_not_eq.f90 sourcefile~flow_test_primitive_compressible_pow.f90 flow_test_primitive_compressible_pow.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_pow.f90 sourcefile~flow_test_compressible_transformations.f90 flow_test_compressible_transformations.f90 sourcefile~flow.f90->sourcefile~flow_test_compressible_transformations.f90 sourcefile~flow_primitive_compressible.f90->sourcefile~flow.f90 sourcefile~flow_primitive_compressible.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_conservative_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_conservative_object.f90->sourcefile~flow.f90 sourcefile~flow_compressible_transformations.f90->sourcefile~flow.f90 var pansourcefileflow_field_objectf90AfferentGraph = svgPanZoom('#sourcefileflow_field_objectf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules flow_field_object Source Code flow_field_object.f90 Source Code !< FLOw **field** abstract object. module flow_field_object !< FLOw **field** abstract object. use penf , only : I4P , R8P implicit none private public :: field_object type , abstract :: field_object !< **Field** abstract object. contains ! deferred methods procedure ( array_interface ), pass ( self ), deferred :: array !< Return serialized array of field. procedure ( description_interface ), pass ( self ), deferred :: description !< Return pretty-printed object description. ! deferred operators procedure ( assign_interface ), pass ( lhs ), deferred :: assign_field !< Operator `=`. procedure ( assign_real_interface ), pass ( lhs ), deferred :: assign_real !< Operator `field = real`. procedure ( unary_operator ), pass ( self ), deferred :: positive !< Unary operator `+ field`. procedure ( symmetric_op_interface ), pass ( lhs ), deferred :: add !< Operator `+`. procedure ( symmetric_op_interface ), pass ( lhs ), deferred :: div !< Operator `/`. procedure ( field_op_integer_interface ), pass ( lhs ), deferred :: div_integer !< Operator `field / integer`. procedure ( field_op_real_interface ), pass ( lhs ), deferred :: div_real !< Operator `field / real`. procedure ( symmetric_op_interface ), pass ( lhs ), deferred :: mul !< Operator `*`. procedure ( field_op_integer_interface ), pass ( lhs ), deferred :: mul_integer !< Operator `field * integer`. procedure ( integer_op_field_interface ), pass ( rhs ), deferred :: integer_mul !< Operator `integer * field`. procedure ( field_op_real_interface ), pass ( lhs ), deferred :: mul_real !< Operator `field * real`. procedure ( real_op_field_interface ), pass ( rhs ), deferred :: real_mul !< Operator `real * field`. procedure ( unary_operator ), pass ( self ), deferred :: negative !< Unary operator `- field`. procedure ( symmetric_op_interface ), pass ( lhs ), deferred :: sub !< Operator `-`. procedure ( field_op_integer_interface ), pass ( lhs ), deferred :: pow_integer !< Operator `field ** integer`. procedure ( field_op_real_interface ), pass ( lhs ), deferred :: pow_real !< Operator `field ** real`. procedure ( compare_interface ), pass ( lhs ), deferred :: eq !< Operator `=='. procedure ( compare_interface ), pass ( lhs ), deferred :: not_eq !< Operator `/='. ! public operators generic :: assignment ( = ) => assign_field , assign_real !< Assignment overloading. generic :: operator ( + ) => add , positive !< Operator `+` overloading. generic :: operator ( / ) => div , div_integer , div_real !< Operator `/` overloading. generic :: operator ( * ) => mul , mul_integer , integer_mul , real_mul , mul_real !< Operator `*` overloading. generic :: operator ( - ) => sub , negative !< Operator `-` overloading. generic :: operator ( ** ) => pow_integer , pow_real !< Operator `**` overloading. generic :: operator ( == ) => eq !< Operator `/=` overloading. generic :: operator ( /= ) => not_eq !< Operator `/=` overloading. endtype field_object abstract interface !< Abstract interfaces of deferred methods of [[field_object]]. pure function array_interface ( self ) result ( array_ ) !< Return serialized array of field. import :: field_object , R8P class ( field_object ), intent ( in ) :: self !< Field. real ( R8P ), allocatable :: array_ (:) !< Serialized array of field. endfunction array_interface pure function description_interface ( self , prefix ) result ( desc ) !< Return a pretty-formatted object description. import :: field_object class ( field_object ), intent ( in ) :: self !< Field. character ( * ), intent ( in ), optional :: prefix !< Prefixing string. character ( len = :), allocatable :: desc !< Description. endfunction description_interface elemental subroutine assign_interface ( lhs , rhs ) !< Operator `=`. import :: field_object class ( field_object ), intent ( inout ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. endsubroutine assign_interface elemental subroutine assign_real_interface ( lhs , rhs ) !< Operator `field = real`. import :: field_object , R8P class ( field_object ), intent ( inout ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. endsubroutine assign_real_interface function unary_operator ( self ) result ( opr ) !< Unary operator `.op.field`. import :: field_object class ( field_object ), intent ( in ) :: self !< Field. class ( field_object ), allocatable :: opr !< Operator result. endfunction unary_operator elemental function symmetric_op_interface ( lhs , rhs ) result ( opr ) !< Operator `field.op.field`. import :: field_object class ( field_object ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. endfunction symmetric_op_interface elemental function integer_op_field_interface ( lhs , rhs ) result ( opr ) !< Operator `field.op.integer`. import :: field_object , I4P integer ( I4P ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. endfunction integer_op_field_interface elemental function field_op_integer_interface ( lhs , rhs ) result ( opr ) !< Operator `field.op.integer`. import :: field_object , I4P class ( field_object ), intent ( in ) :: lhs !< Left hand side. integer ( I4P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. endfunction field_op_integer_interface elemental function field_op_real_interface ( lhs , rhs ) result ( opr ) !< Operator `field.op.real`. import :: field_object , R8P class ( field_object ), intent ( in ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. endfunction field_op_real_interface elemental function real_op_field_interface ( lhs , rhs ) result ( opr ) !< Operator `real.op.field`. import :: field_object , R8P real ( R8P ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. endfunction real_op_field_interface elemental function compare_interface ( lhs , rhs ) result ( opr ) !< Operator `field.compare.field'. import :: field_object class ( field_object ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. logical :: opr !< Operator result. endfunction compare_interface endinterface endmodule flow_field_object","tags":"","loc":"sourcefile/flow_field_object.f90.html","title":"flow_field_object.f90 – FLOw"},{"text":"FLOw field concrete scalar and vectorial objects. This File Depends On sourcefile~~flow_field_scalar_vectorial.f90~~EfferentGraph sourcefile~flow_field_scalar_vectorial.f90 flow_field_scalar_vectorial.f90 sourcefile~flow_field_object.f90 flow_field_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~penf.f90->sourcefile~flow_field_object.f90 sourcefile~vecfor.f90 vecfor.F90 sourcefile~vecfor.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 var pansourcefileflow_field_scalar_vectorialf90EfferentGraph = svgPanZoom('#sourcefileflow_field_scalar_vectorialf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~flow_field_scalar_vectorial.f90~~AfferentGraph sourcefile~flow_field_scalar_vectorial.f90 flow_field_scalar_vectorial.f90 sourcefile~flow.f90 flow.f90 sourcefile~flow_field_scalar_vectorial.f90->sourcefile~flow.f90 sourcefile~flow_test_primitive_compressible_sub.f90 flow_test_primitive_compressible_sub.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_sub.f90 sourcefile~flow_test_conservative_compressible_assign.f90 flow_test_conservative_compressible_assign.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_assign.f90 sourcefile~flow_test_conservative_compressible_add.f90 flow_test_conservative_compressible_add.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_add.f90 sourcefile~flow_test_conservative_compressible_div.f90 flow_test_conservative_compressible_div.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_div.f90 sourcefile~flow_test_conservative_compressible_eq.f90 flow_test_conservative_compressible_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_eq.f90 sourcefile~flow_test_conservative_compressible_mul.f90 flow_test_conservative_compressible_mul.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_mul.f90 sourcefile~flow_test_conservative_compressible_not_eq.f90 flow_test_conservative_compressible_not_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_not_eq.f90 sourcefile~flow_test_conservative_compressible_pow.f90 flow_test_conservative_compressible_pow.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_pow.f90 sourcefile~flow_test_conservative_compressible_sub.f90 flow_test_conservative_compressible_sub.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_sub.f90 sourcefile~flow_test_eos_compressible.f90 flow_test_eos_compressible.f90 sourcefile~flow.f90->sourcefile~flow_test_eos_compressible.f90 sourcefile~flow_test_primitive_compressible_add.f90 flow_test_primitive_compressible_add.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_add.f90 sourcefile~flow_test_primitive_compressible_assign.f90 flow_test_primitive_compressible_assign.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_assign.f90 sourcefile~flow_test_primitive_compressible_div.f90 flow_test_primitive_compressible_div.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_div.f90 sourcefile~flow_test_primitive_compressible_eq.f90 flow_test_primitive_compressible_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_eq.f90 sourcefile~flow_test_primitive_compressible_mul.f90 flow_test_primitive_compressible_mul.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_mul.f90 sourcefile~flow_test_primitive_compressible_multispecie_add.f90 flow_test_primitive_compressible_multispecie_add.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_add.f90 sourcefile~flow_test_primitive_compressible_multispecie_assign.f90 flow_test_primitive_compressible_multispecie_assign.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_assign.f90 sourcefile~flow_test_primitive_compressible_multispecie_div.f90 flow_test_primitive_compressible_multispecie_div.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_div.f90 sourcefile~flow_test_primitive_compressible_multispecie_eq.f90 flow_test_primitive_compressible_multispecie_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_eq.f90 sourcefile~flow_test_primitive_compressible_multispecie_mul.f90 flow_test_primitive_compressible_multispecie_mul.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_mul.f90 sourcefile~flow_test_primitive_compressible_multispecie_not_eq.f90 flow_test_primitive_compressible_multispecie_not_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_not_eq.f90 sourcefile~flow_test_primitive_compressible_multispecie_pow.f90 flow_test_primitive_compressible_multispecie_pow.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_pow.f90 sourcefile~flow_test_primitive_compressible_multispecie_sub.f90 flow_test_primitive_compressible_multispecie_sub.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_sub.f90 sourcefile~flow_test_primitive_compressible_not_eq.f90 flow_test_primitive_compressible_not_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_not_eq.f90 sourcefile~flow_test_primitive_compressible_pow.f90 flow_test_primitive_compressible_pow.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_pow.f90 sourcefile~flow_test_compressible_transformations.f90 flow_test_compressible_transformations.f90 sourcefile~flow.f90->sourcefile~flow_test_compressible_transformations.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules flow_field_scalar_vectorial Source Code flow_field_scalar_vectorial.f90 Source Code !< FLOw **field** concrete scalar and vectorial objects. module flow_field_scalar_vectorial !< FLOw **field** concrete scalar and vectorial objects. use flow_field_object , only : field_object use penf , only : I4P , R8P , str use vecfor , only : vector implicit none private public :: field_scalar public :: field_vectorial type , extends ( field_object ) :: field_scalar !< **Scalar field** object. real ( R8P ) :: field !< Scalar field. contains ! deferred methods procedure , pass ( self ) :: array => array_scalar !< Return serialized array of field. procedure , pass ( self ) :: description => description_scalar !< Return pretty-printed object description. ! deferred operators procedure , pass ( lhs ) :: assign_field => assign_field_scalar !< Operator `=`. procedure , pass ( lhs ) :: assign_real => assign_real_scalar !< Operator `field = real`. procedure , pass ( self ) :: positive => positive_scalar !< Unary operator `+ field`. procedure , pass ( lhs ) :: add => scalar_add_scalar !< Operator `+`. procedure , pass ( lhs ) :: div => scalar_div_scalar !< Operator `/`. procedure , pass ( lhs ) :: div_integer => scalar_div_integer !< Operator `field / integer`. procedure , pass ( lhs ) :: div_real => scalar_div_real !< Operator `field / real`. procedure , pass ( lhs ) :: mul => scalar_mul_object !< Operator `*`. procedure , pass ( lhs ) :: mul_integer => scalar_mul_integer !< Operator `field * integer`. procedure , pass ( rhs ) :: integer_mul => integer_mul_scalar !< Operator `integer * field`. procedure , pass ( lhs ) :: mul_real => scalar_mul_real !< Operator `field * real`. procedure , pass ( rhs ) :: real_mul => real_mul_scalar !< Operator `real * field`. procedure , pass ( self ) :: negative => negative_scalar !< Unary operator `- field`. procedure , pass ( lhs ) :: sub => scalar_sub_scalar !< Operator `-`. procedure , pass ( lhs ) :: pow_integer => scalar_pow_integer !< Operator `field ** integer`. procedure , pass ( lhs ) :: pow_real => scalar_pow_real !< Operator `field ** real`. procedure , pass ( lhs ) :: eq => eq_scalar !< Operator `=='. procedure , pass ( lhs ) :: not_eq => not_eq_scalar !< Operator `/='. endtype field_scalar type , extends ( field_object ) :: field_vectorial !< **Vectorial field** object. type ( vector ) :: field !< Vectorial field. contains ! deferred methods procedure , pass ( self ) :: array => array_vectorial !< Return serialized array of field. procedure , pass ( self ) :: description => description_vectorial !< Return pretty-printed object description. ! deferred operators procedure , pass ( lhs ) :: assign_field => assign_field_vectorial !< Operator `=`. procedure , pass ( lhs ) :: assign_real => assign_real_vectorial !< Operator `field = real`. procedure , pass ( self ) :: positive => positive_vectorial !< Unary operator `+ field`. procedure , pass ( lhs ) :: add => vectorial_add_vectorial !< Operator `+`. procedure , pass ( lhs ) :: div => vectorial_div_object !< Operator `/`. procedure , pass ( lhs ) :: div_integer => vectorial_div_integer !< Operator `field / integer`. procedure , pass ( lhs ) :: div_real => vectorial_div_real !< Operator `field / real`. procedure , pass ( lhs ) :: mul => vectorial_mul_object !< Operator `*`. procedure , pass ( lhs ) :: mul_integer => vectorial_mul_integer !< Operator `field * integer`. procedure , pass ( rhs ) :: integer_mul => integer_mul_vectorial !< Operator `integer * field`. procedure , pass ( lhs ) :: mul_real => vectorial_mul_real !< Operator `field * real`. procedure , pass ( rhs ) :: real_mul => real_mul_vectorial !< Operator `real * field`. procedure , pass ( self ) :: negative => negative_vectorial !< Unary operator `- field`. procedure , pass ( lhs ) :: sub => vectorial_sub_vectorial !< Operator `-`. procedure , pass ( lhs ) :: pow_integer => vectorial_pow_integer !< Operator `field ** integer`. procedure , pass ( lhs ) :: pow_real => vectorial_pow_real !< Operator `field ** real`. procedure , pass ( lhs ) :: eq => eq_vectorial !< Operator `=='. procedure , pass ( lhs ) :: not_eq => not_eq_vectorial !< Operator `/='. endtype field_vectorial contains ! scalar field ! deferred methods pure function array_scalar ( self ) result ( array_ ) !< Return serialized array of field. class ( field_scalar ), intent ( in ) :: self !< Field. real ( R8P ), allocatable :: array_ (:) !< Serialized array of field. allocate ( array_ ( 1 : 1 )) array_ ( 1 ) = self % field endfunction array_scalar pure function description_scalar ( self , prefix ) result ( desc ) !< Return a pretty-formatted object description. class ( field_scalar ), intent ( in ) :: self !< Primitive. character ( * ), intent ( in ), optional :: prefix !< Prefixing string. character ( len = :), allocatable :: prefix_ !< Prefixing string, local variable. character ( len = :), allocatable :: desc !< Description. prefix_ = '' ; if ( present ( prefix )) prefix_ = prefix desc = prefix_ // 'field  = ' // trim ( str ( n = self % field )) endfunction description_scalar ! deferred oprators elemental subroutine assign_field_scalar ( lhs , rhs ) !< Operator `=`. class ( field_scalar ), intent ( inout ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. select type ( rhs ) class is ( field_scalar ) lhs % field = rhs % field endselect endsubroutine assign_field_scalar elemental subroutine assign_real_scalar ( lhs , rhs ) !< Operator `field = real`. class ( field_scalar ), intent ( inout ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. lhs % field = rhs endsubroutine assign_real_scalar function positive_scalar ( self ) result ( opr ) !< Unary operator `+ field`. class ( field_scalar ), intent ( in ) :: self !< Primitive. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_scalar :: opr ) select type ( opr ) class is ( field_scalar ) opr % field = + self % field endselect endfunction positive_scalar elemental function scalar_add_scalar ( lhs , rhs ) result ( opr ) !< Operator `+`. class ( field_scalar ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_scalar :: opr ) select type ( opr ) class is ( field_scalar ) select type ( rhs ) class is ( field_scalar ) opr % field = lhs % field + rhs % field endselect endselect endfunction scalar_add_scalar elemental function scalar_div_scalar ( lhs , rhs ) result ( opr ) !< Operator `/`. class ( field_scalar ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_scalar :: opr ) select type ( opr ) class is ( field_scalar ) select type ( rhs ) class is ( field_scalar ) opr % field = lhs % field / rhs % field endselect endselect endfunction scalar_div_scalar elemental function scalar_div_integer ( lhs , rhs ) result ( opr ) !< Operator `field / integer`. class ( field_scalar ), intent ( in ) :: lhs !< Left hand side. integer ( I4P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_scalar :: opr ) select type ( opr ) class is ( field_scalar ) opr % field = lhs % field / rhs endselect endfunction scalar_div_integer elemental function scalar_div_real ( lhs , rhs ) result ( opr ) !< Operator `field / real`. class ( field_scalar ), intent ( in ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_scalar :: opr ) select type ( opr ) class is ( field_scalar ) opr % field = lhs % field / rhs endselect endfunction scalar_div_real elemental function scalar_mul_object ( lhs , rhs ) result ( opr ) !< Operator `*`. !< !< @note The combinations accepted are: !<+ `field_scalar * field_vectorial => field_vectorial` !<+ `field_scalar * field_scalar    => field_scalar` class ( field_scalar ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. select type ( rhs ) type is ( field_vectorial ) allocate ( field_vectorial :: opr ) select type ( opr ) class is ( field_vectorial ) opr % field = lhs % field * rhs % field endselect class is ( field_scalar ) allocate ( field_scalar :: opr ) select type ( opr ) class is ( field_scalar ) opr % field = lhs % field * rhs % field endselect endselect endfunction scalar_mul_object elemental function scalar_mul_integer ( lhs , rhs ) result ( opr ) !< Operator `field * integer`. class ( field_scalar ), intent ( in ) :: lhs !< Left hand side. integer ( I4P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_scalar :: opr ) select type ( opr ) class is ( field_scalar ) opr % field = lhs % field * rhs endselect endfunction scalar_mul_integer elemental function integer_mul_scalar ( lhs , rhs ) result ( opr ) !< Operator `integer * field`. integer ( I4P ), intent ( in ) :: lhs !< Left hand side. class ( field_scalar ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_scalar :: opr ) select type ( opr ) class is ( field_scalar ) opr % field = lhs * rhs % field endselect endfunction integer_mul_scalar elemental function scalar_mul_real ( lhs , rhs ) result ( opr ) !< Operator `field * real`. class ( field_scalar ), intent ( in ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_scalar :: opr ) select type ( opr ) class is ( field_scalar ) opr % field = lhs % field * rhs endselect endfunction scalar_mul_real elemental function real_mul_scalar ( lhs , rhs ) result ( opr ) !< Operator `real * field`. real ( R8P ), intent ( in ) :: lhs !< Left hand side. class ( field_scalar ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_scalar :: opr ) select type ( opr ) class is ( field_scalar ) opr % field = lhs * rhs % field endselect endfunction real_mul_scalar function negative_scalar ( self ) result ( opr ) !< Unary operator `- field`. class ( field_scalar ), intent ( in ) :: self !< Primitive. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_scalar :: opr ) select type ( opr ) class is ( field_scalar ) opr % field = - self % field endselect endfunction negative_scalar elemental function scalar_sub_scalar ( lhs , rhs ) result ( opr ) !< Operator `-`. class ( field_scalar ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_scalar :: opr ) select type ( opr ) class is ( field_scalar ) select type ( rhs ) class is ( field_scalar ) opr % field = lhs % field - rhs % field endselect endselect endfunction scalar_sub_scalar elemental function scalar_pow_integer ( lhs , rhs ) result ( opr ) !< Operator `field ** integer`. class ( field_scalar ), intent ( in ) :: lhs !< Left hand side. integer ( I4P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_scalar :: opr ) select type ( opr ) class is ( field_scalar ) opr % field = lhs % field ** rhs endselect endfunction scalar_pow_integer elemental function scalar_pow_real ( lhs , rhs ) result ( opr ) !< Operator `field ** real`. class ( field_scalar ), intent ( in ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_scalar :: opr ) select type ( opr ) class is ( field_scalar ) opr % field = lhs % field ** rhs endselect endfunction scalar_pow_real elemental function eq_scalar ( lhs , rhs ) result ( opr ) !< Operator `=='. class ( field_scalar ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. logical :: opr !< Operator result. opr = . false . select type ( rhs ) class is ( field_scalar ) opr = lhs % field == rhs % field endselect endfunction eq_scalar elemental function not_eq_scalar ( lhs , rhs ) result ( opr ) !< Operator `/='. class ( field_scalar ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. logical :: opr !< Operator result. opr = . false . select type ( rhs ) class is ( field_scalar ) opr = lhs % field /= rhs % field endselect endfunction not_eq_scalar ! vectorial field ! deferred methods pure function array_vectorial ( self ) result ( array_ ) !< Return serialized array of field. class ( field_vectorial ), intent ( in ) :: self !< Field. real ( R8P ), allocatable :: array_ (:) !< Serialized array of field. allocate ( array_ ( 1 : 3 )) array_ ( 1 ) = self % field % x array_ ( 2 ) = self % field % y array_ ( 3 ) = self % field % z endfunction array_vectorial pure function description_vectorial ( self , prefix ) result ( desc ) !< Return a pretty-formatted object description. class ( field_vectorial ), intent ( in ) :: self !< Primitive. character ( * ), intent ( in ), optional :: prefix !< Prefixing string. character ( len = :), allocatable :: prefix_ !< Prefixing string, local variable. character ( len = :), allocatable :: desc !< Description. prefix_ = '' ; if ( present ( prefix )) prefix_ = prefix desc = prefix_ // 'field  = ' // trim ( str ( n = [ self % field % x , self % field % y , self % field % z ])) endfunction description_vectorial ! deferred oprators elemental subroutine assign_field_vectorial ( lhs , rhs ) !< Operator `=`. class ( field_vectorial ), intent ( inout ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. select type ( rhs ) class is ( field_vectorial ) lhs % field = rhs % field endselect endsubroutine assign_field_vectorial elemental subroutine assign_real_vectorial ( lhs , rhs ) !< Operator `field = real`. class ( field_vectorial ), intent ( inout ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. lhs % field = rhs endsubroutine assign_real_vectorial function positive_vectorial ( self ) result ( opr ) !< Unary operator `+ field`. class ( field_vectorial ), intent ( in ) :: self !< Primitive. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_vectorial :: opr ) select type ( opr ) class is ( field_vectorial ) opr % field = + self % field endselect endfunction positive_vectorial elemental function vectorial_add_vectorial ( lhs , rhs ) result ( opr ) !< Operator `+`. class ( field_vectorial ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_vectorial :: opr ) select type ( opr ) class is ( field_vectorial ) select type ( rhs ) class is ( field_vectorial ) opr % field = lhs % field + rhs % field endselect endselect endfunction vectorial_add_vectorial elemental function vectorial_div_object ( lhs , rhs ) result ( opr ) !< Operator `/`. !< !< @note The combinations accepted are: !<+ `field_vectorial / field_vectorial => field_vectorial` !<+ `field_vectorial / field_scalar    => field_vectorial` class ( field_vectorial ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_vectorial :: opr ) select type ( opr ) class is ( field_vectorial ) select type ( rhs ) class is ( field_vectorial ) opr % field = lhs % field / rhs % field class is ( field_scalar ) opr % field = lhs % field / rhs % field endselect endselect endfunction vectorial_div_object elemental function vectorial_div_integer ( lhs , rhs ) result ( opr ) !< Operator `field / integer`. class ( field_vectorial ), intent ( in ) :: lhs !< Left hand side. integer ( I4P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_vectorial :: opr ) select type ( opr ) class is ( field_vectorial ) opr % field = lhs % field / rhs endselect endfunction vectorial_div_integer elemental function vectorial_div_real ( lhs , rhs ) result ( opr ) !< Operator `field / real`. class ( field_vectorial ), intent ( in ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_vectorial :: opr ) select type ( opr ) class is ( field_vectorial ) opr % field = lhs % field / rhs endselect endfunction vectorial_div_real elemental function vectorial_mul_object ( lhs , rhs ) result ( opr ) !< Operator `*`. !< !< @note The combinations accepted are: !<+ `field_vectorial * field_vectorial => field_vectorial` !<+ `field_vectorial * field_scalar    => field_vectorial` class ( field_vectorial ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_vectorial :: opr ) select type ( opr ) class is ( field_vectorial ) select type ( rhs ) class is ( field_vectorial ) opr % field = lhs % field * rhs % field class is ( field_scalar ) opr % field = lhs % field * rhs % field endselect endselect endfunction vectorial_mul_object elemental function vectorial_mul_integer ( lhs , rhs ) result ( opr ) !< Operator `field * integer`. class ( field_vectorial ), intent ( in ) :: lhs !< Left hand side. integer ( I4P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_vectorial :: opr ) select type ( opr ) class is ( field_vectorial ) opr % field = lhs % field * rhs endselect endfunction vectorial_mul_integer elemental function integer_mul_vectorial ( lhs , rhs ) result ( opr ) !< Operator `integer * field`. integer ( I4P ), intent ( in ) :: lhs !< Left hand side. class ( field_vectorial ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_vectorial :: opr ) select type ( opr ) class is ( field_vectorial ) opr % field = lhs * rhs % field endselect endfunction integer_mul_vectorial elemental function vectorial_mul_real ( lhs , rhs ) result ( opr ) !< Operator `field * real`. class ( field_vectorial ), intent ( in ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_vectorial :: opr ) select type ( opr ) class is ( field_vectorial ) opr % field = lhs % field * rhs endselect endfunction vectorial_mul_real elemental function real_mul_vectorial ( lhs , rhs ) result ( opr ) !< Operator `real * field`. real ( R8P ), intent ( in ) :: lhs !< Left hand side. class ( field_vectorial ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_vectorial :: opr ) select type ( opr ) class is ( field_vectorial ) opr % field = lhs * rhs % field endselect endfunction real_mul_vectorial function negative_vectorial ( self ) result ( opr ) !< Unary operator `+ field`. class ( field_vectorial ), intent ( in ) :: self !< Primitive. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_vectorial :: opr ) select type ( opr ) class is ( field_vectorial ) opr % field = - self % field endselect endfunction negative_vectorial elemental function vectorial_sub_vectorial ( lhs , rhs ) result ( opr ) !< Operator `-`. class ( field_vectorial ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_vectorial :: opr ) select type ( opr ) class is ( field_vectorial ) select type ( rhs ) class is ( field_vectorial ) opr % field = lhs % field - rhs % field endselect endselect endfunction vectorial_sub_vectorial elemental function vectorial_pow_integer ( lhs , rhs ) result ( opr ) !< Operator `field ** integer`. class ( field_vectorial ), intent ( in ) :: lhs !< Left hand side. integer ( I4P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_vectorial :: opr ) select type ( opr ) class is ( field_vectorial ) opr % field % x = lhs % field % x ** rhs opr % field % y = lhs % field % y ** rhs opr % field % z = lhs % field % z ** rhs endselect endfunction vectorial_pow_integer elemental function vectorial_pow_real ( lhs , rhs ) result ( opr ) !< Operator `field ** real`. class ( field_vectorial ), intent ( in ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_vectorial :: opr ) select type ( opr ) class is ( field_vectorial ) opr % field % x = lhs % field % x ** rhs opr % field % y = lhs % field % y ** rhs opr % field % z = lhs % field % z ** rhs endselect endfunction vectorial_pow_real elemental function eq_vectorial ( lhs , rhs ) result ( opr ) !< Operator `=='. class ( field_vectorial ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. logical :: opr !< Operator result. opr = . false . select type ( rhs ) class is ( field_vectorial ) opr = lhs % field == rhs % field endselect endfunction eq_vectorial elemental function not_eq_vectorial ( lhs , rhs ) result ( opr ) !< Operator `/='. class ( field_vectorial ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. logical :: opr !< Operator result. opr = . false . select type ( rhs ) class is ( field_vectorial ) opr = lhs % field /= rhs % field endselect endfunction not_eq_vectorial endmodule flow_field_scalar_vectorial","tags":"","loc":"sourcefile/flow_field_scalar_vectorial.f90.html","title":"flow_field_scalar_vectorial.f90 – FLOw"},{"text":"FLOw primitive compressible object. This File Depends On sourcefile~~flow_primitive_compressible.f90~~EfferentGraph sourcefile~flow_primitive_compressible.f90 flow_primitive_compressible.f90 sourcefile~flow_field_object.f90 flow_field_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_primitive_object.f90 flow_primitive_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_object.f90 sourcefile~vecfor.f90 vecfor.F90 sourcefile~vecfor.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_object.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~penf.f90->sourcefile~flow_field_object.f90 sourcefile~flow_eos_object.f90 flow_eos_object.f90 sourcefile~penf.f90->sourcefile~flow_eos_object.f90 sourcefile~penf.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 var pansourcefileflow_primitive_compressiblef90EfferentGraph = svgPanZoom('#sourcefileflow_primitive_compressiblef90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~flow_primitive_compressible.f90~~AfferentGraph sourcefile~flow_primitive_compressible.f90 flow_primitive_compressible.f90 sourcefile~flow_compressible_transformations.f90 flow_compressible_transformations.f90 sourcefile~flow_primitive_compressible.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow.f90 flow.f90 sourcefile~flow_primitive_compressible.f90->sourcefile~flow.f90 sourcefile~flow_compressible_transformations.f90->sourcefile~flow.f90 sourcefile~flow_test_primitive_compressible_sub.f90 flow_test_primitive_compressible_sub.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_sub.f90 sourcefile~flow_test_conservative_compressible_assign.f90 flow_test_conservative_compressible_assign.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_assign.f90 sourcefile~flow_test_conservative_compressible_add.f90 flow_test_conservative_compressible_add.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_add.f90 sourcefile~flow_test_conservative_compressible_div.f90 flow_test_conservative_compressible_div.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_div.f90 sourcefile~flow_test_conservative_compressible_eq.f90 flow_test_conservative_compressible_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_eq.f90 sourcefile~flow_test_conservative_compressible_mul.f90 flow_test_conservative_compressible_mul.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_mul.f90 sourcefile~flow_test_conservative_compressible_not_eq.f90 flow_test_conservative_compressible_not_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_not_eq.f90 sourcefile~flow_test_conservative_compressible_pow.f90 flow_test_conservative_compressible_pow.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_pow.f90 sourcefile~flow_test_conservative_compressible_sub.f90 flow_test_conservative_compressible_sub.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_sub.f90 sourcefile~flow_test_eos_compressible.f90 flow_test_eos_compressible.f90 sourcefile~flow.f90->sourcefile~flow_test_eos_compressible.f90 sourcefile~flow_test_primitive_compressible_add.f90 flow_test_primitive_compressible_add.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_add.f90 sourcefile~flow_test_primitive_compressible_assign.f90 flow_test_primitive_compressible_assign.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_assign.f90 sourcefile~flow_test_primitive_compressible_div.f90 flow_test_primitive_compressible_div.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_div.f90 sourcefile~flow_test_primitive_compressible_eq.f90 flow_test_primitive_compressible_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_eq.f90 sourcefile~flow_test_primitive_compressible_mul.f90 flow_test_primitive_compressible_mul.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_mul.f90 sourcefile~flow_test_primitive_compressible_multispecie_add.f90 flow_test_primitive_compressible_multispecie_add.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_add.f90 sourcefile~flow_test_primitive_compressible_multispecie_assign.f90 flow_test_primitive_compressible_multispecie_assign.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_assign.f90 sourcefile~flow_test_primitive_compressible_multispecie_div.f90 flow_test_primitive_compressible_multispecie_div.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_div.f90 sourcefile~flow_test_primitive_compressible_multispecie_eq.f90 flow_test_primitive_compressible_multispecie_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_eq.f90 sourcefile~flow_test_primitive_compressible_multispecie_mul.f90 flow_test_primitive_compressible_multispecie_mul.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_mul.f90 sourcefile~flow_test_primitive_compressible_multispecie_not_eq.f90 flow_test_primitive_compressible_multispecie_not_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_not_eq.f90 sourcefile~flow_test_primitive_compressible_multispecie_pow.f90 flow_test_primitive_compressible_multispecie_pow.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_pow.f90 sourcefile~flow_test_primitive_compressible_multispecie_sub.f90 flow_test_primitive_compressible_multispecie_sub.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_sub.f90 sourcefile~flow_test_primitive_compressible_not_eq.f90 flow_test_primitive_compressible_not_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_not_eq.f90 sourcefile~flow_test_primitive_compressible_pow.f90 flow_test_primitive_compressible_pow.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_pow.f90 sourcefile~flow_test_compressible_transformations.f90 flow_test_compressible_transformations.f90 sourcefile~flow.f90->sourcefile~flow_test_compressible_transformations.f90 var pansourcefileflow_primitive_compressiblef90AfferentGraph = svgPanZoom('#sourcefileflow_primitive_compressiblef90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules flow_primitive_compressible Source Code flow_primitive_compressible.f90 Source Code !< FLOw **primitive** compressible object. module flow_primitive_compressible !< FLOw **primitive** compressible object. !< !< [[primitive_compressible]] is a class that handles compressible primitive fluid dynamic variables. use , intrinsic :: iso_fortran_env , only : stderr => error_unit use flow_eos_object , only : eos_object use flow_field_object , only : field_object use flow_primitive_object , only : primitive_object use penf , only : I4P , R8P , str use vecfor , only : vector implicit none private public :: primitive_compressible public :: primitive_compressible_pointer type , extends ( primitive_object ) :: primitive_compressible !< **Primitive** compressible multispecie object. real ( R8P ) :: density = 0._R8P !< Density, `rho`. type ( vector ) :: velocity !< Velocity, `v`. real ( R8P ) :: pressure = 0._R8P !< Pressure, `p`. contains ! public methods procedure , pass ( self ) :: left_eigenvectors !< Return the left eigenvectors matrix `L` as `dF/dP = A = R &#94; L`. procedure , pass ( self ) :: right_eigenvectors !< Return the right eigenvectors matrix `R` as `dF/dP = A = R &#94; L`. ! deferred methods procedure , pass ( self ) :: array !< Return serialized array of field. procedure , pass ( self ) :: description !< Return pretty-printed object description. procedure , pass ( self ) :: destroy !< Destroy primitive. procedure , pass ( self ) :: energy !< Return energy value. procedure , pass ( self ) :: initialize !< Initialize primitive. procedure , pass ( self ) :: momentum !< Return momentum vector. ! deferred operators procedure , pass ( lhs ) :: assign_field !< Operator `=`. procedure , pass ( lhs ) :: assign_real !< Operator `field = real`. procedure , pass ( self ) :: positive !< Unary operator `+ field`. procedure , pass ( lhs ) :: add !< Operator `+`. procedure , pass ( lhs ) :: div !< Operator `/`. procedure , pass ( lhs ) :: div_integer !< Operator `field / integer`. procedure , pass ( lhs ) :: div_real !< Operator `field / real`. procedure , pass ( lhs ) :: mul !< Operator `*`. procedure , pass ( lhs ) :: mul_integer !< Operator `field * integer`. procedure , pass ( rhs ) :: integer_mul !< Operator `integer * field`. procedure , pass ( lhs ) :: mul_real !< Operator `field * real`. procedure , pass ( rhs ) :: real_mul !< Operator `real * field`. procedure , pass ( self ) :: negative !< Unary operator `- field`. procedure , pass ( lhs ) :: sub !< Operator `-`. procedure , pass ( lhs ) :: pow_integer !< Operator `field ** integer`. procedure , pass ( lhs ) :: pow_real !< Operator `field ** real`. procedure , pass ( lhs ) :: eq !< Operator `=='. procedure , pass ( lhs ) :: not_eq !< Operator `/='. endtype primitive_compressible interface primitive_compressible !< Overload [[primitive_compressible]] name with its constructor. module procedure primitive_compressible_instance endinterface contains ! public non TBP function primitive_compressible_pointer ( to , error_message ) result ( pointer_ ) !< Return [[primitive_compressible]] pointer associated to [[primitive_object]] or its extensions until !< [[primitive_compressible]] included. !< !< @note A type-guard check is performed and error stop is raised if necessary. class ( primitive_object ), intent ( in ), target :: to !< Target of associate. character ( * ), intent ( in ), optional :: error_message !< Auxiliary error message. class ( primitive_compressible ), pointer :: pointer_ !< Associated pointer. select type ( to ) type is ( primitive_compressible ) pointer_ => to class default write ( stderr , '(A)' ) 'error: cast primitive_object to primitive_compressible failed!' if ( present ( error_message )) write ( stderr , '(A)' ) error_message stop endselect endfunction primitive_compressible_pointer ! public methods pure function left_eigenvectors ( self , eos ) result ( eig ) !< Return the left eigenvectors matrix `L` as `dF/dP = A = R &#94; L`. class ( primitive_compressible ), intent ( in ) :: self !< Primitive. class ( eos_object ), intent ( in ) :: eos !< Equation of state. real ( R8P ) :: eig ( 1 : 3 , 1 : 3 ) !< Eigenvectors. real ( R8P ) :: gp !< `g*p`. real ( R8P ) :: gp_a !< `g*p/a`. gp = eos % g () * self % pressure gp_a = gp / eos % speed_of_sound ( density = self % density , pressure = self % pressure ) eig ( 1 , 1 ) = 0._R8P ; eig ( 1 , 2 ) = - gp_a ; eig ( 1 , 3 ) = 1._R8P eig ( 2 , 1 ) = gp / self % density ; eig ( 2 , 2 ) = 0._R8P ; eig ( 2 , 3 ) = - 1._R8P eig ( 3 , 1 ) = 0._R8P ; eig ( 3 , 2 ) = gp_a ; eig ( 3 , 3 ) = 1._R8P endfunction left_eigenvectors pure function right_eigenvectors ( self , eos ) result ( eig ) !< Return the right eigenvectors matrix `R` as `dF/dP = A = R &#94; L`. class ( primitive_compressible ), intent ( in ) :: self !< Primitive. class ( eos_object ), intent ( in ) :: eos !< Equation of state. real ( R8P ) :: eig ( 1 : 3 , 1 : 3 ) !< Eigenvectors. real ( R8P ) :: gp !< `g*p`. real ( R8P ) :: gp_inv !< `1/(g*p)`. real ( R8P ) :: a !< Speed of sound, `sqrt(g*p/r)`. gp = eos % g () * self % pressure gp_inv = 1._R8P / gp a = eos % speed_of_sound ( density = self % density , pressure = self % pressure ) eig ( 1 , 1 ) = 0.5_R8P * self % density * gp_inv ; eig ( 1 , 2 ) = self % density * gp_inv ; eig ( 1 , 3 ) = eig ( 1 , 1 ) eig ( 2 , 1 ) = - 0.5_R8P * a * gp_inv ; eig ( 2 , 2 ) = 0._R8P ; eig ( 2 , 3 ) = - eig ( 2 , 1 ) eig ( 3 , 1 ) = 0.5_R8P ; eig ( 3 , 2 ) = 0._R8P ; eig ( 3 , 3 ) = eig ( 3 , 1 ) endfunction right_eigenvectors ! deferred methods pure function array ( self ) result ( array_ ) !< Return serialized array of field. class ( primitive_compressible ), intent ( in ) :: self !< Primitive. real ( R8P ), allocatable :: array_ (:) !< Serialized array of field. allocate ( array_ ( 1 : 5 )) array_ ( 1 ) = self % density array_ ( 2 ) = self % velocity % x array_ ( 3 ) = self % velocity % y array_ ( 4 ) = self % velocity % z array_ ( 5 ) = self % pressure endfunction array pure function description ( self , prefix ) result ( desc ) !< Return a pretty-formatted object description. class ( primitive_compressible ), intent ( in ) :: self !< Primitive. character ( * ), intent ( in ), optional :: prefix !< Prefixing string. character ( len = :), allocatable :: prefix_ !< Prefixing string, local variable. character ( len = :), allocatable :: desc !< Description. character ( len = 1 ), parameter :: NL = new_line ( 'a' ) !< New line character. prefix_ = '' ; if ( present ( prefix )) prefix_ = prefix desc = '' desc = desc // prefix_ // 'density  = ' // trim ( str ( n = self % density )) // NL desc = desc // prefix_ // 'velocity = ' // trim ( str ( n = [ self % velocity % x , self % velocity % y , self % velocity % z ])) // NL desc = desc // prefix_ // 'pressure = ' // trim ( str ( n = self % pressure )) endfunction description elemental subroutine destroy ( self ) !< Destroy primitive. class ( primitive_compressible ), intent ( inout ) :: self !< Primitive. type ( primitive_compressible ) :: fresh !< Fresh instance of primitive object. self = fresh endsubroutine destroy elemental function energy ( self , eos ) result ( energy_ ) !< Return energy value. class ( primitive_compressible ), intent ( in ) :: self !< Primitive. class ( eos_object ), intent ( in ) :: eos !< Equation of state. real ( R8P ) :: energy_ !< Energy value. energy_ = self % pressure / ( eos % g () - 1._R8P ) + 0.5_R8P * self % density * self % velocity % sq_norm () endfunction energy subroutine initialize ( self , initial_state ) !< Initialize primitive. class ( primitive_compressible ), intent ( inout ) :: self !< Primitive. class ( primitive_object ), intent ( in ), optional :: initial_state !< Initial state. call self % destroy if ( present ( initial_state )) then select type ( initial_state ) class is ( primitive_compressible ) self = initial_state endselect endif endsubroutine initialize elemental function momentum ( self ) result ( momentum_ ) !< Return momentum vector. class ( primitive_compressible ), intent ( in ) :: self !< Primitive. type ( vector ) :: momentum_ !< Momentum vector. momentum_ = self % density * self % velocity endfunction momentum ! deferred oprators elemental subroutine assign_field ( lhs , rhs ) !< Operator `=`. class ( primitive_compressible ), intent ( inout ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. select type ( rhs ) class is ( primitive_compressible ) lhs % density = rhs % density lhs % velocity = rhs % velocity lhs % pressure = rhs % pressure endselect endsubroutine assign_field elemental subroutine assign_real ( lhs , rhs ) !< Operator `field = real`. class ( primitive_compressible ), intent ( inout ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. lhs % density = rhs lhs % velocity = rhs lhs % pressure = rhs endsubroutine assign_real function positive ( self ) result ( opr ) !< Unary operator `+ field`. class ( primitive_compressible ), intent ( in ) :: self !< Primitive. class ( field_object ), allocatable :: opr !< Operator result. allocate ( primitive_compressible :: opr ) select type ( opr ) class is ( primitive_compressible ) opr % density = + self % density opr % velocity = + self % velocity opr % pressure = + self % pressure endselect endfunction positive elemental function add ( lhs , rhs ) result ( opr ) !< Operator `+`. class ( primitive_compressible ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( primitive_compressible :: opr ) select type ( opr ) class is ( primitive_compressible ) select type ( rhs ) class is ( primitive_compressible ) opr % density = lhs % density + rhs % density opr % velocity = lhs % velocity + rhs % velocity opr % pressure = lhs % pressure + rhs % pressure endselect endselect endfunction add elemental function div ( lhs , rhs ) result ( opr ) !< Operator `/`. class ( primitive_compressible ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( primitive_compressible :: opr ) select type ( opr ) class is ( primitive_compressible ) select type ( rhs ) class is ( primitive_compressible ) opr % density = lhs % density / rhs % density opr % velocity = lhs % velocity / rhs % velocity opr % pressure = lhs % pressure / rhs % pressure endselect endselect endfunction div elemental function div_integer ( lhs , rhs ) result ( opr ) !< Operator `field / integer`. class ( primitive_compressible ), intent ( in ) :: lhs !< Left hand side. integer ( I4P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( primitive_compressible :: opr ) select type ( opr ) class is ( primitive_compressible ) opr % density = lhs % density / rhs opr % velocity = lhs % velocity / rhs opr % pressure = lhs % pressure / rhs endselect endfunction div_integer elemental function div_real ( lhs , rhs ) result ( opr ) !< Operator `field / real`. class ( primitive_compressible ), intent ( in ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( primitive_compressible :: opr ) select type ( opr ) class is ( primitive_compressible ) opr % density = lhs % density / rhs opr % velocity = lhs % velocity / rhs opr % pressure = lhs % pressure / rhs endselect endfunction div_real elemental function mul ( lhs , rhs ) result ( opr ) !< Operator `*`. class ( primitive_compressible ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( primitive_compressible :: opr ) select type ( opr ) class is ( primitive_compressible ) select type ( rhs ) class is ( primitive_compressible ) opr % density = lhs % density * rhs % density opr % velocity = lhs % velocity * rhs % velocity opr % pressure = lhs % pressure * rhs % pressure endselect endselect endfunction mul elemental function mul_integer ( lhs , rhs ) result ( opr ) !< Operator `field * integer`. class ( primitive_compressible ), intent ( in ) :: lhs !< Left hand side. integer ( I4P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( primitive_compressible :: opr ) select type ( opr ) class is ( primitive_compressible ) opr % density = lhs % density * rhs opr % velocity = lhs % velocity * rhs opr % pressure = lhs % pressure * rhs endselect endfunction mul_integer elemental function integer_mul ( lhs , rhs ) result ( opr ) !< Operator `integer * field`. integer ( I4P ), intent ( in ) :: lhs !< Left hand side. class ( primitive_compressible ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( primitive_compressible :: opr ) select type ( opr ) class is ( primitive_compressible ) opr % density = lhs * rhs % density opr % velocity = lhs * rhs % velocity opr % pressure = lhs * rhs % pressure endselect endfunction integer_mul elemental function mul_real ( lhs , rhs ) result ( opr ) !< Operator `field * real`. class ( primitive_compressible ), intent ( in ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( primitive_compressible :: opr ) select type ( opr ) class is ( primitive_compressible ) opr % density = lhs % density * rhs opr % velocity = lhs % velocity * rhs opr % pressure = lhs % pressure * rhs endselect endfunction mul_real elemental function real_mul ( lhs , rhs ) result ( opr ) !< Operator `real * field`. real ( R8P ), intent ( in ) :: lhs !< Left hand side. class ( primitive_compressible ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( primitive_compressible :: opr ) select type ( opr ) class is ( primitive_compressible ) opr % density = lhs * rhs % density opr % velocity = lhs * rhs % velocity opr % pressure = lhs * rhs % pressure endselect endfunction real_mul function negative ( self ) result ( opr ) !< Unary operator `- field`. class ( primitive_compressible ), intent ( in ) :: self !< Primitive. class ( field_object ), allocatable :: opr !< Operator result. allocate ( primitive_compressible :: opr ) select type ( opr ) class is ( primitive_compressible ) opr % density = - self % density opr % velocity = - self % velocity opr % pressure = - self % pressure endselect endfunction negative elemental function sub ( lhs , rhs ) result ( opr ) !< Operator `-`. class ( primitive_compressible ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( primitive_compressible :: opr ) select type ( opr ) class is ( primitive_compressible ) select type ( rhs ) class is ( primitive_compressible ) opr % density = lhs % density - rhs % density opr % velocity = lhs % velocity - rhs % velocity opr % pressure = lhs % pressure - rhs % pressure endselect endselect endfunction sub elemental function pow_integer ( lhs , rhs ) result ( opr ) !< Operator `field ** integer`. class ( primitive_compressible ), intent ( in ) :: lhs !< Left hand side. integer ( I4P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( primitive_compressible :: opr ) select type ( opr ) class is ( primitive_compressible ) opr % density = lhs % density ** rhs opr % velocity % x = lhs % velocity % x ** rhs opr % velocity % y = lhs % velocity % y ** rhs opr % velocity % z = lhs % velocity % z ** rhs opr % pressure = lhs % pressure ** rhs endselect endfunction pow_integer elemental function pow_real ( lhs , rhs ) result ( opr ) !< Operator `field ** real`. class ( primitive_compressible ), intent ( in ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( primitive_compressible :: opr ) select type ( opr ) class is ( primitive_compressible ) opr % density = lhs % density ** rhs opr % velocity % x = lhs % velocity % x ** rhs opr % velocity % y = lhs % velocity % y ** rhs opr % velocity % z = lhs % velocity % z ** rhs opr % pressure = lhs % pressure ** rhs endselect endfunction pow_real elemental function eq ( lhs , rhs ) result ( opr ) !< Operator `=='. class ( primitive_compressible ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. logical :: opr !< Operator result. select type ( rhs ) class is ( primitive_compressible ) opr = lhs % density == rhs % density if ( opr ) opr = lhs % velocity == rhs % velocity if ( opr ) opr = lhs % pressure == rhs % pressure endselect endfunction eq elemental function not_eq ( lhs , rhs ) result ( opr ) !< Operator `/='. class ( primitive_compressible ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. logical :: opr !< Operator result. opr = . not .( lhs % eq ( rhs = rhs )) endfunction not_eq ! private non TBP pure function primitive_compressible_instance ( density , velocity , pressure ) result ( instance ) !< Return and instance of [[primitive_compressible]]. !< !< @note This procedure is used for overloading [[primitive_compressible]] name. real ( R8P ), intent ( in ), optional :: density !< Density field. type ( vector ), intent ( in ), optional :: velocity !< Velocity field. real ( R8P ), intent ( in ), optional :: pressure !< Pressure field. type ( primitive_compressible ) :: instance !< Instance of [[primitive_compressible]]. if ( present ( density )) instance % density = density if ( present ( velocity )) instance % velocity = velocity if ( present ( pressure )) instance % pressure = pressure endfunction primitive_compressible_instance endmodule flow_primitive_compressible","tags":"","loc":"sourcefile/flow_primitive_compressible.f90.html","title":"flow_primitive_compressible.f90 – FLOw"},{"text":"FLOw primitive compressible mutlispecie object. This File Depends On sourcefile~~flow_primitive_compressible_multispecie.f90~~EfferentGraph sourcefile~flow_primitive_compressible_multispecie.f90 flow_primitive_compressible_multispecie.f90 sourcefile~flow_field_object.f90 flow_field_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_primitive_object.f90 flow_primitive_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_object.f90 sourcefile~vecfor.f90 vecfor.F90 sourcefile~vecfor.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_object.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~penf.f90->sourcefile~flow_field_object.f90 sourcefile~flow_eos_object.f90 flow_eos_object.f90 sourcefile~penf.f90->sourcefile~flow_eos_object.f90 sourcefile~penf.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 var pansourcefileflow_primitive_compressible_multispecief90EfferentGraph = svgPanZoom('#sourcefileflow_primitive_compressible_multispecief90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~flow_primitive_compressible_multispecie.f90~~AfferentGraph sourcefile~flow_primitive_compressible_multispecie.f90 flow_primitive_compressible_multispecie.f90 sourcefile~flow.f90 flow.f90 sourcefile~flow_primitive_compressible_multispecie.f90->sourcefile~flow.f90 sourcefile~flow_test_primitive_compressible_sub.f90 flow_test_primitive_compressible_sub.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_sub.f90 sourcefile~flow_test_conservative_compressible_assign.f90 flow_test_conservative_compressible_assign.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_assign.f90 sourcefile~flow_test_conservative_compressible_add.f90 flow_test_conservative_compressible_add.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_add.f90 sourcefile~flow_test_conservative_compressible_div.f90 flow_test_conservative_compressible_div.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_div.f90 sourcefile~flow_test_conservative_compressible_eq.f90 flow_test_conservative_compressible_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_eq.f90 sourcefile~flow_test_conservative_compressible_mul.f90 flow_test_conservative_compressible_mul.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_mul.f90 sourcefile~flow_test_conservative_compressible_not_eq.f90 flow_test_conservative_compressible_not_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_not_eq.f90 sourcefile~flow_test_conservative_compressible_pow.f90 flow_test_conservative_compressible_pow.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_pow.f90 sourcefile~flow_test_conservative_compressible_sub.f90 flow_test_conservative_compressible_sub.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_sub.f90 sourcefile~flow_test_eos_compressible.f90 flow_test_eos_compressible.f90 sourcefile~flow.f90->sourcefile~flow_test_eos_compressible.f90 sourcefile~flow_test_primitive_compressible_add.f90 flow_test_primitive_compressible_add.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_add.f90 sourcefile~flow_test_primitive_compressible_assign.f90 flow_test_primitive_compressible_assign.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_assign.f90 sourcefile~flow_test_primitive_compressible_div.f90 flow_test_primitive_compressible_div.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_div.f90 sourcefile~flow_test_primitive_compressible_eq.f90 flow_test_primitive_compressible_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_eq.f90 sourcefile~flow_test_primitive_compressible_mul.f90 flow_test_primitive_compressible_mul.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_mul.f90 sourcefile~flow_test_primitive_compressible_multispecie_add.f90 flow_test_primitive_compressible_multispecie_add.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_add.f90 sourcefile~flow_test_primitive_compressible_multispecie_assign.f90 flow_test_primitive_compressible_multispecie_assign.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_assign.f90 sourcefile~flow_test_primitive_compressible_multispecie_div.f90 flow_test_primitive_compressible_multispecie_div.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_div.f90 sourcefile~flow_test_primitive_compressible_multispecie_eq.f90 flow_test_primitive_compressible_multispecie_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_eq.f90 sourcefile~flow_test_primitive_compressible_multispecie_mul.f90 flow_test_primitive_compressible_multispecie_mul.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_mul.f90 sourcefile~flow_test_primitive_compressible_multispecie_not_eq.f90 flow_test_primitive_compressible_multispecie_not_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_not_eq.f90 sourcefile~flow_test_primitive_compressible_multispecie_pow.f90 flow_test_primitive_compressible_multispecie_pow.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_pow.f90 sourcefile~flow_test_primitive_compressible_multispecie_sub.f90 flow_test_primitive_compressible_multispecie_sub.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_sub.f90 sourcefile~flow_test_primitive_compressible_not_eq.f90 flow_test_primitive_compressible_not_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_not_eq.f90 sourcefile~flow_test_primitive_compressible_pow.f90 flow_test_primitive_compressible_pow.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_pow.f90 sourcefile~flow_test_compressible_transformations.f90 flow_test_compressible_transformations.f90 sourcefile~flow.f90->sourcefile~flow_test_compressible_transformations.f90 var pansourcefileflow_primitive_compressible_multispecief90AfferentGraph = svgPanZoom('#sourcefileflow_primitive_compressible_multispecief90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules flow_primitive_compressible_multispecie Source Code flow_primitive_compressible_multispecie.f90 Source Code !< FLOw **primitive** compressible mutlispecie object. module flow_primitive_compressible_multispecie !< FLOw **primitive** compressible mutlispecie object. !< !< [[primitive_compressible_multispecie]] is a class that handles compressible multispecie primitive fluid dynamic variables. use flow_eos_object , only : eos_object use flow_field_object , only : field_object use flow_primitive_object , only : primitive_object use penf , only : I4P , R8P , str use vecfor , only : vector implicit none private public :: primitive_compressible_multispecie type , extends ( primitive_object ) :: primitive_compressible_multispecie !< **Primitive** compressible multispecie object. real ( R8P ) :: density = 0._R8P !< Density, `rho`. type ( vector ) :: velocity !< Velocity, `v`. real ( R8P ) :: pressure = 0._R8P !< Pressure, `p`. real ( R8P ), allocatable :: partial_densities (:) !< Partial densities `rho(s), rho = sum(rho(s))`. contains ! deferred methods procedure , pass ( self ) :: array !< Return serialized array of field. procedure , pass ( self ) :: description !< Return pretty-printed object description. procedure , pass ( self ) :: destroy !< Destroy primitive. procedure , pass ( self ) :: energy !< Return energy value. procedure , pass ( self ) :: initialize !< Initialize primitive. procedure , pass ( self ) :: momentum !< Return momentum vector. ! deferred operators procedure , pass ( lhs ) :: assign_field !< Operator `=`. procedure , pass ( lhs ) :: assign_real !< Operator `field = real`. procedure , pass ( self ) :: positive !< Unary operator `+ field`. procedure , pass ( lhs ) :: add !< Operator `+`. procedure , pass ( lhs ) :: div !< Operator `/`. procedure , pass ( lhs ) :: div_integer !< Operator `field / integer`. procedure , pass ( lhs ) :: div_real !< Operator `field / real`. procedure , pass ( lhs ) :: mul !< Operator `*`. procedure , pass ( lhs ) :: mul_integer !< Operator `field * integer`. procedure , pass ( rhs ) :: integer_mul !< Operator `integer * field`. procedure , pass ( lhs ) :: mul_real !< Operator `field * real`. procedure , pass ( rhs ) :: real_mul !< Operator `real * field`. procedure , pass ( self ) :: negative !< Unary operator `- field`. procedure , pass ( lhs ) :: sub !< Operator `-`. procedure , pass ( lhs ) :: pow_integer !< Operator `field ** integer`. procedure , pass ( lhs ) :: pow_real !< Operator `field ** real`. procedure , pass ( lhs ) :: eq !< Operator `=='. procedure , pass ( lhs ) :: not_eq !< Operator `/='. ! public operators generic :: operator (. compatible .) => compatible !< Operator `.compatible.` overloading. ! public methods procedure , pass ( lhs ) :: compatible !< Operator `.compatible.`. endtype primitive_compressible_multispecie interface primitive_compressible_multispecie !< Overload [[primitive_compressible_multispecie]] name with its constructor. module procedure primitive_compressible_multispecie_instance endinterface contains ! deferred methods pure function array ( self ) result ( array_ ) !< Return serialized array of field. class ( primitive_compressible_multispecie ), intent ( in ) :: self !< Primitive. real ( R8P ), allocatable :: array_ (:) !< Serialized array of field. if ( allocated ( self % partial_densities )) then allocate ( array_ ( 1 : 5 + size ( self % partial_densities , dim = 1 ))) array_ ( 1 ) = self % density array_ ( 2 ) = self % velocity % x array_ ( 3 ) = self % velocity % y array_ ( 4 ) = self % velocity % z array_ ( 5 ) = self % pressure array_ ( 6 :) = self % partial_densities (:) else allocate ( array_ ( 1 : 5 )) array_ ( 1 ) = self % density array_ ( 2 ) = self % velocity % x array_ ( 3 ) = self % velocity % y array_ ( 4 ) = self % velocity % z array_ ( 5 ) = self % pressure endif endfunction array pure function description ( self , prefix ) result ( desc ) !< Return a pretty-formatted object description. class ( primitive_compressible_multispecie ), intent ( in ) :: self !< Primitive. character ( * ), intent ( in ), optional :: prefix !< Prefixing string. character ( len = :), allocatable :: prefix_ !< Prefixing string, local variable. character ( len = :), allocatable :: desc !< Description. character ( len = 1 ), parameter :: NL = new_line ( 'a' ) !< New line character. if ( allocated ( self % partial_densities )) then prefix_ = '' ; if ( present ( prefix )) prefix_ = prefix desc = '' desc = desc // prefix_ // 'density           = ' // trim ( str ( n = self % density )) // NL desc = desc // prefix_ // 'velocity          = ' // trim ( str ( n = [ self % velocity % x , self % velocity % y , self % velocity % z ])) // NL desc = desc // prefix_ // 'pressure          = ' // trim ( str ( n = self % pressure )) // NL desc = desc // prefix_ // 'partial densities = ' // trim ( str ( n = self % partial_densities )) else prefix_ = '' ; if ( present ( prefix )) prefix_ = prefix desc = '' desc = desc // prefix_ // 'density  = ' // trim ( str ( n = self % density )) // NL desc = desc // prefix_ // 'velocity = ' // trim ( str ( n = [ self % velocity % x , self % velocity % y , self % velocity % z ])) // NL desc = desc // prefix_ // 'pressure = ' // trim ( str ( n = self % pressure )) endif endfunction description elemental subroutine destroy ( self ) !< Destroy primitive. class ( primitive_compressible_multispecie ), intent ( inout ) :: self !< Primitive. type ( primitive_compressible_multispecie ) :: fresh !< Fresh instance of primitive object. self = fresh endsubroutine destroy elemental function energy ( self , eos ) result ( energy_ ) !< Return energy value. class ( primitive_compressible_multispecie ), intent ( in ) :: self !< Primitive. class ( eos_object ), intent ( in ) :: eos !< Equation of state. real ( R8P ) :: energy_ !< Energy value. energy_ = self % pressure / ( eos % g () - 1._R8P ) + 0.5_R8P * self % density * self % velocity % sq_norm () endfunction energy subroutine initialize ( self , initial_state ) !< Initialize primitive. class ( primitive_compressible_multispecie ), intent ( inout ) :: self !< Primitive. class ( primitive_object ), intent ( in ), optional :: initial_state !< Initial state. call self % destroy if ( present ( initial_state )) then select type ( initial_state ) class is ( primitive_compressible_multispecie ) self = initial_state endselect endif endsubroutine initialize elemental function momentum ( self ) result ( momentum_ ) !< Return momentum vector. class ( primitive_compressible_multispecie ), intent ( in ) :: self !< Primitive. type ( vector ) :: momentum_ !< Momentum vector. momentum_ = self % density * self % velocity endfunction momentum ! deferred oprators elemental subroutine assign_field ( lhs , rhs ) !< Operator `=`. class ( primitive_compressible_multispecie ), intent ( inout ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. select type ( rhs ) class is ( primitive_compressible_multispecie ) lhs % density = rhs % density lhs % velocity = rhs % velocity lhs % pressure = rhs % pressure if ( allocated ( rhs % partial_densities )) lhs % partial_densities = rhs % partial_densities endselect endsubroutine assign_field elemental subroutine assign_real ( lhs , rhs ) !< Operator `field = real`. class ( primitive_compressible_multispecie ), intent ( inout ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. lhs % density = rhs lhs % velocity = rhs lhs % pressure = rhs if ( allocated ( lhs % partial_densities )) lhs % partial_densities = rhs endsubroutine assign_real function positive ( self ) result ( opr ) !< Unary operator `+ field`. class ( primitive_compressible_multispecie ), intent ( in ) :: self !< Primitive. class ( field_object ), allocatable :: opr !< Operator result. allocate ( primitive_compressible_multispecie :: opr ) select type ( opr ) class is ( primitive_compressible_multispecie ) opr % density = + self % density opr % velocity = + self % velocity opr % pressure = + self % pressure if ( allocated ( self % partial_densities )) opr % partial_densities = + self % partial_densities endselect endfunction positive elemental function add ( lhs , rhs ) result ( opr ) !< Operator `+`. class ( primitive_compressible_multispecie ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( primitive_compressible_multispecie :: opr ) select type ( opr ) class is ( primitive_compressible_multispecie ) select type ( rhs ) class is ( primitive_compressible_multispecie ) opr % density = lhs % density + rhs % density opr % velocity = lhs % velocity + rhs % velocity opr % pressure = lhs % pressure + rhs % pressure if ( lhs . compatible . rhs ) opr % partial_densities = lhs % partial_densities + rhs % partial_densities endselect endselect endfunction add elemental function div ( lhs , rhs ) result ( opr ) !< Operator `/`. class ( primitive_compressible_multispecie ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( primitive_compressible_multispecie :: opr ) select type ( opr ) class is ( primitive_compressible_multispecie ) select type ( rhs ) class is ( primitive_compressible_multispecie ) opr % density = lhs % density / rhs % density opr % velocity = lhs % velocity / rhs % velocity opr % pressure = lhs % pressure / rhs % pressure if ( lhs . compatible . rhs ) opr % partial_densities = lhs % partial_densities / rhs % partial_densities endselect endselect endfunction div elemental function div_integer ( lhs , rhs ) result ( opr ) !< Operator `field / integer`. class ( primitive_compressible_multispecie ), intent ( in ) :: lhs !< Left hand side. integer ( I4P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( primitive_compressible_multispecie :: opr ) select type ( opr ) class is ( primitive_compressible_multispecie ) opr % density = lhs % density / rhs opr % velocity = lhs % velocity / rhs opr % pressure = lhs % pressure / rhs if ( allocated ( lhs % partial_densities )) opr % partial_densities = lhs % partial_densities / rhs endselect endfunction div_integer elemental function div_real ( lhs , rhs ) result ( opr ) !< Operator `field / real`. class ( primitive_compressible_multispecie ), intent ( in ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( primitive_compressible_multispecie :: opr ) select type ( opr ) class is ( primitive_compressible_multispecie ) opr % density = lhs % density / rhs opr % velocity = lhs % velocity / rhs opr % pressure = lhs % pressure / rhs if ( allocated ( lhs % partial_densities )) opr % partial_densities = lhs % partial_densities / rhs endselect endfunction div_real elemental function mul ( lhs , rhs ) result ( opr ) !< Operator `*`. class ( primitive_compressible_multispecie ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( primitive_compressible_multispecie :: opr ) select type ( opr ) class is ( primitive_compressible_multispecie ) select type ( rhs ) class is ( primitive_compressible_multispecie ) opr % density = lhs % density * rhs % density opr % velocity = lhs % velocity * rhs % velocity opr % pressure = lhs % pressure * rhs % pressure if ( lhs . compatible . rhs ) opr % partial_densities = lhs % partial_densities * rhs % partial_densities endselect endselect endfunction mul elemental function mul_integer ( lhs , rhs ) result ( opr ) !< Operator `field * integer`. class ( primitive_compressible_multispecie ), intent ( in ) :: lhs !< Left hand side. integer ( I4P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( primitive_compressible_multispecie :: opr ) select type ( opr ) class is ( primitive_compressible_multispecie ) opr % density = lhs % density * rhs opr % velocity = lhs % velocity * rhs opr % pressure = lhs % pressure * rhs if ( allocated ( lhs % partial_densities )) opr % partial_densities = lhs % partial_densities * rhs endselect endfunction mul_integer elemental function integer_mul ( lhs , rhs ) result ( opr ) !< Operator `integer * field`. integer ( I4P ), intent ( in ) :: lhs !< Left hand side. class ( primitive_compressible_multispecie ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( primitive_compressible_multispecie :: opr ) select type ( opr ) class is ( primitive_compressible_multispecie ) opr % density = lhs * rhs % density opr % velocity = lhs * rhs % velocity opr % pressure = lhs * rhs % pressure if ( allocated ( rhs % partial_densities )) opr % partial_densities = lhs * rhs % partial_densities endselect endfunction integer_mul elemental function mul_real ( lhs , rhs ) result ( opr ) !< Operator `field * real`. class ( primitive_compressible_multispecie ), intent ( in ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( primitive_compressible_multispecie :: opr ) select type ( opr ) class is ( primitive_compressible_multispecie ) opr % density = lhs % density * rhs opr % velocity = lhs % velocity * rhs opr % pressure = lhs % pressure * rhs if ( allocated ( lhs % partial_densities )) opr % partial_densities = lhs % partial_densities * rhs endselect endfunction mul_real elemental function real_mul ( lhs , rhs ) result ( opr ) !< Operator `real * field`. real ( R8P ), intent ( in ) :: lhs !< Left hand side. class ( primitive_compressible_multispecie ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( primitive_compressible_multispecie :: opr ) select type ( opr ) class is ( primitive_compressible_multispecie ) opr % density = lhs * rhs % density opr % velocity = lhs * rhs % velocity opr % pressure = lhs * rhs % pressure if ( allocated ( rhs % partial_densities )) opr % partial_densities = lhs * rhs % partial_densities endselect endfunction real_mul function negative ( self ) result ( operator_result ) !< Unary operator `- field`. class ( primitive_compressible_multispecie ), intent ( in ) :: self !< Primitive. class ( field_object ), allocatable :: operator_result !< Operator result. allocate ( primitive_compressible_multispecie :: operator_result ) select type ( operator_result ) class is ( primitive_compressible_multispecie ) operator_result % density = - self % density operator_result % velocity = - self % velocity operator_result % pressure = - self % pressure if ( allocated ( self % partial_densities )) operator_result % partial_densities = - self % partial_densities endselect endfunction negative elemental function sub ( lhs , rhs ) result ( opr ) !< Operator `-`. class ( primitive_compressible_multispecie ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( primitive_compressible_multispecie :: opr ) select type ( opr ) class is ( primitive_compressible_multispecie ) select type ( rhs ) class is ( primitive_compressible_multispecie ) opr % density = lhs % density - rhs % density opr % velocity = lhs % velocity - rhs % velocity opr % pressure = lhs % pressure - rhs % pressure if ( lhs . compatible . rhs ) opr % partial_densities = lhs % partial_densities - rhs % partial_densities endselect endselect endfunction sub elemental function pow_integer ( lhs , rhs ) result ( opr ) !< Operator `field ** integer`. class ( primitive_compressible_multispecie ), intent ( in ) :: lhs !< Left hand side. integer ( I4P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( primitive_compressible_multispecie :: opr ) select type ( opr ) class is ( primitive_compressible_multispecie ) opr % density = lhs % density ** rhs opr % velocity % x = lhs % velocity % x ** rhs opr % velocity % y = lhs % velocity % y ** rhs opr % velocity % z = lhs % velocity % z ** rhs opr % pressure = lhs % pressure ** rhs if ( allocated ( lhs % partial_densities )) opr % partial_densities = lhs % partial_densities ** rhs endselect endfunction pow_integer elemental function pow_real ( lhs , rhs ) result ( opr ) !< Operator `field ** real`. class ( primitive_compressible_multispecie ), intent ( in ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( primitive_compressible_multispecie :: opr ) select type ( opr ) class is ( primitive_compressible_multispecie ) opr % density = lhs % density ** rhs opr % velocity % x = lhs % velocity % x ** rhs opr % velocity % y = lhs % velocity % y ** rhs opr % velocity % z = lhs % velocity % z ** rhs opr % pressure = lhs % pressure ** rhs if ( allocated ( lhs % partial_densities )) opr % partial_densities = lhs % partial_densities ** rhs endselect endfunction pow_real elemental function eq ( lhs , rhs ) result ( opr ) !< Operator `=='. class ( primitive_compressible_multispecie ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. logical :: opr !< Operator result. integer ( I4P ) :: d !< Counter. select type ( rhs ) class is ( primitive_compressible_multispecie ) opr = lhs % density == rhs % density if ( opr ) opr = lhs % velocity == rhs % velocity if ( opr ) opr = lhs % pressure == rhs % pressure if ( opr . and . allocated ( lhs % partial_densities ). and . allocated ( rhs % partial_densities )) then if ( opr ) opr = lhs . compatible . rhs if ( opr ) then do d = 1 , size ( lhs % partial_densities , dim = 1 ) opr = lhs % partial_densities ( d ) == rhs % partial_densities ( d ) if (. not . opr ) exit enddo endif elseif ( opr . and . allocated ( lhs % partial_densities ). and .(. not . allocated ( rhs % partial_densities ))) then opr = . false . elseif ( opr . and .(. not . allocated ( lhs % partial_densities )). and . allocated ( rhs % partial_densities )) then opr = . false . endif endselect endfunction eq elemental function not_eq ( lhs , rhs ) result ( opr ) !< Operator `/='. class ( primitive_compressible_multispecie ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. logical :: opr !< Operator result. opr = . not .( lhs % eq ( rhs = rhs )) endfunction not_eq ! public methods elemental function compatible ( lhs , rhs ) result ( opr ) !< Operator `.compatible.`. class ( primitive_compressible_multispecie ), intent ( in ) :: lhs !< Left hand side. type ( primitive_compressible_multispecie ), intent ( in ) :: rhs !< Right hand side. logical :: opr !< Operator result. opr = allocated ( lhs % partial_densities ). and . allocated ( rhs % partial_densities ) if ( opr ) opr = size ( lhs % partial_densities , dim = 1 ) == size ( rhs % partial_densities , dim = 1 ) endfunction compatible ! private non TBP pure function primitive_compressible_multispecie_instance ( density , velocity , pressure , partial_densities ) result ( instance ) !< Return and instance of [[primitive_compressible_multispecie]]. !< !< @note This procedure is used for overloading [[primitive_compressible_multispecie]] name. real ( R8P ), intent ( in ), optional :: density !< Density field. type ( vector ), intent ( in ), optional :: velocity !< Velocity field. real ( R8P ), intent ( in ), optional :: pressure !< Pressure field. real ( R8P ), intent ( in ), optional :: partial_densities (:) !< Partial densities field. type ( primitive_compressible_multispecie ) :: instance !< Instance of [[primitive_compressible_multispecie]]. if ( present ( density )) instance % density = density if ( present ( velocity )) instance % velocity = velocity if ( present ( pressure )) instance % pressure = pressure if ( present ( partial_densities )) instance % partial_densities = partial_densities endfunction primitive_compressible_multispecie_instance endmodule flow_primitive_compressible_multispecie","tags":"","loc":"sourcefile/flow_primitive_compressible_multispecie.f90.html","title":"flow_primitive_compressible_multispecie.f90 – FLOw"},{"text":"FLOw primitive abstract object. This File Depends On sourcefile~~flow_primitive_object.f90~~EfferentGraph sourcefile~flow_primitive_object.f90 flow_primitive_object.f90 sourcefile~flow_field_object.f90 flow_field_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_object.f90 sourcefile~vecfor.f90 vecfor.F90 sourcefile~vecfor.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_eos_object.f90 flow_eos_object.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_object.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~flow_primitive_object.f90 sourcefile~penf.f90->sourcefile~flow_field_object.f90 sourcefile~penf.f90->sourcefile~flow_eos_object.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 var pansourcefileflow_primitive_objectf90EfferentGraph = svgPanZoom('#sourcefileflow_primitive_objectf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~flow_primitive_object.f90~~AfferentGraph sourcefile~flow_primitive_object.f90 flow_primitive_object.f90 sourcefile~flow_primitive_compressible_multispecie.f90 flow_primitive_compressible_multispecie.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_primitive_compressible.f90 flow_primitive_compressible.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow.f90 flow.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow.f90 sourcefile~flow_primitive_compressible_multispecie.f90->sourcefile~flow.f90 sourcefile~flow_primitive_compressible.f90->sourcefile~flow.f90 sourcefile~flow_compressible_transformations.f90 flow_compressible_transformations.f90 sourcefile~flow_primitive_compressible.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_test_primitive_compressible_sub.f90 flow_test_primitive_compressible_sub.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_sub.f90 sourcefile~flow_test_conservative_compressible_assign.f90 flow_test_conservative_compressible_assign.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_assign.f90 sourcefile~flow_test_conservative_compressible_add.f90 flow_test_conservative_compressible_add.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_add.f90 sourcefile~flow_test_conservative_compressible_div.f90 flow_test_conservative_compressible_div.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_div.f90 sourcefile~flow_test_conservative_compressible_eq.f90 flow_test_conservative_compressible_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_eq.f90 sourcefile~flow_test_conservative_compressible_mul.f90 flow_test_conservative_compressible_mul.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_mul.f90 sourcefile~flow_test_conservative_compressible_not_eq.f90 flow_test_conservative_compressible_not_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_not_eq.f90 sourcefile~flow_test_conservative_compressible_pow.f90 flow_test_conservative_compressible_pow.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_pow.f90 sourcefile~flow_test_conservative_compressible_sub.f90 flow_test_conservative_compressible_sub.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_sub.f90 sourcefile~flow_test_eos_compressible.f90 flow_test_eos_compressible.f90 sourcefile~flow.f90->sourcefile~flow_test_eos_compressible.f90 sourcefile~flow_test_primitive_compressible_add.f90 flow_test_primitive_compressible_add.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_add.f90 sourcefile~flow_test_primitive_compressible_assign.f90 flow_test_primitive_compressible_assign.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_assign.f90 sourcefile~flow_test_primitive_compressible_div.f90 flow_test_primitive_compressible_div.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_div.f90 sourcefile~flow_test_primitive_compressible_eq.f90 flow_test_primitive_compressible_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_eq.f90 sourcefile~flow_test_primitive_compressible_mul.f90 flow_test_primitive_compressible_mul.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_mul.f90 sourcefile~flow_test_primitive_compressible_multispecie_add.f90 flow_test_primitive_compressible_multispecie_add.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_add.f90 sourcefile~flow_test_primitive_compressible_multispecie_assign.f90 flow_test_primitive_compressible_multispecie_assign.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_assign.f90 sourcefile~flow_test_primitive_compressible_multispecie_div.f90 flow_test_primitive_compressible_multispecie_div.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_div.f90 sourcefile~flow_test_primitive_compressible_multispecie_eq.f90 flow_test_primitive_compressible_multispecie_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_eq.f90 sourcefile~flow_test_primitive_compressible_multispecie_mul.f90 flow_test_primitive_compressible_multispecie_mul.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_mul.f90 sourcefile~flow_test_primitive_compressible_multispecie_not_eq.f90 flow_test_primitive_compressible_multispecie_not_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_not_eq.f90 sourcefile~flow_test_primitive_compressible_multispecie_pow.f90 flow_test_primitive_compressible_multispecie_pow.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_pow.f90 sourcefile~flow_test_primitive_compressible_multispecie_sub.f90 flow_test_primitive_compressible_multispecie_sub.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_sub.f90 sourcefile~flow_test_primitive_compressible_not_eq.f90 flow_test_primitive_compressible_not_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_not_eq.f90 sourcefile~flow_test_primitive_compressible_pow.f90 flow_test_primitive_compressible_pow.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_pow.f90 sourcefile~flow_test_compressible_transformations.f90 flow_test_compressible_transformations.f90 sourcefile~flow.f90->sourcefile~flow_test_compressible_transformations.f90 sourcefile~flow_compressible_transformations.f90->sourcefile~flow.f90 var pansourcefileflow_primitive_objectf90AfferentGraph = svgPanZoom('#sourcefileflow_primitive_objectf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules flow_primitive_object Source Code flow_primitive_object.f90 Source Code !< FLOw **primitive** abstract object. module flow_primitive_object !< FLOw **primitive** abstract object. !< !< [[primitive_object]] is a class that handles primitive fluid dynamic variables. use flow_eos_object , only : eos_object use flow_field_object , only : field_object use penf , only : R8P use vecfor , only : vector implicit none private public :: primitive_object type , extends ( field_object ), abstract :: primitive_object !< **Primitive** object. contains ! deferred methods procedure ( destroy_interface ), pass ( self ), deferred :: destroy !< Destroy primitive. procedure ( energy_interface ), pass ( self ), deferred :: energy !< Return energy value. procedure ( initialize_interface ), pass ( self ), deferred :: initialize !< Initialize primitive. procedure ( momentum_interface ), pass ( self ), deferred :: momentum !< Return momentum vector. endtype primitive_object abstract interface !< Abstract interfaces of deferred methods of [[primitive_object]]. elemental subroutine destroy_interface ( self ) !< Destroy primitive. import :: primitive_object class ( primitive_object ), intent ( inout ) :: self !< Primitive. endsubroutine destroy_interface elemental function energy_interface ( self , eos ) result ( energy_ ) !< Return energy value. import :: primitive_object , eos_object , R8P class ( primitive_object ), intent ( in ) :: self !< Primitive. class ( eos_object ), intent ( in ) :: eos !< Equation of state. real ( R8P ) :: energy_ !< Energy value. endfunction energy_interface subroutine initialize_interface ( self , initial_state ) !< Initialize primitive. import :: primitive_object class ( primitive_object ), intent ( inout ) :: self !< Primitive. class ( primitive_object ), optional , intent ( in ) :: initial_state !< Initial state. endsubroutine initialize_interface elemental function momentum_interface ( self ) result ( momentum_ ) !< Return momentum vector. import :: primitive_object , vector class ( primitive_object ), intent ( in ) :: self !< Primitive. type ( vector ) :: momentum_ !< Momentum vector. endfunction momentum_interface endinterface endmodule flow_primitive_object","tags":"","loc":"sourcefile/flow_primitive_object.f90.html","title":"flow_primitive_object.f90 – FLOw"},{"text":"FLOw test. This File Depends On sourcefile~~flow_test_compressible_transformations.f90~~EfferentGraph sourcefile~flow_test_compressible_transformations.f90 flow_test_compressible_transformations.f90 sourcefile~flow.f90 flow.f90 sourcefile~flow.f90->sourcefile~flow_test_compressible_transformations.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~flow_test_compressible_transformations.f90 sourcefile~flow_eos_compressible.f90 flow_eos_compressible.f90 sourcefile~penf.f90->sourcefile~flow_eos_compressible.f90 sourcefile~flow_field_scalar_vectorial.f90 flow_field_scalar_vectorial.f90 sourcefile~penf.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~flow_primitive_object.f90 flow_primitive_object.f90 sourcefile~penf.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_conservative_compressible.f90 flow_conservative_compressible.f90 sourcefile~penf.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_primitive_compressible.f90 flow_primitive_compressible.f90 sourcefile~penf.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_conservative_object.f90 flow_conservative_object.f90 sourcefile~penf.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_primitive_compressible_multispecie.f90 flow_primitive_compressible_multispecie.f90 sourcefile~penf.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_eos_object.f90 flow_eos_object.f90 sourcefile~penf.f90->sourcefile~flow_eos_object.f90 sourcefile~flow_field_object.f90 flow_field_object.f90 sourcefile~penf.f90->sourcefile~flow_field_object.f90 sourcefile~flow_compressible_transformations.f90 flow_compressible_transformations.f90 sourcefile~penf.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_eos_compressible.f90->sourcefile~flow.f90 sourcefile~flow_field_scalar_vectorial.f90->sourcefile~flow.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_conservative_compressible.f90->sourcefile~flow.f90 sourcefile~flow_conservative_compressible.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_primitive_compressible.f90->sourcefile~flow.f90 sourcefile~flow_primitive_compressible.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_conservative_object.f90->sourcefile~flow.f90 sourcefile~flow_conservative_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_primitive_compressible_multispecie.f90->sourcefile~flow.f90 sourcefile~flow_eos_object.f90->sourcefile~flow.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_eos_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_field_object.f90->sourcefile~flow.f90 sourcefile~flow_field_object.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_field_object.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_compressible_transformations.f90->sourcefile~flow.f90 sourcefile~vecfor.f90 vecfor.F90 sourcefile~vecfor.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_object.f90 sourcefile~vecfor.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~vecfor.f90->sourcefile~flow_conservative_object.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~vecfor.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 var pansourcefileflow_test_compressible_transformationsf90EfferentGraph = svgPanZoom('#sourcefileflow_test_compressible_transformationsf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs flow_test_compressible_transformations Source Code flow_test_compressible_transformations.f90 Source Code !< FLOw test. program flow_test_compressible_transformations !< FLOw test. use flow , only : eos_compressible , conservative_compressible , primitive_compressible , & conservative_to_primitive_compressible , primitive_to_conservative_compressible use penf , only : R8P , ZeroR8 implicit none type ( eos_compressible ) :: eos !< An equation of state. type ( primitive_compressible ) :: p !< A primitive compressible instance. type ( conservative_compressible ) :: u !< A conservative compressible instance. logical :: are_tests_passed ( 2 ) !< List of passed tests. are_tests_passed = . false . eos = eos_compressible ( cp = 104 0.004_R8P , cv = 74 2.86_R8P ) u = conservative_compressible ( density = 1._R8P , energy = 2.5_R8P ) p = conservative_to_primitive_compressible ( conservative = u , eos = eos ) are_tests_passed ( 1 ) = ( p % density >= 1._R8P - ZeroR8 ). and .( p % density <= 1._R8P + ZeroR8 ). and . & ( p % velocity >= 0._R8P - ZeroR8 ). and .( p % velocity <= 0._R8P + ZeroR8 ). and . & ( p % pressure >= 1._R8P - ZeroR8 ). and .( p % pressure <= 1._R8P + ZeroR8 ) print \"(A,L1)\" , 'u to p, is done right? ' , are_tests_passed ( 1 ) p = primitive_compressible ( density = 1._R8P , pressure = 1._R8P ) u = primitive_to_conservative_compressible ( primitive = p , eos = eos ) are_tests_passed ( 2 ) = ( u % density >= 1._R8P - ZeroR8 ). and .( u % density <= 1._R8P + ZeroR8 ). and . & ( u % momentum >= 0._R8P - ZeroR8 ). and .( u % momentum <= 0._R8P + ZeroR8 ). and . & ( u % energy >= 2.5_R8P - ZeroR8 ). and .( u % energy <= 2.5_R8P + ZeroR8 ) print \"(A,L1)\" , 'p to u, is done right? ' , are_tests_passed ( 2 ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( are_tests_passed ) endprogram flow_test_compressible_transformations","tags":"","loc":"sourcefile/flow_test_compressible_transformations.f90.html","title":"flow_test_compressible_transformations.f90 – FLOw"},{"text":"FLOw test. This File Depends On sourcefile~~flow_test_conservative_compressible_add.f90~~EfferentGraph sourcefile~flow_test_conservative_compressible_add.f90 flow_test_conservative_compressible_add.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~flow_test_conservative_compressible_add.f90 sourcefile~flow_eos_compressible.f90 flow_eos_compressible.f90 sourcefile~penf.f90->sourcefile~flow_eos_compressible.f90 sourcefile~flow_field_scalar_vectorial.f90 flow_field_scalar_vectorial.f90 sourcefile~penf.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~flow_primitive_object.f90 flow_primitive_object.f90 sourcefile~penf.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_conservative_compressible.f90 flow_conservative_compressible.f90 sourcefile~penf.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_primitive_compressible.f90 flow_primitive_compressible.f90 sourcefile~penf.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_conservative_object.f90 flow_conservative_object.f90 sourcefile~penf.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_primitive_compressible_multispecie.f90 flow_primitive_compressible_multispecie.f90 sourcefile~penf.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_eos_object.f90 flow_eos_object.f90 sourcefile~penf.f90->sourcefile~flow_eos_object.f90 sourcefile~flow_field_object.f90 flow_field_object.f90 sourcefile~penf.f90->sourcefile~flow_field_object.f90 sourcefile~flow_compressible_transformations.f90 flow_compressible_transformations.f90 sourcefile~penf.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow.f90 flow.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_add.f90 sourcefile~vecfor.f90 vecfor.F90 sourcefile~vecfor.f90->sourcefile~flow_test_conservative_compressible_add.f90 sourcefile~vecfor.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_object.f90 sourcefile~vecfor.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~vecfor.f90->sourcefile~flow_conservative_object.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~vecfor.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~flow_eos_compressible.f90->sourcefile~flow.f90 sourcefile~flow_field_scalar_vectorial.f90->sourcefile~flow.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_conservative_compressible.f90->sourcefile~flow.f90 sourcefile~flow_conservative_compressible.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_primitive_compressible.f90->sourcefile~flow.f90 sourcefile~flow_primitive_compressible.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_conservative_object.f90->sourcefile~flow.f90 sourcefile~flow_conservative_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_primitive_compressible_multispecie.f90->sourcefile~flow.f90 sourcefile~flow_eos_object.f90->sourcefile~flow.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_eos_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_field_object.f90->sourcefile~flow.f90 sourcefile~flow_field_object.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_field_object.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_compressible_transformations.f90->sourcefile~flow.f90 var pansourcefileflow_test_conservative_compressible_addf90EfferentGraph = svgPanZoom('#sourcefileflow_test_conservative_compressible_addf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs flow_test_conservative_compressible_add Source Code flow_test_conservative_compressible_add.f90 Source Code !< FLOw test. program flow_test_conservative_compressible_add !< FLOw test. use flow , only : conservative_compressible use penf , only : R8P use vecfor , only : vector implicit none type ( conservative_compressible ) :: conservative1 !< A conservative object. type ( conservative_compressible ) :: conservative2 !< A conservative object. type ( conservative_compressible ) :: conservative3 !< A conservative object. type ( vector ) :: momentum !< A vector object. logical :: test_passed ( 2 ) !< List of passed tests. test_passed = . false . momentum = 1._R8P conservative1 = conservative_compressible ( density = 0.125_R8P , momentum = momentum , energy = 1._R8P ) momentum = 2._R8P conservative2 = conservative_compressible ( density = 1._R8P , momentum = momentum , energy = 1._R8P ) conservative3 = conservative1 + conservative2 test_passed ( 1 ) = conservative3 == ( conservative1 + conservative2 ) print \"(A,F6.3)\" , 'density  => 0.125  + 1   = ' , conservative3 % density print \"(A,3(F6.3,1X))\" , 'momentum => 1      + 2   = ' , conservative3 % momentum print \"(A,F6.3)\" , 'energy   => 1      + 1   = ' , conservative3 % energy momentum = - 1._R8P conservative1 = conservative_compressible ( density = 0.125_R8P , momentum = momentum , energy = 1._R8P ) conservative2 = + conservative1 test_passed ( 2 ) = conservative2 == conservative1 print \"(A,F6.3)\" , 'density  => + (0.125) = ' , conservative2 % density print \"(A,3(F6.3,1X))\" , 'momentum => + (-1)    = ' , conservative2 % momentum print \"(A,F6.3)\" , 'energy   => + (1)     = ' , conservative2 % energy print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram flow_test_conservative_compressible_add","tags":"","loc":"sourcefile/flow_test_conservative_compressible_add.f90.html","title":"flow_test_conservative_compressible_add.f90 – FLOw"},{"text":"FLOw test. This File Depends On sourcefile~~flow_test_conservative_compressible_assign.f90~~EfferentGraph sourcefile~flow_test_conservative_compressible_assign.f90 flow_test_conservative_compressible_assign.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~flow_test_conservative_compressible_assign.f90 sourcefile~flow_eos_compressible.f90 flow_eos_compressible.f90 sourcefile~penf.f90->sourcefile~flow_eos_compressible.f90 sourcefile~flow_field_scalar_vectorial.f90 flow_field_scalar_vectorial.f90 sourcefile~penf.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~flow_primitive_object.f90 flow_primitive_object.f90 sourcefile~penf.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_conservative_compressible.f90 flow_conservative_compressible.f90 sourcefile~penf.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_primitive_compressible.f90 flow_primitive_compressible.f90 sourcefile~penf.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_conservative_object.f90 flow_conservative_object.f90 sourcefile~penf.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_primitive_compressible_multispecie.f90 flow_primitive_compressible_multispecie.f90 sourcefile~penf.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_eos_object.f90 flow_eos_object.f90 sourcefile~penf.f90->sourcefile~flow_eos_object.f90 sourcefile~flow_field_object.f90 flow_field_object.f90 sourcefile~penf.f90->sourcefile~flow_field_object.f90 sourcefile~flow_compressible_transformations.f90 flow_compressible_transformations.f90 sourcefile~penf.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow.f90 flow.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_assign.f90 sourcefile~vecfor.f90 vecfor.F90 sourcefile~vecfor.f90->sourcefile~flow_test_conservative_compressible_assign.f90 sourcefile~vecfor.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_object.f90 sourcefile~vecfor.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~vecfor.f90->sourcefile~flow_conservative_object.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~vecfor.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~flow_eos_compressible.f90->sourcefile~flow.f90 sourcefile~flow_field_scalar_vectorial.f90->sourcefile~flow.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_conservative_compressible.f90->sourcefile~flow.f90 sourcefile~flow_conservative_compressible.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_primitive_compressible.f90->sourcefile~flow.f90 sourcefile~flow_primitive_compressible.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_conservative_object.f90->sourcefile~flow.f90 sourcefile~flow_conservative_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_primitive_compressible_multispecie.f90->sourcefile~flow.f90 sourcefile~flow_eos_object.f90->sourcefile~flow.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_eos_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_field_object.f90->sourcefile~flow.f90 sourcefile~flow_field_object.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_field_object.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_compressible_transformations.f90->sourcefile~flow.f90 var pansourcefileflow_test_conservative_compressible_assignf90EfferentGraph = svgPanZoom('#sourcefileflow_test_conservative_compressible_assignf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs flow_test_conservative_compressible_assign Source Code flow_test_conservative_compressible_assign.f90 Source Code !< FLOw test. program flow_test_conservative_compressible_assign !< FLOw test. use flow , only : conservative_compressible use penf , only : R8P use vecfor , only : vector implicit none type ( conservative_compressible ) :: conservative1 !< A conservative object. type ( conservative_compressible ) :: conservative2 !< A conservative object. type ( vector ) :: momentum !< A vector object. logical :: test_passed ( 2 ) !< List of passed tests. test_passed = . false . conservative1 = 0.125_R8P test_passed ( 1 ) = ( conservative1 % density == 0.125_R8P ). and . & ( conservative1 % momentum % x == 0.125_R8P ). and . & ( conservative1 % momentum % y == 0.125_R8P ). and . & ( conservative1 % momentum % z == 0.125_R8P ). and . & ( conservative1 % energy == 0.125_R8P ) print \"(A,F6.3)\" , 'density   = ' , conservative1 % density print \"(A,3(F6.3,1X))\" , 'momentum  = ' , conservative1 % momentum print \"(A,F6.3)\" , 'energy    = ' , conservative1 % energy momentum = 1._R8P conservative1 = conservative_compressible ( density = 0.125_R8P , momentum = momentum , energy = 2._R8P ) conservative2 = conservative1 test_passed ( 2 ) = conservative1 == conservative2 print \"(A)\" , '' print \"(A,F6.3)\" , 'density   = ' , conservative2 % density print \"(A,3(F6.3,1X))\" , 'momentum  = ' , conservative2 % momentum print \"(A,F6.3)\" , 'energy    = ' , conservative2 % energy print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram flow_test_conservative_compressible_assign","tags":"","loc":"sourcefile/flow_test_conservative_compressible_assign.f90.html","title":"flow_test_conservative_compressible_assign.f90 – FLOw"},{"text":"FLOw test. This File Depends On sourcefile~~flow_test_conservative_compressible_div.f90~~EfferentGraph sourcefile~flow_test_conservative_compressible_div.f90 flow_test_conservative_compressible_div.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~flow_test_conservative_compressible_div.f90 sourcefile~flow_eos_compressible.f90 flow_eos_compressible.f90 sourcefile~penf.f90->sourcefile~flow_eos_compressible.f90 sourcefile~flow_field_scalar_vectorial.f90 flow_field_scalar_vectorial.f90 sourcefile~penf.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~flow_primitive_object.f90 flow_primitive_object.f90 sourcefile~penf.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_conservative_compressible.f90 flow_conservative_compressible.f90 sourcefile~penf.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_primitive_compressible.f90 flow_primitive_compressible.f90 sourcefile~penf.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_conservative_object.f90 flow_conservative_object.f90 sourcefile~penf.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_primitive_compressible_multispecie.f90 flow_primitive_compressible_multispecie.f90 sourcefile~penf.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_eos_object.f90 flow_eos_object.f90 sourcefile~penf.f90->sourcefile~flow_eos_object.f90 sourcefile~flow_field_object.f90 flow_field_object.f90 sourcefile~penf.f90->sourcefile~flow_field_object.f90 sourcefile~flow_compressible_transformations.f90 flow_compressible_transformations.f90 sourcefile~penf.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow.f90 flow.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_div.f90 sourcefile~vecfor.f90 vecfor.F90 sourcefile~vecfor.f90->sourcefile~flow_test_conservative_compressible_div.f90 sourcefile~vecfor.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_object.f90 sourcefile~vecfor.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~vecfor.f90->sourcefile~flow_conservative_object.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~vecfor.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~flow_eos_compressible.f90->sourcefile~flow.f90 sourcefile~flow_field_scalar_vectorial.f90->sourcefile~flow.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_conservative_compressible.f90->sourcefile~flow.f90 sourcefile~flow_conservative_compressible.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_primitive_compressible.f90->sourcefile~flow.f90 sourcefile~flow_primitive_compressible.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_conservative_object.f90->sourcefile~flow.f90 sourcefile~flow_conservative_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_primitive_compressible_multispecie.f90->sourcefile~flow.f90 sourcefile~flow_eos_object.f90->sourcefile~flow.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_eos_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_field_object.f90->sourcefile~flow.f90 sourcefile~flow_field_object.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_field_object.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_compressible_transformations.f90->sourcefile~flow.f90 var pansourcefileflow_test_conservative_compressible_divf90EfferentGraph = svgPanZoom('#sourcefileflow_test_conservative_compressible_divf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs flow_test_conservative_compressible_div Source Code flow_test_conservative_compressible_div.f90 Source Code !< FLOw test. program flow_test_conservative_compressible_div !< FLOw test. use flow , only : conservative_compressible use penf , only : I4P , R8P use vecfor , only : vector implicit none type ( conservative_compressible ) :: conservative1 !< A conservative object. type ( conservative_compressible ) :: conservative2 !< A conservative object. type ( conservative_compressible ) :: conservative3 !< A conservative object. type ( vector ) :: momentum !< A vector object. logical :: test_passed ( 3 ) !< List of passed tests. test_passed = . false . momentum = 1._R8P conservative1 = conservative_compressible ( density = 0.125_R8P , momentum = momentum , energy = 1._R8P ) momentum = 2._R8P conservative2 = conservative_compressible ( density = 1._R8P , momentum = momentum , energy = 1._R8P ) conservative3 = conservative1 / conservative2 test_passed ( 1 ) = conservative3 == ( conservative1 / conservative2 ) print \"(A,F6.3)\" , 'density   => 0.125  / 1   = ' , conservative3 % density print \"(A,3(F6.3,1X))\" , 'momentum  => 1      / 2   = ' , conservative3 % momentum print \"(A,F6.3)\" , 'energy    => 1      / 1   = ' , conservative3 % energy call print_error ( test = 'conservative3 = conservative1 / conservative2' , is_test_passed = test_passed ( 1 )) conservative3 = conservative1 / 2._R8P test_passed ( 2 ) = conservative3 == ( conservative1 / 2._R8P ) print \"(A)\" , '' print \"(A,F6.3)\" , 'density   => 0.125  / 2.0 = ' , conservative3 % density print \"(A,3(F6.3,1X))\" , 'momentum  => 1      / 2.0 = ' , conservative3 % momentum print \"(A,F6.3)\" , 'energy    => 1      / 2.0 = ' , conservative3 % energy call print_error ( test = 'conservative3 = conservative1 / 2.0' , is_test_passed = test_passed ( 2 )) conservative3 = conservative1 / 2_I4P test_passed ( 3 ) = conservative3 == ( conservative1 / 2_I4P ) print \"(A)\" , '' print \"(A,F6.3)\" , 'density   => 0.125  / 2 = ' , conservative3 % density print \"(A,3(F6.3,1X))\" , 'momentum  => 1      / 2 = ' , conservative3 % momentum print \"(A,F6.3)\" , 'energy    => 1      / 2 = ' , conservative3 % energy call print_error ( test = 'conservative3 = conservative1 / 2' , is_test_passed = test_passed ( 3 )) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) contains subroutine print_error ( test , is_test_passed ) !< Print error message if test is failed. character ( * ), intent ( in ) :: test !< Test description. logical , intent ( in ) :: is_test_passed !< Test result. if (. not . is_test_passed ) then print * , '\"' // test // '\" failed!' print * , 'conservative1:' print \"(A,F6.3)\" , '  density   = ' , conservative1 % density print \"(A,3(F6.3,1X))\" , '  momentum  = ' , conservative1 % momentum print \"(A,F6.3)\" , '  energy    = ' , conservative1 % energy print * , 'conservative2:' print \"(A,F6.3)\" , '  density   = ' , conservative2 % density print \"(A,3(F6.3,1X))\" , '  momentum  = ' , conservative2 % momentum print \"(A,F6.3)\" , '  energy    = ' , conservative2 % energy print * , 'conservative3:' print \"(A,F6.3)\" , '  density   = ' , conservative3 % density print \"(A,3(F6.3,1X))\" , '  momentum  = ' , conservative3 % momentum print \"(A,F6.3)\" , '  energy    = ' , conservative3 % energy endif endsubroutine print_error endprogram flow_test_conservative_compressible_div","tags":"","loc":"sourcefile/flow_test_conservative_compressible_div.f90.html","title":"flow_test_conservative_compressible_div.f90 – FLOw"},{"text":"FLOw test. This File Depends On sourcefile~~flow_test_conservative_compressible_eq.f90~~EfferentGraph sourcefile~flow_test_conservative_compressible_eq.f90 flow_test_conservative_compressible_eq.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~flow_test_conservative_compressible_eq.f90 sourcefile~flow_eos_compressible.f90 flow_eos_compressible.f90 sourcefile~penf.f90->sourcefile~flow_eos_compressible.f90 sourcefile~flow_field_scalar_vectorial.f90 flow_field_scalar_vectorial.f90 sourcefile~penf.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~flow_primitive_object.f90 flow_primitive_object.f90 sourcefile~penf.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_conservative_compressible.f90 flow_conservative_compressible.f90 sourcefile~penf.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_primitive_compressible.f90 flow_primitive_compressible.f90 sourcefile~penf.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_conservative_object.f90 flow_conservative_object.f90 sourcefile~penf.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_primitive_compressible_multispecie.f90 flow_primitive_compressible_multispecie.f90 sourcefile~penf.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_eos_object.f90 flow_eos_object.f90 sourcefile~penf.f90->sourcefile~flow_eos_object.f90 sourcefile~flow_field_object.f90 flow_field_object.f90 sourcefile~penf.f90->sourcefile~flow_field_object.f90 sourcefile~flow_compressible_transformations.f90 flow_compressible_transformations.f90 sourcefile~penf.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow.f90 flow.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_eq.f90 sourcefile~vecfor.f90 vecfor.F90 sourcefile~vecfor.f90->sourcefile~flow_test_conservative_compressible_eq.f90 sourcefile~vecfor.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_object.f90 sourcefile~vecfor.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~vecfor.f90->sourcefile~flow_conservative_object.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~vecfor.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~flow_eos_compressible.f90->sourcefile~flow.f90 sourcefile~flow_field_scalar_vectorial.f90->sourcefile~flow.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_conservative_compressible.f90->sourcefile~flow.f90 sourcefile~flow_conservative_compressible.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_primitive_compressible.f90->sourcefile~flow.f90 sourcefile~flow_primitive_compressible.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_conservative_object.f90->sourcefile~flow.f90 sourcefile~flow_conservative_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_primitive_compressible_multispecie.f90->sourcefile~flow.f90 sourcefile~flow_eos_object.f90->sourcefile~flow.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_eos_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_field_object.f90->sourcefile~flow.f90 sourcefile~flow_field_object.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_field_object.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_compressible_transformations.f90->sourcefile~flow.f90 var pansourcefileflow_test_conservative_compressible_eqf90EfferentGraph = svgPanZoom('#sourcefileflow_test_conservative_compressible_eqf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs flow_test_conservative_compressible_eq Source Code flow_test_conservative_compressible_eq.f90 Source Code !< FLOw test. program flow_test_conservative_compressible_eq !< FLOw test. use flow , only : conservative_compressible use penf , only : R8P use vecfor , only : vector implicit none type ( conservative_compressible ) :: conservative1 !< A conservative object. type ( conservative_compressible ) :: conservative2 !< A conservative object. type ( vector ) :: momentum !< A vector object. logical :: test_passed ( 5 ) !< List of passed tests. test_passed = . false . momentum = 1._R8P conservative1 = conservative_compressible ( density = 0.125_R8P , momentum = momentum , energy = 1._R8P ) momentum = 1._R8P conservative2 = conservative_compressible ( density = 1._R8P , momentum = momentum , energy = 1._R8P ) test_passed ( 1 ) = ( conservative1 == conservative2 ). eqv .(. false .) print \"(A,L1)\" , 'density  => 0.125 /= 1 = ' , test_passed ( 1 ) momentum = 1._R8P conservative1 = conservative_compressible ( density = 0.125_R8P , momentum = momentum , energy = 1._R8P ) momentum = 2._R8P conservative2 = conservative_compressible ( density = 0.125_R8P , momentum = momentum , energy = 1._R8P ) test_passed ( 2 ) = ( conservative1 == conservative2 ). eqv .(. false .) print \"(A,L1)\" , 'momentum => 1     /= 2 = ' , test_passed ( 2 ) momentum = 1._R8P conservative1 = conservative_compressible ( density = 0.125_R8P , momentum = momentum , energy = 1._R8P ) momentum = 2._R8P conservative2 = conservative_compressible ( density = 0.125_R8P , momentum = momentum , energy = 2._R8P ) test_passed ( 3 ) = ( conservative1 == conservative2 ). eqv .(. false .) print \"(A,L1)\" , 'energy   => 1     /= 2 = ' , test_passed ( 3 ) momentum = 1._R8P conservative1 = conservative_compressible ( density = 0.125_R8P , momentum = momentum , energy = 1._R8P ) momentum = 2._R8P conservative2 = conservative_compressible ( density = 1._R8P , momentum = momentum , energy = 2._R8P ) test_passed ( 4 ) = ( conservative1 == conservative2 ). eqv .(. false .) print \"(A)\" , new_line ( 'a' ) // 'all together' print \"(A,L1)\" , 'density  => 0.125 /= 1 = ' , test_passed ( 4 ) print \"(A,L1)\" , 'momentum => 1     /= 2 = ' , test_passed ( 4 ) print \"(A,L1)\" , 'energy   => 1     /= 2 = ' , test_passed ( 4 ) momentum = 1._R8P conservative1 = conservative_compressible ( density = 1._R8P , momentum = momentum , energy = 1._R8P ) momentum = 1._R8P conservative2 = conservative_compressible ( density = 1._R8P , momentum = momentum , energy = 1._R8P ) test_passed ( 5 ) = ( conservative1 == conservative2 ). eqv .(. true .) print \"(A)\" , new_line ( 'a' ) // 'all together true' print \"(A,L1)\" , 'density  => 1 == 1 = ' , test_passed ( 5 ) print \"(A,L1)\" , 'momentum => 1 == 1 = ' , test_passed ( 5 ) print \"(A,L1)\" , 'energy   => 1 == 1 = ' , test_passed ( 5 ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram flow_test_conservative_compressible_eq","tags":"","loc":"sourcefile/flow_test_conservative_compressible_eq.f90.html","title":"flow_test_conservative_compressible_eq.f90 – FLOw"},{"text":"FLOw test. This File Depends On sourcefile~~flow_test_conservative_compressible_mul.f90~~EfferentGraph sourcefile~flow_test_conservative_compressible_mul.f90 flow_test_conservative_compressible_mul.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~flow_test_conservative_compressible_mul.f90 sourcefile~flow_eos_compressible.f90 flow_eos_compressible.f90 sourcefile~penf.f90->sourcefile~flow_eos_compressible.f90 sourcefile~flow_field_scalar_vectorial.f90 flow_field_scalar_vectorial.f90 sourcefile~penf.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~flow_primitive_object.f90 flow_primitive_object.f90 sourcefile~penf.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_conservative_compressible.f90 flow_conservative_compressible.f90 sourcefile~penf.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_primitive_compressible.f90 flow_primitive_compressible.f90 sourcefile~penf.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_conservative_object.f90 flow_conservative_object.f90 sourcefile~penf.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_primitive_compressible_multispecie.f90 flow_primitive_compressible_multispecie.f90 sourcefile~penf.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_eos_object.f90 flow_eos_object.f90 sourcefile~penf.f90->sourcefile~flow_eos_object.f90 sourcefile~flow_field_object.f90 flow_field_object.f90 sourcefile~penf.f90->sourcefile~flow_field_object.f90 sourcefile~flow_compressible_transformations.f90 flow_compressible_transformations.f90 sourcefile~penf.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow.f90 flow.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_mul.f90 sourcefile~vecfor.f90 vecfor.F90 sourcefile~vecfor.f90->sourcefile~flow_test_conservative_compressible_mul.f90 sourcefile~vecfor.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_object.f90 sourcefile~vecfor.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~vecfor.f90->sourcefile~flow_conservative_object.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~vecfor.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~flow_eos_compressible.f90->sourcefile~flow.f90 sourcefile~flow_field_scalar_vectorial.f90->sourcefile~flow.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_conservative_compressible.f90->sourcefile~flow.f90 sourcefile~flow_conservative_compressible.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_primitive_compressible.f90->sourcefile~flow.f90 sourcefile~flow_primitive_compressible.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_conservative_object.f90->sourcefile~flow.f90 sourcefile~flow_conservative_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_primitive_compressible_multispecie.f90->sourcefile~flow.f90 sourcefile~flow_eos_object.f90->sourcefile~flow.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_eos_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_field_object.f90->sourcefile~flow.f90 sourcefile~flow_field_object.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_field_object.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_compressible_transformations.f90->sourcefile~flow.f90 var pansourcefileflow_test_conservative_compressible_mulf90EfferentGraph = svgPanZoom('#sourcefileflow_test_conservative_compressible_mulf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs flow_test_conservative_compressible_mul Source Code flow_test_conservative_compressible_mul.f90 Source Code !< FLOw test. program flow_test_conservative_compressible_mul !< FLOw test. use flow , only : conservative_compressible use penf , only : I4P , R8P use vecfor , only : vector implicit none type ( conservative_compressible ) :: conservative1 !< A conservative object. type ( conservative_compressible ) :: conservative2 !< A conservative object. type ( conservative_compressible ) :: conservative3 !< A conservative object. type ( vector ) :: momentum !< A vector object. logical :: test_passed ( 5 ) !< List of passed tests. test_passed = . false . momentum = 1._R8P conservative1 = conservative_compressible ( density = 0.125_R8P , momentum = momentum , energy = 1._R8P ) momentum = 2._R8P conservative2 = conservative_compressible ( density = 1._R8P , momentum = momentum , energy = 1._R8P ) conservative3 = conservative1 * conservative2 test_passed ( 1 ) = conservative3 == ( conservative1 * conservative2 ) print \"(A,F6.3)\" , 'density   => 0.125  * 1 = ' , conservative3 % density print \"(A,3(F6.3,1X))\" , 'momentum  => 1      * 2 = ' , conservative3 % momentum print \"(A,F6.3)\" , 'energy    => 1      * 1 = ' , conservative3 % energy call print_error ( test = 'conservative3 = conservative1 * conservative2' , is_test_passed = test_passed ( 1 )) conservative3 = 2._R8P * conservative1 test_passed ( 2 ) = conservative3 == ( 2._R8P * conservative1 ) print \"(A)\" , '' print \"(A,F6.3)\" , 'density   => 2.0 * 0.125  = ' , conservative3 % density print \"(A,3(F6.3,1X))\" , 'momentum  => 2.0 * 1      = ' , conservative3 % momentum print \"(A,F6.3)\" , 'energy    => 2.0 * 1      = ' , conservative3 % energy call print_error ( test = 'conservative3 = 2.0 * conservative1' , is_test_passed = test_passed ( 2 )) conservative3 = conservative1 * 2._R8P test_passed ( 3 ) = conservative3 == ( conservative1 * 2._R8P ) print \"(A)\" , '' print \"(A,F6.3)\" , 'density   => 0.125  * 2.0 = ' , conservative3 % density print \"(A,3(F6.3,1X))\" , 'momentum  => 1      * 2.0 = ' , conservative3 % momentum print \"(A,F6.3)\" , 'energy    => 1      * 2.0 = ' , conservative3 % energy call print_error ( test = 'conservative3 = conservative1 * 2.0' , is_test_passed = test_passed ( 3 )) conservative3 = 2_I4P * conservative1 test_passed ( 4 ) = conservative3 == ( 2_I4P * conservative1 ) print \"(A)\" , '' print \"(A,F6.3)\" , 'density   => 2 * 0.125  = ' , conservative3 % density print \"(A,3(F6.3,1X))\" , 'momentum  => 2 * 1      = ' , conservative3 % momentum print \"(A,F6.3)\" , 'energy    => 2 * 1      = ' , conservative3 % energy call print_error ( test = 'conservative3 = 2 * conservative1' , is_test_passed = test_passed ( 4 )) conservative3 = conservative1 * 2_I4P test_passed ( 5 ) = conservative3 == ( conservative1 * 2_I4P ) print \"(A)\" , '' print \"(A,F6.3)\" , 'density   => 0.125  * 2 = ' , conservative3 % density print \"(A,3(F6.3,1X))\" , 'momentum  => 1      * 2 = ' , conservative3 % momentum print \"(A,F6.3)\" , 'energy    => 1      * 2 = ' , conservative3 % energy call print_error ( test = 'conservative3 = conservative1 * 2' , is_test_passed = test_passed ( 5 )) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) contains subroutine print_error ( test , is_test_passed ) !< Print error message if test is failed. character ( * ), intent ( in ) :: test !< Test description. logical , intent ( in ) :: is_test_passed !< Test result. if (. not . is_test_passed ) then print * , '\"' // test // '\" failed!' print * , 'conservative1:' print \"(A,F6.3)\" , '  density  = ' , conservative1 % density print \"(A,3(F6.3,1X))\" , '  momentum = ' , conservative1 % momentum print \"(A,F6.3)\" , '  energy   = ' , conservative1 % energy print * , 'conservative2:' print \"(A,F6.3)\" , '  density  = ' , conservative2 % density print \"(A,3(F6.3,1X))\" , '  momentum = ' , conservative2 % momentum print \"(A,F6.3)\" , '  energy   = ' , conservative2 % energy print * , 'conservative3:' print \"(A,F6.3)\" , '  density  = ' , conservative3 % density print \"(A,3(F6.3,1X))\" , '  momentum = ' , conservative3 % momentum print \"(A,F6.3)\" , '  energy   = ' , conservative3 % energy endif endsubroutine print_error endprogram flow_test_conservative_compressible_mul","tags":"","loc":"sourcefile/flow_test_conservative_compressible_mul.f90.html","title":"flow_test_conservative_compressible_mul.f90 – FLOw"},{"text":"FLOw test. This File Depends On sourcefile~~flow_test_conservative_compressible_not_eq.f90~~EfferentGraph sourcefile~flow_test_conservative_compressible_not_eq.f90 flow_test_conservative_compressible_not_eq.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~flow_test_conservative_compressible_not_eq.f90 sourcefile~flow_eos_compressible.f90 flow_eos_compressible.f90 sourcefile~penf.f90->sourcefile~flow_eos_compressible.f90 sourcefile~flow_field_scalar_vectorial.f90 flow_field_scalar_vectorial.f90 sourcefile~penf.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~flow_primitive_object.f90 flow_primitive_object.f90 sourcefile~penf.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_conservative_compressible.f90 flow_conservative_compressible.f90 sourcefile~penf.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_primitive_compressible.f90 flow_primitive_compressible.f90 sourcefile~penf.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_conservative_object.f90 flow_conservative_object.f90 sourcefile~penf.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_primitive_compressible_multispecie.f90 flow_primitive_compressible_multispecie.f90 sourcefile~penf.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_eos_object.f90 flow_eos_object.f90 sourcefile~penf.f90->sourcefile~flow_eos_object.f90 sourcefile~flow_field_object.f90 flow_field_object.f90 sourcefile~penf.f90->sourcefile~flow_field_object.f90 sourcefile~flow_compressible_transformations.f90 flow_compressible_transformations.f90 sourcefile~penf.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow.f90 flow.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_not_eq.f90 sourcefile~vecfor.f90 vecfor.F90 sourcefile~vecfor.f90->sourcefile~flow_test_conservative_compressible_not_eq.f90 sourcefile~vecfor.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_object.f90 sourcefile~vecfor.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~vecfor.f90->sourcefile~flow_conservative_object.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~vecfor.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~flow_eos_compressible.f90->sourcefile~flow.f90 sourcefile~flow_field_scalar_vectorial.f90->sourcefile~flow.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_conservative_compressible.f90->sourcefile~flow.f90 sourcefile~flow_conservative_compressible.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_primitive_compressible.f90->sourcefile~flow.f90 sourcefile~flow_primitive_compressible.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_conservative_object.f90->sourcefile~flow.f90 sourcefile~flow_conservative_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_primitive_compressible_multispecie.f90->sourcefile~flow.f90 sourcefile~flow_eos_object.f90->sourcefile~flow.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_eos_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_field_object.f90->sourcefile~flow.f90 sourcefile~flow_field_object.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_field_object.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_compressible_transformations.f90->sourcefile~flow.f90 var pansourcefileflow_test_conservative_compressible_not_eqf90EfferentGraph = svgPanZoom('#sourcefileflow_test_conservative_compressible_not_eqf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs flow_test_conservative_compressible_not_eq Source Code flow_test_conservative_compressible_not_eq.f90 Source Code !< FLOw test. program flow_test_conservative_compressible_not_eq !< FLOw test. use flow , only : conservative_compressible use penf , only : R8P use vecfor , only : vector implicit none type ( conservative_compressible ) :: conservative1 !< A conservative object. type ( conservative_compressible ) :: conservative2 !< A conservative object. type ( vector ) :: momentum !< A vector object. logical :: test_passed ( 5 ) !< List of passed tests. test_passed = . false . momentum = 1._R8P conservative1 = conservative_compressible ( density = 0.125_R8P , momentum = momentum , energy = 1._R8P ) momentum = 1._R8P conservative2 = conservative_compressible ( density = 1._R8P , momentum = momentum , energy = 1._R8P ) test_passed ( 1 ) = ( conservative1 /= conservative2 ). eqv .(. true .) print \"(A,L1)\" , 'density  => 0.125 /= 1 = ' , test_passed ( 1 ) momentum = 1._R8P conservative1 = conservative_compressible ( density = 0.125_R8P , momentum = momentum , energy = 1._R8P ) momentum = 2._R8P conservative2 = conservative_compressible ( density = 0.125_R8P , momentum = momentum , energy = 1._R8P ) test_passed ( 2 ) = ( conservative1 /= conservative2 ). eqv .(. true .) print \"(A,L1)\" , 'momentum => 1     /= 2 = ' , test_passed ( 2 ) momentum = 1._R8P conservative1 = conservative_compressible ( density = 0.125_R8P , momentum = momentum , energy = 1._R8P ) momentum = 2._R8P conservative2 = conservative_compressible ( density = 0.125_R8P , momentum = momentum , energy = 2._R8P ) test_passed ( 3 ) = ( conservative1 /= conservative2 ). eqv .(. true .) print \"(A,L1)\" , 'energy   => 1     /= 2 = ' , test_passed ( 3 ) momentum = 1._R8P conservative1 = conservative_compressible ( density = 0.125_R8P , momentum = momentum , energy = 1._R8P ) momentum = 2._R8P conservative2 = conservative_compressible ( density = 1._R8P , momentum = momentum , energy = 2._R8P ) test_passed ( 4 ) = ( conservative1 /= conservative2 ). eqv .(. true .) print \"(A)\" , new_line ( 'a' ) // 'all together' print \"(A,L1)\" , 'density  => 0.125 /= 1 = ' , test_passed ( 4 ) print \"(A,L1)\" , 'momentum => 1     /= 2 = ' , test_passed ( 4 ) print \"(A,L1)\" , 'energy   => 1     /= 2 = ' , test_passed ( 4 ) momentum = 1._R8P conservative1 = conservative_compressible ( density = 1._R8P , momentum = momentum , energy = 1._R8P ) momentum = 1._R8P conservative2 = conservative_compressible ( density = 1._R8P , momentum = momentum , energy = 1._R8P ) test_passed ( 5 ) = ( conservative1 /= conservative2 ). eqv .(. false .) print \"(A)\" , new_line ( 'a' ) // 'all together' print \"(A,L1)\" , 'density  => 0.125 /= 1 = ' , test_passed ( 5 ) print \"(A,L1)\" , 'momentum => 1     /= 2 = ' , test_passed ( 5 ) print \"(A,L1)\" , 'energy   => 1     /= 2 = ' , test_passed ( 5 ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram flow_test_conservative_compressible_not_eq","tags":"","loc":"sourcefile/flow_test_conservative_compressible_not_eq.f90.html","title":"flow_test_conservative_compressible_not_eq.f90 – FLOw"},{"text":"FLOw test. This File Depends On sourcefile~~flow_test_conservative_compressible_pow.f90~~EfferentGraph sourcefile~flow_test_conservative_compressible_pow.f90 flow_test_conservative_compressible_pow.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~flow_test_conservative_compressible_pow.f90 sourcefile~flow_eos_compressible.f90 flow_eos_compressible.f90 sourcefile~penf.f90->sourcefile~flow_eos_compressible.f90 sourcefile~flow_field_scalar_vectorial.f90 flow_field_scalar_vectorial.f90 sourcefile~penf.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~flow_primitive_object.f90 flow_primitive_object.f90 sourcefile~penf.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_conservative_compressible.f90 flow_conservative_compressible.f90 sourcefile~penf.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_primitive_compressible.f90 flow_primitive_compressible.f90 sourcefile~penf.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_conservative_object.f90 flow_conservative_object.f90 sourcefile~penf.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_primitive_compressible_multispecie.f90 flow_primitive_compressible_multispecie.f90 sourcefile~penf.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_eos_object.f90 flow_eos_object.f90 sourcefile~penf.f90->sourcefile~flow_eos_object.f90 sourcefile~flow_field_object.f90 flow_field_object.f90 sourcefile~penf.f90->sourcefile~flow_field_object.f90 sourcefile~flow_compressible_transformations.f90 flow_compressible_transformations.f90 sourcefile~penf.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow.f90 flow.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_pow.f90 sourcefile~vecfor.f90 vecfor.F90 sourcefile~vecfor.f90->sourcefile~flow_test_conservative_compressible_pow.f90 sourcefile~vecfor.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_object.f90 sourcefile~vecfor.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~vecfor.f90->sourcefile~flow_conservative_object.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~vecfor.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~flow_eos_compressible.f90->sourcefile~flow.f90 sourcefile~flow_field_scalar_vectorial.f90->sourcefile~flow.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_conservative_compressible.f90->sourcefile~flow.f90 sourcefile~flow_conservative_compressible.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_primitive_compressible.f90->sourcefile~flow.f90 sourcefile~flow_primitive_compressible.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_conservative_object.f90->sourcefile~flow.f90 sourcefile~flow_conservative_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_primitive_compressible_multispecie.f90->sourcefile~flow.f90 sourcefile~flow_eos_object.f90->sourcefile~flow.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_eos_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_field_object.f90->sourcefile~flow.f90 sourcefile~flow_field_object.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_field_object.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_compressible_transformations.f90->sourcefile~flow.f90 var pansourcefileflow_test_conservative_compressible_powf90EfferentGraph = svgPanZoom('#sourcefileflow_test_conservative_compressible_powf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs flow_test_conservative_compressible_add Source Code flow_test_conservative_compressible_pow.f90 Source Code !< FLOw test. program flow_test_conservative_compressible_add !< FLOw test. use flow , only : conservative_compressible use penf , only : I4P , R8P use vecfor , only : vector implicit none type ( conservative_compressible ) :: conservative1 !< A conservative object. type ( conservative_compressible ) :: conservative2 !< A conservative object. type ( vector ) :: momentum !< A vector object. logical :: test_passed ( 2 ) !< List of passed tests. test_passed = . false . momentum = 0.5_R8P conservative1 = conservative_compressible ( density = 0.125_R8P , momentum = momentum , energy = 1._R8P ) conservative2 = conservative1 ** 2_I4P print \"(A,F6.3)\" , 'density  => 0.125 ** 2 = ' , conservative2 % density print \"(A,3(F6.3,1X))\" , 'momentum => 0.5   ** 2 = ' , conservative2 % momentum print \"(A,F6.3)\" , 'energy   => 1     ** 2 = ' , conservative2 % energy test_passed ( 1 ) = conservative2 % density == ( 0.125_R8P ** 2_I4P ) momentum = 0.5_R8P conservative1 = conservative_compressible ( density = 0.125_R8P , momentum = momentum , energy = 1._R8P ) conservative2 = conservative1 ** 2._R8P print \"(A,F6.3)\" , 'density  => 0.125 ** 2.0 = ' , conservative2 % density print \"(A,3(F6.3,1X))\" , 'momentum => 0.5   ** 2.0 = ' , conservative2 % momentum print \"(A,F6.3)\" , 'energy   => 1     ** 2.0 = ' , conservative2 % energy test_passed ( 2 ) = conservative2 % density == ( 0.125_R8P ** 2._R8P ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram flow_test_conservative_compressible_add","tags":"","loc":"sourcefile/flow_test_conservative_compressible_pow.f90.html","title":"flow_test_conservative_compressible_pow.f90 – FLOw"},{"text":"FLOw test. This File Depends On sourcefile~~flow_test_conservative_compressible_sub.f90~~EfferentGraph sourcefile~flow_test_conservative_compressible_sub.f90 flow_test_conservative_compressible_sub.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~flow_test_conservative_compressible_sub.f90 sourcefile~flow_eos_compressible.f90 flow_eos_compressible.f90 sourcefile~penf.f90->sourcefile~flow_eos_compressible.f90 sourcefile~flow_field_scalar_vectorial.f90 flow_field_scalar_vectorial.f90 sourcefile~penf.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~flow_primitive_object.f90 flow_primitive_object.f90 sourcefile~penf.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_conservative_compressible.f90 flow_conservative_compressible.f90 sourcefile~penf.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_primitive_compressible.f90 flow_primitive_compressible.f90 sourcefile~penf.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_conservative_object.f90 flow_conservative_object.f90 sourcefile~penf.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_primitive_compressible_multispecie.f90 flow_primitive_compressible_multispecie.f90 sourcefile~penf.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_eos_object.f90 flow_eos_object.f90 sourcefile~penf.f90->sourcefile~flow_eos_object.f90 sourcefile~flow_field_object.f90 flow_field_object.f90 sourcefile~penf.f90->sourcefile~flow_field_object.f90 sourcefile~flow_compressible_transformations.f90 flow_compressible_transformations.f90 sourcefile~penf.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow.f90 flow.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_sub.f90 sourcefile~vecfor.f90 vecfor.F90 sourcefile~vecfor.f90->sourcefile~flow_test_conservative_compressible_sub.f90 sourcefile~vecfor.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_object.f90 sourcefile~vecfor.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~vecfor.f90->sourcefile~flow_conservative_object.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~vecfor.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~flow_eos_compressible.f90->sourcefile~flow.f90 sourcefile~flow_field_scalar_vectorial.f90->sourcefile~flow.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_conservative_compressible.f90->sourcefile~flow.f90 sourcefile~flow_conservative_compressible.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_primitive_compressible.f90->sourcefile~flow.f90 sourcefile~flow_primitive_compressible.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_conservative_object.f90->sourcefile~flow.f90 sourcefile~flow_conservative_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_primitive_compressible_multispecie.f90->sourcefile~flow.f90 sourcefile~flow_eos_object.f90->sourcefile~flow.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_eos_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_field_object.f90->sourcefile~flow.f90 sourcefile~flow_field_object.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_field_object.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_compressible_transformations.f90->sourcefile~flow.f90 var pansourcefileflow_test_conservative_compressible_subf90EfferentGraph = svgPanZoom('#sourcefileflow_test_conservative_compressible_subf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs flow_test_conservative_compressible_sub Source Code flow_test_conservative_compressible_sub.f90 Source Code !< FLOw test. program flow_test_conservative_compressible_sub !< FLOw test. use flow , only : conservative_compressible use penf , only : R8P use vecfor , only : vector implicit none type ( conservative_compressible ) :: conservative1 !< A conservative object. type ( conservative_compressible ) :: conservative2 !< A conservative object. type ( conservative_compressible ) :: conservative3 !< A conservative object. type ( vector ) :: momentum !< A vector object. logical :: test_passed ( 2 ) !< List of passed tests. test_passed = . false . momentum = 1._R8P conservative1 = conservative_compressible ( density = 0.125_R8P , momentum = momentum , energy = 1._R8P ) momentum = 2._R8P conservative2 = conservative_compressible ( density = 1._R8P , momentum = momentum , energy = 1._R8P ) conservative3 = conservative1 - conservative2 test_passed ( 1 ) = conservative3 == ( conservative1 - conservative2 ) print \"(A,F6.3)\" , 'density   => 0.125  - 1   = ' , conservative3 % density print \"(A,3(F6.3,1X))\" , 'momentum  => 1      - 2   = ' , conservative3 % momentum print \"(A,F6.3)\" , 'energy    => 1      - 1   = ' , conservative3 % energy momentum = - 1._R8P conservative1 = conservative_compressible ( density = 0.125_R8P , momentum = momentum , energy = 1._R8P ) conservative2 = - conservative1 test_passed ( 2 ) = conservative2 == - conservative1 print \"(A,F6.3)\" , 'density   => - (0.125) = ' , conservative2 % density print \"(A,3(F6.3,1X))\" , 'momentum  => - (-1)    = ' , conservative2 % momentum print \"(A,F6.3)\" , 'energy    => - (1)     = ' , conservative2 % energy print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram flow_test_conservative_compressible_sub","tags":"","loc":"sourcefile/flow_test_conservative_compressible_sub.f90.html","title":"flow_test_conservative_compressible_sub.f90 – FLOw"},{"text":"Flow test. This File Depends On sourcefile~~flow_test_eos_compressible.f90~~EfferentGraph sourcefile~flow_test_eos_compressible.f90 flow_test_eos_compressible.f90 sourcefile~flow.f90 flow.f90 sourcefile~flow.f90->sourcefile~flow_test_eos_compressible.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~flow_test_eos_compressible.f90 sourcefile~flow_eos_compressible.f90 flow_eos_compressible.f90 sourcefile~penf.f90->sourcefile~flow_eos_compressible.f90 sourcefile~flow_field_scalar_vectorial.f90 flow_field_scalar_vectorial.f90 sourcefile~penf.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~flow_primitive_object.f90 flow_primitive_object.f90 sourcefile~penf.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_conservative_compressible.f90 flow_conservative_compressible.f90 sourcefile~penf.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_primitive_compressible.f90 flow_primitive_compressible.f90 sourcefile~penf.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_conservative_object.f90 flow_conservative_object.f90 sourcefile~penf.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_primitive_compressible_multispecie.f90 flow_primitive_compressible_multispecie.f90 sourcefile~penf.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_eos_object.f90 flow_eos_object.f90 sourcefile~penf.f90->sourcefile~flow_eos_object.f90 sourcefile~flow_field_object.f90 flow_field_object.f90 sourcefile~penf.f90->sourcefile~flow_field_object.f90 sourcefile~flow_compressible_transformations.f90 flow_compressible_transformations.f90 sourcefile~penf.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_eos_compressible.f90->sourcefile~flow.f90 sourcefile~flow_field_scalar_vectorial.f90->sourcefile~flow.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_conservative_compressible.f90->sourcefile~flow.f90 sourcefile~flow_conservative_compressible.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_primitive_compressible.f90->sourcefile~flow.f90 sourcefile~flow_primitive_compressible.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_conservative_object.f90->sourcefile~flow.f90 sourcefile~flow_conservative_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_primitive_compressible_multispecie.f90->sourcefile~flow.f90 sourcefile~flow_eos_object.f90->sourcefile~flow.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_eos_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_field_object.f90->sourcefile~flow.f90 sourcefile~flow_field_object.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_field_object.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_compressible_transformations.f90->sourcefile~flow.f90 sourcefile~vecfor.f90 vecfor.F90 sourcefile~vecfor.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_object.f90 sourcefile~vecfor.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~vecfor.f90->sourcefile~flow_conservative_object.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~vecfor.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 var pansourcefileflow_test_eos_compressiblef90EfferentGraph = svgPanZoom('#sourcefileflow_test_eos_compressiblef90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs flow_test_eos_compressible Source Code flow_test_eos_compressible.f90 Source Code !< Flow test. program flow_test_eos_compressible !< Flow test. use flow , only : eos_compressible use penf , only : R8P , ZeroR8 implicit none type ( eos_compressible ) :: eos !< An equation of state. logical :: are_tests_passed ( 13 ) !< List of passed tests. are_tests_passed = . false . eos = eos_compressible ( cp = 104 0.004_R8P , cv = 74 2.86_R8P ) print \"(A)\" , 'EOS description:' print \"(A)\" , eos % description () are_tests_passed ( 1 ) = ( eos % g () >= 1.4_R8P - ZeroR8 ). and .( eos % g () <= 1.4_R8P + ZeroR8 ) print \"(A,L1)\" , 'eos%g() = 1.4, is right? ' , are_tests_passed ( 1 ) eos = eos_compressible ( cp = 104 0.004_R8P , gam = 1.4_R8P ) are_tests_passed ( 2 ) = ( eos % cv () >= 74 2.86_R8P - ZeroR8 ). and .( eos % cv () <= 74 2.86_R8P + ZeroR8 ) print \"(A,L1)\" , 'eos%cv() = 742.86, is right? ' , are_tests_passed ( 2 ) eos = eos_compressible ( cv = 74 2.86_R8P , gam = 1.4_R8P ) are_tests_passed ( 3 ) = ( eos % R () >= 29 7.144_R8P - 1000 * ZeroR8 ). and .( eos % R () <= 29 7.144_R8P + 1000 * ZeroR8 ) print \"(A,L1)\" , 'eos%R() = 297.144, is right? ' , are_tests_passed ( 3 ) eos = eos_compressible ( cv = 74 2.86_R8P , R = 29 7.144_R8P ) are_tests_passed ( 4 ) = ( eos % cp () >= 104 0.004_R8P - ZeroR8 ). and .( eos % cp () <= 104 0.004_R8P + ZeroR8 ) print \"(A,L1)\" , 'eos%cp() = 1040.004, is right? ' , are_tests_passed ( 4 ) eos = eos_compressible ( cp = 104 0.004_R8P , R = 29 7.144_R8P ) are_tests_passed ( 5 ) = ( eos % cv () >= 74 2.86_R8P - 1000 * ZeroR8 ). and .( eos % cv () <= 74 2.86_R8P + 1000 * ZeroR8 ) print \"(A,L1)\" , 'eos%cv() = 742.86, is right? ' , are_tests_passed ( 5 ) eos = eos_compressible ( gam = 1.4_R8P , R = 29 7.144_R8P ) are_tests_passed ( 6 ) = ( eos % cp () >= 104 0.004_R8P - 1000 * ZeroR8 ). and .( eos % cp () <= 104 0.004_R8P + 1000 * ZeroR8 ) print \"(A,L1)\" , 'eos%cp() = 1040.004, is right? ' , are_tests_passed ( 6 ) eos = eos_compressible ( cp = 104 0.004_R8P , cv = 74 2.86_R8P ) are_tests_passed ( 7 ) = ( eos % pressure ( density = 1._R8P , energy = 1._R8P ) >= 0.4_R8P - ZeroR8 ). and .& ( eos % pressure ( density = 1._R8P , energy = 1._R8P ) <= 0.4_R8P + ZeroR8 ) print \"(A,L1)\" , 'eos%pressure(density=1, energy=1) = 0.4, is right? ' , are_tests_passed ( 7 ) are_tests_passed ( 8 ) = ( eos % pressure ( density = 1._R8P , temperature = 1._R8P ) >= 29 7.144_R8P - 1000 * ZeroR8 ). and .& ( eos % pressure ( density = 1._R8P , temperature = 1._R8P ) <= 29 7.144_R8P + 1000 * ZeroR8 ) print \"(A,L1)\" , 'eos%pressure(density=1, temperature=1) = 297.144, is right? ' , are_tests_passed ( 8 ) are_tests_passed ( 9 ) = ( eos % density ( pressure = 1._R8P , speed_of_sound = 1._R8P ) >= 1.4_R8P - ZeroR8 ). and .& ( eos % density ( pressure = 1._R8P , speed_of_sound = 1._R8P ) <= 1.4_R8P + ZeroR8 ) print \"(A,L1)\" , 'eos%density(pressure=1, speed_of_sound=1) = 1.4, is right? ' , are_tests_passed ( 9 ) are_tests_passed ( 10 ) = ( eos % internal_energy ( density = 1._R8P , pressure = 1._R8P ) >= 1._R8P / 0.4_R8P - ZeroR8 ). and .& ( eos % internal_energy ( density = 1._R8P , pressure = 1._R8P ) <= 1._R8P / 0.4_R8P + ZeroR8 ) print \"(A,L1)\" , 'eos%internal_energy(density=1, pressure=1) = 1/0.4, is right? ' , are_tests_passed ( 10 ) are_tests_passed ( 11 ) = ( eos % temperature ( density = 1._R8P , pressure = 1._R8P ) >= 1._R8P / 29 7.144_R8P - ZeroR8 ). and .& ( eos % temperature ( density = 1._R8P , pressure = 1._R8P ) <= 1._R8P / 29 7.144_R8P + ZeroR8 ) print \"(A,L1)\" , 'eos%temperature(density=1, pressure=1) = 1/297.144, is right? ' , are_tests_passed ( 11 ) are_tests_passed ( 12 ) = ( eos % temperature ( energy = 1._R8P ) >= 1._R8P / 74 2.86_R8P - ZeroR8 ). and .& ( eos % temperature ( energy = 1._R8P ) <= 1._R8P / 74 2.86_R8P + ZeroR8 ) print \"(A,L1)\" , 'eos%temperature(energy=1) = 1/742.86, is right? ' , are_tests_passed ( 12 ) are_tests_passed ( 13 ) = ( eos % total_entalpy ( pressure = 1._R8P , & density = 1._R8P , & velocity_sq_norm = 2._R8P ) >= 4.5_R8P - ZeroR8 ). and .& ( eos % total_entalpy ( pressure = 1._R8P , & density = 1._R8P , & velocity_sq_norm = 2._R8P ) <= 4.5_R8P + ZeroR8 ) print \"(A,L1)\" , 'eos%total_entalpy(pressure=1, density=1, velocity_sq_norm=2) = 4.5, is right? ' , are_tests_passed ( 13 ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( are_tests_passed ) endprogram flow_test_eos_compressible","tags":"","loc":"sourcefile/flow_test_eos_compressible.f90.html","title":"flow_test_eos_compressible.f90 – FLOw"},{"text":"FLOw test. This File Depends On sourcefile~~flow_test_primitive_compressible_add.f90~~EfferentGraph sourcefile~flow_test_primitive_compressible_add.f90 flow_test_primitive_compressible_add.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_add.f90 sourcefile~flow_eos_compressible.f90 flow_eos_compressible.f90 sourcefile~penf.f90->sourcefile~flow_eos_compressible.f90 sourcefile~flow_field_scalar_vectorial.f90 flow_field_scalar_vectorial.f90 sourcefile~penf.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~flow_primitive_object.f90 flow_primitive_object.f90 sourcefile~penf.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_conservative_compressible.f90 flow_conservative_compressible.f90 sourcefile~penf.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_primitive_compressible.f90 flow_primitive_compressible.f90 sourcefile~penf.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_conservative_object.f90 flow_conservative_object.f90 sourcefile~penf.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_primitive_compressible_multispecie.f90 flow_primitive_compressible_multispecie.f90 sourcefile~penf.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_eos_object.f90 flow_eos_object.f90 sourcefile~penf.f90->sourcefile~flow_eos_object.f90 sourcefile~flow_field_object.f90 flow_field_object.f90 sourcefile~penf.f90->sourcefile~flow_field_object.f90 sourcefile~flow_compressible_transformations.f90 flow_compressible_transformations.f90 sourcefile~penf.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow.f90 flow.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_add.f90 sourcefile~vecfor.f90 vecfor.F90 sourcefile~vecfor.f90->sourcefile~flow_test_primitive_compressible_add.f90 sourcefile~vecfor.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_object.f90 sourcefile~vecfor.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~vecfor.f90->sourcefile~flow_conservative_object.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~vecfor.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~flow_eos_compressible.f90->sourcefile~flow.f90 sourcefile~flow_field_scalar_vectorial.f90->sourcefile~flow.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_conservative_compressible.f90->sourcefile~flow.f90 sourcefile~flow_conservative_compressible.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_primitive_compressible.f90->sourcefile~flow.f90 sourcefile~flow_primitive_compressible.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_conservative_object.f90->sourcefile~flow.f90 sourcefile~flow_conservative_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_primitive_compressible_multispecie.f90->sourcefile~flow.f90 sourcefile~flow_eos_object.f90->sourcefile~flow.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_eos_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_field_object.f90->sourcefile~flow.f90 sourcefile~flow_field_object.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_field_object.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_compressible_transformations.f90->sourcefile~flow.f90 var pansourcefileflow_test_primitive_compressible_addf90EfferentGraph = svgPanZoom('#sourcefileflow_test_primitive_compressible_addf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs flow_test_primitive_compressible_add Source Code flow_test_primitive_compressible_add.f90 Source Code !< FLOw test. program flow_test_primitive_compressible_add !< FLOw test. use flow , only : primitive_compressible use penf , only : R8P use vecfor , only : vector implicit none type ( primitive_compressible ) :: primitive1 !< A primitive object. type ( primitive_compressible ) :: primitive2 !< A primitive object. type ( primitive_compressible ) :: primitive3 !< A primitive object. type ( vector ) :: velocity !< A vector object. logical :: test_passed ( 2 ) !< List of passed tests. test_passed = . false . velocity = 1._R8P primitive1 = primitive_compressible ( density = 0.125_R8P , velocity = velocity , pressure = 1._R8P ) velocity = 2._R8P primitive2 = primitive_compressible ( density = 1._R8P , velocity = velocity , pressure = 1._R8P ) primitive3 = primitive1 + primitive2 test_passed ( 1 ) = primitive3 == ( primitive1 + primitive2 ) print \"(A,F6.3)\" , 'density   => 0.125  + 1   = ' , primitive3 % density print \"(A,3(F6.3,1X))\" , 'velocity  => 1      + 2   = ' , primitive3 % velocity print \"(A,F6.3)\" , 'pressure  => 1      + 1   = ' , primitive3 % pressure velocity = - 1._R8P primitive1 = primitive_compressible ( density = 0.125_R8P , velocity = velocity , pressure = 1._R8P ) primitive2 = + primitive1 test_passed ( 2 ) = primitive2 == primitive1 print \"(A,F6.3)\" , 'density   => + (0.125) = ' , primitive2 % density print \"(A,3(F6.3,1X))\" , 'velocity  => + (-1)    = ' , primitive2 % velocity print \"(A,F6.3)\" , 'pressure  => + (1)     = ' , primitive2 % pressure print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram flow_test_primitive_compressible_add","tags":"","loc":"sourcefile/flow_test_primitive_compressible_add.f90.html","title":"flow_test_primitive_compressible_add.f90 – FLOw"},{"text":"FLOw test. This File Depends On sourcefile~~flow_test_primitive_compressible_assign.f90~~EfferentGraph sourcefile~flow_test_primitive_compressible_assign.f90 flow_test_primitive_compressible_assign.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_assign.f90 sourcefile~flow_eos_compressible.f90 flow_eos_compressible.f90 sourcefile~penf.f90->sourcefile~flow_eos_compressible.f90 sourcefile~flow_field_scalar_vectorial.f90 flow_field_scalar_vectorial.f90 sourcefile~penf.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~flow_primitive_object.f90 flow_primitive_object.f90 sourcefile~penf.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_conservative_compressible.f90 flow_conservative_compressible.f90 sourcefile~penf.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_primitive_compressible.f90 flow_primitive_compressible.f90 sourcefile~penf.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_conservative_object.f90 flow_conservative_object.f90 sourcefile~penf.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_primitive_compressible_multispecie.f90 flow_primitive_compressible_multispecie.f90 sourcefile~penf.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_eos_object.f90 flow_eos_object.f90 sourcefile~penf.f90->sourcefile~flow_eos_object.f90 sourcefile~flow_field_object.f90 flow_field_object.f90 sourcefile~penf.f90->sourcefile~flow_field_object.f90 sourcefile~flow_compressible_transformations.f90 flow_compressible_transformations.f90 sourcefile~penf.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow.f90 flow.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_assign.f90 sourcefile~vecfor.f90 vecfor.F90 sourcefile~vecfor.f90->sourcefile~flow_test_primitive_compressible_assign.f90 sourcefile~vecfor.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_object.f90 sourcefile~vecfor.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~vecfor.f90->sourcefile~flow_conservative_object.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~vecfor.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~flow_eos_compressible.f90->sourcefile~flow.f90 sourcefile~flow_field_scalar_vectorial.f90->sourcefile~flow.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_conservative_compressible.f90->sourcefile~flow.f90 sourcefile~flow_conservative_compressible.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_primitive_compressible.f90->sourcefile~flow.f90 sourcefile~flow_primitive_compressible.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_conservative_object.f90->sourcefile~flow.f90 sourcefile~flow_conservative_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_primitive_compressible_multispecie.f90->sourcefile~flow.f90 sourcefile~flow_eos_object.f90->sourcefile~flow.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_eos_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_field_object.f90->sourcefile~flow.f90 sourcefile~flow_field_object.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_field_object.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_compressible_transformations.f90->sourcefile~flow.f90 var pansourcefileflow_test_primitive_compressible_assignf90EfferentGraph = svgPanZoom('#sourcefileflow_test_primitive_compressible_assignf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs flow_test_primitive_compressible_assign Source Code flow_test_primitive_compressible_assign.f90 Source Code !< FLOw test. program flow_test_primitive_compressible_assign !< FLOw test. use flow , only : primitive_compressible use penf , only : R8P use vecfor , only : vector implicit none type ( primitive_compressible ) :: primitive1 !< A primitive object. type ( primitive_compressible ) :: primitive2 !< A primitive object. type ( vector ) :: velocity !< A vector object. logical :: test_passed ( 2 ) !< List of passed tests. test_passed = . false . primitive1 = 0.125_R8P test_passed ( 1 ) = ( primitive1 % density == 0.125_R8P ). and . & ( primitive1 % velocity % x == 0.125_R8P ). and . & ( primitive1 % velocity % y == 0.125_R8P ). and . & ( primitive1 % velocity % z == 0.125_R8P ). and . & ( primitive1 % pressure == 0.125_R8P ) print \"(A,F6.3)\" , 'density   = ' , primitive1 % density print \"(A,3(F6.3,1X))\" , 'velocity  = ' , primitive1 % velocity print \"(A,F6.3)\" , 'pressure  = ' , primitive1 % pressure velocity = 1._R8P primitive1 = primitive_compressible ( density = 0.125_R8P , velocity = velocity , pressure = 2._R8P ) primitive2 = primitive1 test_passed ( 2 ) = primitive1 == primitive2 print \"(A)\" , '' print \"(A,F6.3)\" , 'density   = ' , primitive2 % density print \"(A,3(F6.3,1X))\" , 'velocity  = ' , primitive2 % velocity print \"(A,F6.3)\" , 'pressure  = ' , primitive2 % pressure print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram flow_test_primitive_compressible_assign","tags":"","loc":"sourcefile/flow_test_primitive_compressible_assign.f90.html","title":"flow_test_primitive_compressible_assign.f90 – FLOw"},{"text":"FLOw test. This File Depends On sourcefile~~flow_test_primitive_compressible_div.f90~~EfferentGraph sourcefile~flow_test_primitive_compressible_div.f90 flow_test_primitive_compressible_div.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_div.f90 sourcefile~flow_eos_compressible.f90 flow_eos_compressible.f90 sourcefile~penf.f90->sourcefile~flow_eos_compressible.f90 sourcefile~flow_field_scalar_vectorial.f90 flow_field_scalar_vectorial.f90 sourcefile~penf.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~flow_primitive_object.f90 flow_primitive_object.f90 sourcefile~penf.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_conservative_compressible.f90 flow_conservative_compressible.f90 sourcefile~penf.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_primitive_compressible.f90 flow_primitive_compressible.f90 sourcefile~penf.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_conservative_object.f90 flow_conservative_object.f90 sourcefile~penf.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_primitive_compressible_multispecie.f90 flow_primitive_compressible_multispecie.f90 sourcefile~penf.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_eos_object.f90 flow_eos_object.f90 sourcefile~penf.f90->sourcefile~flow_eos_object.f90 sourcefile~flow_field_object.f90 flow_field_object.f90 sourcefile~penf.f90->sourcefile~flow_field_object.f90 sourcefile~flow_compressible_transformations.f90 flow_compressible_transformations.f90 sourcefile~penf.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow.f90 flow.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_div.f90 sourcefile~vecfor.f90 vecfor.F90 sourcefile~vecfor.f90->sourcefile~flow_test_primitive_compressible_div.f90 sourcefile~vecfor.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_object.f90 sourcefile~vecfor.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~vecfor.f90->sourcefile~flow_conservative_object.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~vecfor.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~flow_eos_compressible.f90->sourcefile~flow.f90 sourcefile~flow_field_scalar_vectorial.f90->sourcefile~flow.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_conservative_compressible.f90->sourcefile~flow.f90 sourcefile~flow_conservative_compressible.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_primitive_compressible.f90->sourcefile~flow.f90 sourcefile~flow_primitive_compressible.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_conservative_object.f90->sourcefile~flow.f90 sourcefile~flow_conservative_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_primitive_compressible_multispecie.f90->sourcefile~flow.f90 sourcefile~flow_eos_object.f90->sourcefile~flow.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_eos_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_field_object.f90->sourcefile~flow.f90 sourcefile~flow_field_object.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_field_object.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_compressible_transformations.f90->sourcefile~flow.f90 var pansourcefileflow_test_primitive_compressible_divf90EfferentGraph = svgPanZoom('#sourcefileflow_test_primitive_compressible_divf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs flow_test_primitive_compressible_div Source Code flow_test_primitive_compressible_div.f90 Source Code !< FLOw test. program flow_test_primitive_compressible_div !< FLOw test. use flow , only : primitive_compressible use penf , only : I4P , R8P use vecfor , only : vector implicit none type ( primitive_compressible ) :: primitive1 !< A primitive object. type ( primitive_compressible ) :: primitive2 !< A primitive object. type ( primitive_compressible ) :: primitive3 !< A primitive object. type ( vector ) :: velocity !< A vector object. logical :: test_passed ( 3 ) !< List of passed tests. test_passed = . false . velocity = 1._R8P primitive1 = primitive_compressible ( density = 0.125_R8P , velocity = velocity , pressure = 1._R8P ) velocity = 2._R8P primitive2 = primitive_compressible ( density = 1._R8P , velocity = velocity , pressure = 1._R8P ) primitive3 = primitive1 / primitive2 test_passed ( 1 ) = primitive3 == ( primitive1 / primitive2 ) print \"(A,F6.3)\" , 'density   => 0.125  / 1   = ' , primitive3 % density print \"(A,3(F6.3,1X))\" , 'velocity  => 1      / 2   = ' , primitive3 % velocity print \"(A,F6.3)\" , 'pressure  => 1      / 1   = ' , primitive3 % pressure call print_error ( test = 'primitive3 = primitive1 / primitive2' , is_test_passed = test_passed ( 1 )) primitive3 = primitive1 / 2._R8P test_passed ( 2 ) = primitive3 == ( primitive1 / 2._R8P ) print \"(A)\" , '' print \"(A,F6.3)\" , 'density   => 0.125  / 2.0 = ' , primitive3 % density print \"(A,3(F6.3,1X))\" , 'velocity  => 1      / 2.0 = ' , primitive3 % velocity print \"(A,F6.3)\" , 'pressure  => 1      / 2.0 = ' , primitive3 % pressure call print_error ( test = 'primitive3 = primitive1 / 2.0' , is_test_passed = test_passed ( 2 )) primitive3 = primitive1 / 2_I4P test_passed ( 3 ) = primitive3 == ( primitive1 / 2_I4P ) print \"(A)\" , '' print \"(A,F6.3)\" , 'density   => 0.125  / 2 = ' , primitive3 % density print \"(A,3(F6.3,1X))\" , 'velocity  => 1      / 2 = ' , primitive3 % velocity print \"(A,F6.3)\" , 'pressure  => 1      / 2 = ' , primitive3 % pressure call print_error ( test = 'primitive3 = primitive1 / 2' , is_test_passed = test_passed ( 3 )) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) contains subroutine print_error ( test , is_test_passed ) !< Print error message if test is failed. character ( * ), intent ( in ) :: test !< Test description. logical , intent ( in ) :: is_test_passed !< Test result. if (. not . is_test_passed ) then print * , '\"' // test // '\" failed!' print * , 'primitive1:' print \"(A,F6.3)\" , '  density   = ' , primitive1 % density print \"(A,3(F6.3,1X))\" , '  velocity  = ' , primitive1 % velocity print \"(A,F6.3)\" , '  pressure  = ' , primitive1 % pressure print * , 'primitive2:' print \"(A,F6.3)\" , '  density   = ' , primitive2 % density print \"(A,3(F6.3,1X))\" , '  velocity  = ' , primitive2 % velocity print \"(A,F6.3)\" , '  pressure  = ' , primitive2 % pressure print * , 'primitive3:' print \"(A,F6.3)\" , '  density   = ' , primitive3 % density print \"(A,3(F6.3,1X))\" , '  velocity  = ' , primitive3 % velocity print \"(A,F6.3)\" , '  pressure  = ' , primitive3 % pressure endif endsubroutine print_error endprogram flow_test_primitive_compressible_div","tags":"","loc":"sourcefile/flow_test_primitive_compressible_div.f90.html","title":"flow_test_primitive_compressible_div.f90 – FLOw"},{"text":"FLOw test. This File Depends On sourcefile~~flow_test_primitive_compressible_eq.f90~~EfferentGraph sourcefile~flow_test_primitive_compressible_eq.f90 flow_test_primitive_compressible_eq.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_eq.f90 sourcefile~flow_eos_compressible.f90 flow_eos_compressible.f90 sourcefile~penf.f90->sourcefile~flow_eos_compressible.f90 sourcefile~flow_field_scalar_vectorial.f90 flow_field_scalar_vectorial.f90 sourcefile~penf.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~flow_primitive_object.f90 flow_primitive_object.f90 sourcefile~penf.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_conservative_compressible.f90 flow_conservative_compressible.f90 sourcefile~penf.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_primitive_compressible.f90 flow_primitive_compressible.f90 sourcefile~penf.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_conservative_object.f90 flow_conservative_object.f90 sourcefile~penf.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_primitive_compressible_multispecie.f90 flow_primitive_compressible_multispecie.f90 sourcefile~penf.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_eos_object.f90 flow_eos_object.f90 sourcefile~penf.f90->sourcefile~flow_eos_object.f90 sourcefile~flow_field_object.f90 flow_field_object.f90 sourcefile~penf.f90->sourcefile~flow_field_object.f90 sourcefile~flow_compressible_transformations.f90 flow_compressible_transformations.f90 sourcefile~penf.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow.f90 flow.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_eq.f90 sourcefile~vecfor.f90 vecfor.F90 sourcefile~vecfor.f90->sourcefile~flow_test_primitive_compressible_eq.f90 sourcefile~vecfor.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_object.f90 sourcefile~vecfor.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~vecfor.f90->sourcefile~flow_conservative_object.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~vecfor.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~flow_eos_compressible.f90->sourcefile~flow.f90 sourcefile~flow_field_scalar_vectorial.f90->sourcefile~flow.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_conservative_compressible.f90->sourcefile~flow.f90 sourcefile~flow_conservative_compressible.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_primitive_compressible.f90->sourcefile~flow.f90 sourcefile~flow_primitive_compressible.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_conservative_object.f90->sourcefile~flow.f90 sourcefile~flow_conservative_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_primitive_compressible_multispecie.f90->sourcefile~flow.f90 sourcefile~flow_eos_object.f90->sourcefile~flow.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_eos_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_field_object.f90->sourcefile~flow.f90 sourcefile~flow_field_object.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_field_object.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_compressible_transformations.f90->sourcefile~flow.f90 var pansourcefileflow_test_primitive_compressible_eqf90EfferentGraph = svgPanZoom('#sourcefileflow_test_primitive_compressible_eqf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs flow_test_primitive_compressible_eq Source Code flow_test_primitive_compressible_eq.f90 Source Code !< FLOw test. program flow_test_primitive_compressible_eq !< FLOw test. use flow , only : primitive_compressible use penf , only : R8P use vecfor , only : vector implicit none type ( primitive_compressible ) :: primitive1 !< A primitive object. type ( primitive_compressible ) :: primitive2 !< A primitive object. type ( vector ) :: velocity !< A vector object. logical :: test_passed ( 5 ) !< List of passed tests. test_passed = . false . velocity = 1._R8P primitive1 = primitive_compressible ( density = 0.125_R8P , velocity = velocity , pressure = 1._R8P ) velocity = 1._R8P primitive2 = primitive_compressible ( density = 1._R8P , velocity = velocity , pressure = 1._R8P ) test_passed ( 1 ) = ( primitive1 == primitive2 ). eqv .(. false .) print \"(A,L1)\" , 'density  => 0.125 /= 1 = ' , test_passed ( 1 ) velocity = 1._R8P primitive1 = primitive_compressible ( density = 0.125_R8P , velocity = velocity , pressure = 1._R8P ) velocity = 2._R8P primitive2 = primitive_compressible ( density = 0.125_R8P , velocity = velocity , pressure = 1._R8P ) test_passed ( 2 ) = ( primitive1 == primitive2 ). eqv .(. false .) print \"(A,L1)\" , 'velocity => 1     /= 2 = ' , test_passed ( 2 ) velocity = 1._R8P primitive1 = primitive_compressible ( density = 0.125_R8P , velocity = velocity , pressure = 1._R8P ) velocity = 2._R8P primitive2 = primitive_compressible ( density = 0.125_R8P , velocity = velocity , pressure = 2._R8P ) test_passed ( 3 ) = ( primitive1 == primitive2 ). eqv .(. false .) print \"(A,L1)\" , 'pressure => 1     /= 2 = ' , test_passed ( 3 ) velocity = 1._R8P primitive1 = primitive_compressible ( density = 0.125_R8P , velocity = velocity , pressure = 1._R8P ) velocity = 2._R8P primitive2 = primitive_compressible ( density = 1._R8P , velocity = velocity , pressure = 2._R8P ) test_passed ( 4 ) = ( primitive1 == primitive2 ). eqv .(. false .) print \"(A)\" , new_line ( 'a' ) // 'all together' print \"(A,L1)\" , 'density  => 0.125 /= 1 = ' , test_passed ( 4 ) print \"(A,L1)\" , 'velocity => 1     /= 2 = ' , test_passed ( 4 ) print \"(A,L1)\" , 'pressure => 1     /= 2 = ' , test_passed ( 4 ) velocity = 1._R8P primitive1 = primitive_compressible ( density = 1._R8P , velocity = velocity , pressure = 1._R8P ) velocity = 1._R8P primitive2 = primitive_compressible ( density = 1._R8P , velocity = velocity , pressure = 1._R8P ) test_passed ( 5 ) = ( primitive1 == primitive2 ). eqv .(. true .) print \"(A)\" , new_line ( 'a' ) // 'all together true' print \"(A,L1)\" , 'density  => 1 == 1 = ' , test_passed ( 5 ) print \"(A,L1)\" , 'velocity => 1 == 1 = ' , test_passed ( 5 ) print \"(A,L1)\" , 'pressure => 1 == 1 = ' , test_passed ( 5 ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram flow_test_primitive_compressible_eq","tags":"","loc":"sourcefile/flow_test_primitive_compressible_eq.f90.html","title":"flow_test_primitive_compressible_eq.f90 – FLOw"},{"text":"FLOw test. This File Depends On sourcefile~~flow_test_primitive_compressible_mul.f90~~EfferentGraph sourcefile~flow_test_primitive_compressible_mul.f90 flow_test_primitive_compressible_mul.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_mul.f90 sourcefile~flow_eos_compressible.f90 flow_eos_compressible.f90 sourcefile~penf.f90->sourcefile~flow_eos_compressible.f90 sourcefile~flow_field_scalar_vectorial.f90 flow_field_scalar_vectorial.f90 sourcefile~penf.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~flow_primitive_object.f90 flow_primitive_object.f90 sourcefile~penf.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_conservative_compressible.f90 flow_conservative_compressible.f90 sourcefile~penf.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_primitive_compressible.f90 flow_primitive_compressible.f90 sourcefile~penf.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_conservative_object.f90 flow_conservative_object.f90 sourcefile~penf.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_primitive_compressible_multispecie.f90 flow_primitive_compressible_multispecie.f90 sourcefile~penf.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_eos_object.f90 flow_eos_object.f90 sourcefile~penf.f90->sourcefile~flow_eos_object.f90 sourcefile~flow_field_object.f90 flow_field_object.f90 sourcefile~penf.f90->sourcefile~flow_field_object.f90 sourcefile~flow_compressible_transformations.f90 flow_compressible_transformations.f90 sourcefile~penf.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow.f90 flow.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_mul.f90 sourcefile~vecfor.f90 vecfor.F90 sourcefile~vecfor.f90->sourcefile~flow_test_primitive_compressible_mul.f90 sourcefile~vecfor.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_object.f90 sourcefile~vecfor.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~vecfor.f90->sourcefile~flow_conservative_object.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~vecfor.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~flow_eos_compressible.f90->sourcefile~flow.f90 sourcefile~flow_field_scalar_vectorial.f90->sourcefile~flow.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_conservative_compressible.f90->sourcefile~flow.f90 sourcefile~flow_conservative_compressible.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_primitive_compressible.f90->sourcefile~flow.f90 sourcefile~flow_primitive_compressible.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_conservative_object.f90->sourcefile~flow.f90 sourcefile~flow_conservative_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_primitive_compressible_multispecie.f90->sourcefile~flow.f90 sourcefile~flow_eos_object.f90->sourcefile~flow.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_eos_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_field_object.f90->sourcefile~flow.f90 sourcefile~flow_field_object.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_field_object.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_compressible_transformations.f90->sourcefile~flow.f90 var pansourcefileflow_test_primitive_compressible_mulf90EfferentGraph = svgPanZoom('#sourcefileflow_test_primitive_compressible_mulf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs flow_test_primitive_compressible_mul Source Code flow_test_primitive_compressible_mul.f90 Source Code !< FLOw test. program flow_test_primitive_compressible_mul !< FLOw test. use flow , only : primitive_compressible use penf , only : I4P , R8P use vecfor , only : vector implicit none type ( primitive_compressible ) :: primitive1 !< A primitive object. type ( primitive_compressible ) :: primitive2 !< A primitive object. type ( primitive_compressible ) :: primitive3 !< A primitive object. type ( vector ) :: velocity !< A vector object. logical :: test_passed ( 5 ) !< List of passed tests. test_passed = . false . velocity = 1._R8P primitive1 = primitive_compressible ( density = 0.125_R8P , velocity = velocity , pressure = 1._R8P ) velocity = 2._R8P primitive2 = primitive_compressible ( density = 1._R8P , velocity = velocity , pressure = 1._R8P ) primitive3 = primitive1 * primitive2 test_passed ( 1 ) = primitive3 == ( primitive1 * primitive2 ) print \"(A,F6.3)\" , 'density   => 0.125  * 1 = ' , primitive3 % density print \"(A,3(F6.3,1X))\" , 'velocity  => 1      * 2 = ' , primitive3 % velocity print \"(A,F6.3)\" , 'pressure  => 1      * 1 = ' , primitive3 % pressure call print_error ( test = 'primitive3 = primitive1 * primitive2' , is_test_passed = test_passed ( 1 )) primitive3 = 2._R8P * primitive1 test_passed ( 2 ) = primitive3 == ( 2._R8P * primitive1 ) print \"(A)\" , '' print \"(A,F6.3)\" , 'density   => 2.0 * 0.125  = ' , primitive3 % density print \"(A,3(F6.3,1X))\" , 'velocity  => 2.0 * 1      = ' , primitive3 % velocity print \"(A,F6.3)\" , 'pressure  => 2.0 * 1      = ' , primitive3 % pressure call print_error ( test = 'primitive3 = 2.0 * primitive1' , is_test_passed = test_passed ( 2 )) primitive3 = primitive1 * 2._R8P test_passed ( 3 ) = primitive3 == ( primitive1 * 2._R8P ) print \"(A)\" , '' print \"(A,F6.3)\" , 'density   => 0.125  * 2.0 = ' , primitive3 % density print \"(A,3(F6.3,1X))\" , 'velocity  => 1      * 2.0 = ' , primitive3 % velocity print \"(A,F6.3)\" , 'pressure  => 1      * 2.0 = ' , primitive3 % pressure call print_error ( test = 'primitive3 = primitive1 * 2.0' , is_test_passed = test_passed ( 3 )) primitive3 = 2_I4P * primitive1 test_passed ( 4 ) = primitive3 == ( 2_I4P * primitive1 ) print \"(A)\" , '' print \"(A,F6.3)\" , 'density   => 2 * 0.125  = ' , primitive3 % density print \"(A,3(F6.3,1X))\" , 'velocity  => 2 * 1      = ' , primitive3 % velocity print \"(A,F6.3)\" , 'pressure  => 2 * 1      = ' , primitive3 % pressure call print_error ( test = 'primitive3 = 2 * primitive1' , is_test_passed = test_passed ( 4 )) primitive3 = primitive1 * 2_I4P test_passed ( 5 ) = primitive3 == ( primitive1 * 2_I4P ) print \"(A)\" , '' print \"(A,F6.3)\" , 'density   => 0.125  * 2 = ' , primitive3 % density print \"(A,3(F6.3,1X))\" , 'velocity  => 1      * 2 = ' , primitive3 % velocity print \"(A,F6.3)\" , 'pressure  => 1      * 2 = ' , primitive3 % pressure call print_error ( test = 'primitive3 = primitive1 * 2' , is_test_passed = test_passed ( 5 )) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) contains subroutine print_error ( test , is_test_passed ) !< Print error message if test is failed. character ( * ), intent ( in ) :: test !< Test description. logical , intent ( in ) :: is_test_passed !< Test result. if (. not . is_test_passed ) then print * , '\"' // test // '\" failed!' print * , 'primitive1:' print \"(A,F6.3)\" , '  density   = ' , primitive1 % density print \"(A,3(F6.3,1X))\" , '  velocity  = ' , primitive1 % velocity print \"(A,F6.3)\" , '  pressure  = ' , primitive1 % pressure print * , 'primitive2:' print \"(A,F6.3)\" , '  density   = ' , primitive2 % density print \"(A,3(F6.3,1X))\" , '  velocity  = ' , primitive2 % velocity print \"(A,F6.3)\" , '  pressure  = ' , primitive2 % pressure print * , 'primitive3:' print \"(A,F6.3)\" , '  density   = ' , primitive3 % density print \"(A,3(F6.3,1X))\" , '  velocity  = ' , primitive3 % velocity print \"(A,F6.3)\" , '  pressure  = ' , primitive3 % pressure endif endsubroutine print_error endprogram flow_test_primitive_compressible_mul","tags":"","loc":"sourcefile/flow_test_primitive_compressible_mul.f90.html","title":"flow_test_primitive_compressible_mul.f90 – FLOw"},{"text":"FLOw test. This File Depends On sourcefile~~flow_test_primitive_compressible_multispecie_add.f90~~EfferentGraph sourcefile~flow_test_primitive_compressible_multispecie_add.f90 flow_test_primitive_compressible_multispecie_add.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_multispecie_add.f90 sourcefile~flow_eos_compressible.f90 flow_eos_compressible.f90 sourcefile~penf.f90->sourcefile~flow_eos_compressible.f90 sourcefile~flow_field_scalar_vectorial.f90 flow_field_scalar_vectorial.f90 sourcefile~penf.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~flow_primitive_object.f90 flow_primitive_object.f90 sourcefile~penf.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_conservative_compressible.f90 flow_conservative_compressible.f90 sourcefile~penf.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_primitive_compressible.f90 flow_primitive_compressible.f90 sourcefile~penf.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_conservative_object.f90 flow_conservative_object.f90 sourcefile~penf.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_primitive_compressible_multispecie.f90 flow_primitive_compressible_multispecie.f90 sourcefile~penf.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_eos_object.f90 flow_eos_object.f90 sourcefile~penf.f90->sourcefile~flow_eos_object.f90 sourcefile~flow_field_object.f90 flow_field_object.f90 sourcefile~penf.f90->sourcefile~flow_field_object.f90 sourcefile~flow_compressible_transformations.f90 flow_compressible_transformations.f90 sourcefile~penf.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow.f90 flow.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_add.f90 sourcefile~vecfor.f90 vecfor.F90 sourcefile~vecfor.f90->sourcefile~flow_test_primitive_compressible_multispecie_add.f90 sourcefile~vecfor.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_object.f90 sourcefile~vecfor.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~vecfor.f90->sourcefile~flow_conservative_object.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~vecfor.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~flow_eos_compressible.f90->sourcefile~flow.f90 sourcefile~flow_field_scalar_vectorial.f90->sourcefile~flow.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_conservative_compressible.f90->sourcefile~flow.f90 sourcefile~flow_conservative_compressible.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_primitive_compressible.f90->sourcefile~flow.f90 sourcefile~flow_primitive_compressible.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_conservative_object.f90->sourcefile~flow.f90 sourcefile~flow_conservative_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_primitive_compressible_multispecie.f90->sourcefile~flow.f90 sourcefile~flow_eos_object.f90->sourcefile~flow.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_eos_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_field_object.f90->sourcefile~flow.f90 sourcefile~flow_field_object.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_field_object.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_compressible_transformations.f90->sourcefile~flow.f90 var pansourcefileflow_test_primitive_compressible_multispecie_addf90EfferentGraph = svgPanZoom('#sourcefileflow_test_primitive_compressible_multispecie_addf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs flow_test_primitive_compressible_multispecie_add Source Code flow_test_primitive_compressible_multispecie_add.f90 Source Code !< FLOw test. program flow_test_primitive_compressible_multispecie_add !< FLOw test. use flow , only : primitive_compressible_multispecie use penf , only : R8P use vecfor , only : vector implicit none type ( primitive_compressible_multispecie ) :: primitive1 !< A primitive object. type ( primitive_compressible_multispecie ) :: primitive2 !< A primitive object. type ( primitive_compressible_multispecie ) :: primitive3 !< A primitive object. type ( vector ) :: velocity !< A vector object. logical :: test_passed ( 2 ) !< List of passed tests. test_passed = . false . velocity = 1._R8P primitive1 = primitive_compressible_multispecie ( density = 0.125_R8P , & velocity = velocity , & pressure = 1._R8P , & partial_densities = [ 0.125_R8P / 2 , 0.125_R8P / 2 ]) velocity = 2._R8P primitive2 = primitive_compressible_multispecie ( density = 1._R8P , & velocity = velocity , & pressure = 1._R8P , & partial_densities = [ 1._R8P / 2 , 1._R8P / 2 ]) primitive3 = primitive1 + primitive2 test_passed ( 1 ) = primitive3 == ( primitive1 + primitive2 ) print \"(A,F6.3)\" , 'density   => 0.125  + 1   = ' , primitive3 % density print \"(A,3(F6.3,1X))\" , 'velocity  => 1      + 2   = ' , primitive3 % velocity print \"(A,F6.3)\" , 'pressure  => 1      + 1   = ' , primitive3 % pressure print \"(A,2(F7.4,1X))\" , 'densities => 0.0625 + 0.5 = ' , primitive3 % partial_densities velocity = - 1._R8P primitive1 = primitive_compressible_multispecie ( density = 0.125_R8P , velocity = velocity , pressure = 1._R8P , & partial_densities = [ 0.125_R8P / 2 , 0.125_R8P / 2 ]) primitive2 = + primitive1 test_passed ( 2 ) = primitive2 == primitive1 print \"(A,F6.3)\" , 'density   => + (0.125)  = ' , primitive2 % density print \"(A,3(F6.3,1X))\" , 'velocity  => + (-1)     = ' , primitive2 % velocity print \"(A,F6.3)\" , 'pressure  => + (1)      = ' , primitive2 % pressure print \"(A,2(F7.4,1X))\" , 'densities => + (0.0625) = ' , primitive2 % partial_densities print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram flow_test_primitive_compressible_multispecie_add","tags":"","loc":"sourcefile/flow_test_primitive_compressible_multispecie_add.f90.html","title":"flow_test_primitive_compressible_multispecie_add.f90 – FLOw"},{"text":"FLOw test. This File Depends On sourcefile~~flow_test_primitive_compressible_multispecie_assign.f90~~EfferentGraph sourcefile~flow_test_primitive_compressible_multispecie_assign.f90 flow_test_primitive_compressible_multispecie_assign.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_multispecie_assign.f90 sourcefile~flow_eos_compressible.f90 flow_eos_compressible.f90 sourcefile~penf.f90->sourcefile~flow_eos_compressible.f90 sourcefile~flow_field_scalar_vectorial.f90 flow_field_scalar_vectorial.f90 sourcefile~penf.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~flow_primitive_object.f90 flow_primitive_object.f90 sourcefile~penf.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_conservative_compressible.f90 flow_conservative_compressible.f90 sourcefile~penf.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_primitive_compressible.f90 flow_primitive_compressible.f90 sourcefile~penf.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_conservative_object.f90 flow_conservative_object.f90 sourcefile~penf.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_primitive_compressible_multispecie.f90 flow_primitive_compressible_multispecie.f90 sourcefile~penf.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_eos_object.f90 flow_eos_object.f90 sourcefile~penf.f90->sourcefile~flow_eos_object.f90 sourcefile~flow_field_object.f90 flow_field_object.f90 sourcefile~penf.f90->sourcefile~flow_field_object.f90 sourcefile~flow_compressible_transformations.f90 flow_compressible_transformations.f90 sourcefile~penf.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow.f90 flow.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_assign.f90 sourcefile~vecfor.f90 vecfor.F90 sourcefile~vecfor.f90->sourcefile~flow_test_primitive_compressible_multispecie_assign.f90 sourcefile~vecfor.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_object.f90 sourcefile~vecfor.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~vecfor.f90->sourcefile~flow_conservative_object.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~vecfor.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~flow_eos_compressible.f90->sourcefile~flow.f90 sourcefile~flow_field_scalar_vectorial.f90->sourcefile~flow.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_conservative_compressible.f90->sourcefile~flow.f90 sourcefile~flow_conservative_compressible.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_primitive_compressible.f90->sourcefile~flow.f90 sourcefile~flow_primitive_compressible.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_conservative_object.f90->sourcefile~flow.f90 sourcefile~flow_conservative_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_primitive_compressible_multispecie.f90->sourcefile~flow.f90 sourcefile~flow_eos_object.f90->sourcefile~flow.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_eos_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_field_object.f90->sourcefile~flow.f90 sourcefile~flow_field_object.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_field_object.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_compressible_transformations.f90->sourcefile~flow.f90 var pansourcefileflow_test_primitive_compressible_multispecie_assignf90EfferentGraph = svgPanZoom('#sourcefileflow_test_primitive_compressible_multispecie_assignf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs flow_test_primitive_compressible_multispecie_assign Source Code flow_test_primitive_compressible_multispecie_assign.f90 Source Code !< FLOw test. program flow_test_primitive_compressible_multispecie_assign !< FLOw test. use flow , only : primitive_compressible_multispecie use penf , only : R8P use vecfor , only : vector implicit none type ( primitive_compressible_multispecie ) :: primitive1 !< A primitive object. type ( primitive_compressible_multispecie ) :: primitive2 !< A primitive object. type ( vector ) :: velocity !< A vector object. logical :: test_passed ( 2 ) !< List of passed tests. test_passed = . false . primitive1 = 0.125_R8P test_passed ( 1 ) = ( primitive1 % density == 0.125_R8P ). and . & ( primitive1 % velocity % x == 0.125_R8P ). and . & ( primitive1 % velocity % y == 0.125_R8P ). and . & ( primitive1 % velocity % z == 0.125_R8P ). and . & ( primitive1 % pressure == 0.125_R8P ) print \"(A,F6.3)\" , 'density   = ' , primitive1 % density print \"(A,3(F6.3,1X))\" , 'velocity  = ' , primitive1 % velocity print \"(A,F6.3)\" , 'pressure  = ' , primitive1 % pressure velocity = 1._R8P primitive1 = primitive_compressible_multispecie ( density = 0.125_R8P , & velocity = velocity , & pressure = 1._R8P , & partial_densities = [ 0.125_R8P / 2 , 0.125_R8P / 2 ]) primitive2 = primitive1 test_passed ( 2 ) = primitive1 == primitive2 print \"(A)\" , '' print \"(A,F6.3)\" , 'density   = ' , primitive2 % density print \"(A,3(F6.3,1X))\" , 'velocity  = ' , primitive2 % velocity print \"(A,F6.3)\" , 'pressure  = ' , primitive2 % pressure print \"(A,2(F7.4,1X))\" , 'densities = ' , primitive2 % partial_densities ( 1 ), primitive2 % partial_densities ( 2 ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram flow_test_primitive_compressible_multispecie_assign","tags":"","loc":"sourcefile/flow_test_primitive_compressible_multispecie_assign.f90.html","title":"flow_test_primitive_compressible_multispecie_assign.f90 – FLOw"},{"text":"FLOw test. This File Depends On sourcefile~~flow_test_primitive_compressible_multispecie_div.f90~~EfferentGraph sourcefile~flow_test_primitive_compressible_multispecie_div.f90 flow_test_primitive_compressible_multispecie_div.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_multispecie_div.f90 sourcefile~flow_eos_compressible.f90 flow_eos_compressible.f90 sourcefile~penf.f90->sourcefile~flow_eos_compressible.f90 sourcefile~flow_field_scalar_vectorial.f90 flow_field_scalar_vectorial.f90 sourcefile~penf.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~flow_primitive_object.f90 flow_primitive_object.f90 sourcefile~penf.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_conservative_compressible.f90 flow_conservative_compressible.f90 sourcefile~penf.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_primitive_compressible.f90 flow_primitive_compressible.f90 sourcefile~penf.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_conservative_object.f90 flow_conservative_object.f90 sourcefile~penf.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_primitive_compressible_multispecie.f90 flow_primitive_compressible_multispecie.f90 sourcefile~penf.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_eos_object.f90 flow_eos_object.f90 sourcefile~penf.f90->sourcefile~flow_eos_object.f90 sourcefile~flow_field_object.f90 flow_field_object.f90 sourcefile~penf.f90->sourcefile~flow_field_object.f90 sourcefile~flow_compressible_transformations.f90 flow_compressible_transformations.f90 sourcefile~penf.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow.f90 flow.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_div.f90 sourcefile~vecfor.f90 vecfor.F90 sourcefile~vecfor.f90->sourcefile~flow_test_primitive_compressible_multispecie_div.f90 sourcefile~vecfor.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_object.f90 sourcefile~vecfor.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~vecfor.f90->sourcefile~flow_conservative_object.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~vecfor.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~flow_eos_compressible.f90->sourcefile~flow.f90 sourcefile~flow_field_scalar_vectorial.f90->sourcefile~flow.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_conservative_compressible.f90->sourcefile~flow.f90 sourcefile~flow_conservative_compressible.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_primitive_compressible.f90->sourcefile~flow.f90 sourcefile~flow_primitive_compressible.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_conservative_object.f90->sourcefile~flow.f90 sourcefile~flow_conservative_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_primitive_compressible_multispecie.f90->sourcefile~flow.f90 sourcefile~flow_eos_object.f90->sourcefile~flow.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_eos_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_field_object.f90->sourcefile~flow.f90 sourcefile~flow_field_object.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_field_object.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_compressible_transformations.f90->sourcefile~flow.f90 var pansourcefileflow_test_primitive_compressible_multispecie_divf90EfferentGraph = svgPanZoom('#sourcefileflow_test_primitive_compressible_multispecie_divf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs flow_test_primitive_compressible_multispecie_div Source Code flow_test_primitive_compressible_multispecie_div.f90 Source Code !< FLOw test. program flow_test_primitive_compressible_multispecie_div !< FLOw test. use flow , only : primitive_compressible_multispecie use penf , only : I4P , R8P use vecfor , only : vector implicit none type ( primitive_compressible_multispecie ) :: primitive1 !< A primitive object. type ( primitive_compressible_multispecie ) :: primitive2 !< A primitive object. type ( primitive_compressible_multispecie ) :: primitive3 !< A primitive object. type ( vector ) :: velocity !< A vector object. logical :: test_passed ( 3 ) !< List of passed tests. test_passed = . false . velocity = 1._R8P primitive1 = primitive_compressible_multispecie ( density = 0.125_R8P , & velocity = velocity , & pressure = 1._R8P , & partial_densities = [ 0.125_R8P / 2 , 0.125_R8P / 2 ]) velocity = 2._R8P primitive2 = primitive_compressible_multispecie ( density = 1._R8P , & velocity = velocity , & pressure = 1._R8P , & partial_densities = [ 1._R8P / 2 , 1._R8P / 2 ]) primitive3 = primitive1 / primitive2 test_passed ( 1 ) = primitive3 == ( primitive1 / primitive2 ) print \"(A,F6.3)\" , 'density   => 0.125  / 1   = ' , primitive3 % density print \"(A,3(F6.3,1X))\" , 'velocity  => 1      / 2   = ' , primitive3 % velocity print \"(A,F6.3)\" , 'pressure  => 1      / 1   = ' , primitive3 % pressure print \"(A,2(F7.4,1X))\" , 'densities => 0.0625 / 0.5 = ' , primitive3 % partial_densities ( 1 ), primitive3 % partial_densities ( 2 ) call print_error ( test = 'primitive3 = primitive1 / primitive2' , is_test_passed = test_passed ( 1 )) primitive3 = primitive1 / 2._R8P test_passed ( 2 ) = primitive3 == ( primitive1 / 2._R8P ) print \"(A)\" , '' print \"(A,F6.3)\" , 'density   => 0.125  / 2.0 = ' , primitive3 % density print \"(A,3(F6.3,1X))\" , 'velocity  => 1      / 2.0 = ' , primitive3 % velocity print \"(A,F6.3)\" , 'pressure  => 1      / 2.0 = ' , primitive3 % pressure print \"(A,2(F7.4,1X))\" , 'densities => 0.0625 / 2.0 = ' , primitive3 % partial_densities ( 1 ), primitive3 % partial_densities ( 2 ) call print_error ( test = 'primitive3 = primitive1 / 2.0' , is_test_passed = test_passed ( 2 )) primitive3 = primitive1 / 2_I4P test_passed ( 3 ) = primitive3 == ( primitive1 / 2_I4P ) print \"(A)\" , '' print \"(A,F6.3)\" , 'density   => 0.125  / 2 = ' , primitive3 % density print \"(A,3(F6.3,1X))\" , 'velocity  => 1      / 2 = ' , primitive3 % velocity print \"(A,F6.3)\" , 'pressure  => 1      / 2 = ' , primitive3 % pressure print \"(A,2(F7.4,1X))\" , 'densities => 0.0625 / 2 = ' , primitive3 % partial_densities ( 1 ), primitive3 % partial_densities ( 2 ) call print_error ( test = 'primitive3 = primitive1 / 2' , is_test_passed = test_passed ( 3 )) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) contains subroutine print_error ( test , is_test_passed ) !< Print error message if test is failed. character ( * ), intent ( in ) :: test !< Test description. logical , intent ( in ) :: is_test_passed !< Test result. if (. not . is_test_passed ) then print * , '\"' // test // '\" failed!' print * , 'primitive1:' print \"(A,F6.3)\" , '  density   = ' , primitive1 % density print \"(A,3(F6.3,1X))\" , '  velocity  = ' , primitive1 % velocity print \"(A,F6.3)\" , '  pressure  = ' , primitive1 % pressure print \"(A,2(F7.4,1X))\" , '  densities = ' , primitive1 % partial_densities ( 1 ), primitive1 % partial_densities ( 2 ) print * , 'primitive2:' print \"(A,F6.3)\" , '  density   = ' , primitive2 % density print \"(A,3(F6.3,1X))\" , '  velocity  = ' , primitive2 % velocity print \"(A,F6.3)\" , '  pressure  = ' , primitive2 % pressure print \"(A,2(F7.4,1X))\" , '  densities = ' , primitive2 % partial_densities ( 1 ), primitive2 % partial_densities ( 2 ) print * , 'primitive3:' print \"(A,F6.3)\" , '  density   = ' , primitive3 % density print \"(A,3(F6.3,1X))\" , '  velocity  = ' , primitive3 % velocity print \"(A,F6.3)\" , '  pressure  = ' , primitive3 % pressure print \"(A,2(F7.4,1X))\" , '  densities = ' , primitive3 % partial_densities ( 1 ), primitive3 % partial_densities ( 2 ) endif endsubroutine print_error endprogram flow_test_primitive_compressible_multispecie_div","tags":"","loc":"sourcefile/flow_test_primitive_compressible_multispecie_div.f90.html","title":"flow_test_primitive_compressible_multispecie_div.f90 – FLOw"},{"text":"FLOw test. This File Depends On sourcefile~~flow_test_primitive_compressible_multispecie_eq.f90~~EfferentGraph sourcefile~flow_test_primitive_compressible_multispecie_eq.f90 flow_test_primitive_compressible_multispecie_eq.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_multispecie_eq.f90 sourcefile~flow_eos_compressible.f90 flow_eos_compressible.f90 sourcefile~penf.f90->sourcefile~flow_eos_compressible.f90 sourcefile~flow_field_scalar_vectorial.f90 flow_field_scalar_vectorial.f90 sourcefile~penf.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~flow_primitive_object.f90 flow_primitive_object.f90 sourcefile~penf.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_conservative_compressible.f90 flow_conservative_compressible.f90 sourcefile~penf.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_primitive_compressible.f90 flow_primitive_compressible.f90 sourcefile~penf.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_conservative_object.f90 flow_conservative_object.f90 sourcefile~penf.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_primitive_compressible_multispecie.f90 flow_primitive_compressible_multispecie.f90 sourcefile~penf.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_eos_object.f90 flow_eos_object.f90 sourcefile~penf.f90->sourcefile~flow_eos_object.f90 sourcefile~flow_field_object.f90 flow_field_object.f90 sourcefile~penf.f90->sourcefile~flow_field_object.f90 sourcefile~flow_compressible_transformations.f90 flow_compressible_transformations.f90 sourcefile~penf.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow.f90 flow.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_eq.f90 sourcefile~vecfor.f90 vecfor.F90 sourcefile~vecfor.f90->sourcefile~flow_test_primitive_compressible_multispecie_eq.f90 sourcefile~vecfor.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_object.f90 sourcefile~vecfor.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~vecfor.f90->sourcefile~flow_conservative_object.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~vecfor.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~flow_eos_compressible.f90->sourcefile~flow.f90 sourcefile~flow_field_scalar_vectorial.f90->sourcefile~flow.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_conservative_compressible.f90->sourcefile~flow.f90 sourcefile~flow_conservative_compressible.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_primitive_compressible.f90->sourcefile~flow.f90 sourcefile~flow_primitive_compressible.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_conservative_object.f90->sourcefile~flow.f90 sourcefile~flow_conservative_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_primitive_compressible_multispecie.f90->sourcefile~flow.f90 sourcefile~flow_eos_object.f90->sourcefile~flow.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_eos_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_field_object.f90->sourcefile~flow.f90 sourcefile~flow_field_object.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_field_object.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_compressible_transformations.f90->sourcefile~flow.f90 var pansourcefileflow_test_primitive_compressible_multispecie_eqf90EfferentGraph = svgPanZoom('#sourcefileflow_test_primitive_compressible_multispecie_eqf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs flow_test_primitive_compressible_multispecie_eq Source Code flow_test_primitive_compressible_multispecie_eq.f90 Source Code !< FLOw test. program flow_test_primitive_compressible_multispecie_eq !< FLOw test. use flow , only : primitive_compressible_multispecie use penf , only : R8P use vecfor , only : vector implicit none type ( primitive_compressible_multispecie ) :: primitive1 !< A primitive object. type ( primitive_compressible_multispecie ) :: primitive2 !< A primitive object. type ( vector ) :: velocity !< A vector object. logical :: test_passed ( 8 ) !< List of passed tests. test_passed = . false . velocity = 1._R8P primitive1 = primitive_compressible_multispecie ( density = 0.125_R8P , velocity = velocity , pressure = 1._R8P ) velocity = 1._R8P primitive2 = primitive_compressible_multispecie ( density = 1._R8P , velocity = velocity , pressure = 1._R8P ) test_passed ( 1 ) = ( primitive1 == primitive2 ). eqv .(. false .) print \"(A,L1)\" , 'density  => 0.125 /= 1 = ' , test_passed ( 1 ) velocity = 1._R8P primitive1 = primitive_compressible_multispecie ( density = 0.125_R8P , velocity = velocity , pressure = 1._R8P ) velocity = 2._R8P primitive2 = primitive_compressible_multispecie ( density = 0.125_R8P , velocity = velocity , pressure = 1._R8P ) test_passed ( 2 ) = ( primitive1 == primitive2 ). eqv .(. false .) print \"(A,L1)\" , 'velocity => 1     /= 2 = ' , test_passed ( 2 ) velocity = 1._R8P primitive1 = primitive_compressible_multispecie ( density = 0.125_R8P , velocity = velocity , pressure = 1._R8P ) velocity = 2._R8P primitive2 = primitive_compressible_multispecie ( density = 0.125_R8P , velocity = velocity , pressure = 2._R8P ) test_passed ( 3 ) = ( primitive1 == primitive2 ). eqv .(. false .) print \"(A,L1)\" , 'pressure => 1     /= 2 = ' , test_passed ( 3 ) velocity = 1._R8P primitive1 = primitive_compressible_multispecie ( density = 0.125_R8P , velocity = velocity , pressure = 1._R8P ) velocity = 2._R8P primitive2 = primitive_compressible_multispecie ( density = 1._R8P , velocity = velocity , pressure = 2._R8P ) test_passed ( 4 ) = ( primitive1 == primitive2 ). eqv .(. false .) print \"(A)\" , new_line ( 'a' ) // 'all together' print \"(A,L1)\" , 'density  => 0.125 /= 1 = ' , test_passed ( 4 ) print \"(A,L1)\" , 'velocity => 1     /= 2 = ' , test_passed ( 4 ) print \"(A,L1)\" , 'pressure => 1     /= 2 = ' , test_passed ( 4 ) velocity = 1._R8P primitive1 = primitive_compressible_multispecie ( density = 1._R8P , velocity = velocity , pressure = 1._R8P ) velocity = 1._R8P primitive2 = primitive_compressible_multispecie ( density = 1._R8P , velocity = velocity , pressure = 1._R8P ) test_passed ( 5 ) = ( primitive1 == primitive2 ). eqv .(. true .) print \"(A)\" , new_line ( 'a' ) // 'all together true' print \"(A,L1)\" , 'density  => 1 == 1 = ' , test_passed ( 5 ) print \"(A,L1)\" , 'velocity => 1 == 1 = ' , test_passed ( 5 ) print \"(A,L1)\" , 'pressure => 1 == 1 = ' , test_passed ( 5 ) velocity = 1._R8P primitive1 = primitive_compressible_multispecie ( density = 1._R8P , velocity = velocity , pressure = 1._R8P , partial_densities = [ 0.5_R8P ]) velocity = 1._R8P primitive2 = primitive_compressible_multispecie ( density = 1._R8P , velocity = velocity , pressure = 1._R8P ) test_passed ( 6 ) = ( primitive1 == primitive2 ). eqv .(. false .) print \"(A)\" , new_line ( 'a' ) // 'all together true with imcompatible densities' print \"(A,L1)\" , 'density   => 1   == 1    = ' , test_passed ( 6 ) print \"(A,L1)\" , 'velocity  => 1   == 1    = ' , test_passed ( 6 ) print \"(A,L1)\" , 'pressure  => 1   == 1    = ' , test_passed ( 6 ) print \"(A,L1)\" , 'densities => 0.5 /= null = ' , test_passed ( 6 ) velocity = 1._R8P primitive1 = primitive_compressible_multispecie ( density = 1._R8P , velocity = velocity , pressure = 1._R8P , partial_densities = [ 0.5_R8P ]) velocity = 1._R8P primitive2 = primitive_compressible_multispecie ( density = 1._R8P , velocity = velocity , pressure = 1._R8P , partial_densities = [ 0.1_R8P ]) test_passed ( 7 ) = ( primitive1 == primitive2 ). eqv .(. false .) print \"(A)\" , new_line ( 'a' ) // 'all together true with different densities' print \"(A,L1)\" , 'density   => 1   == 1   = ' , test_passed ( 7 ) print \"(A,L1)\" , 'velocity  => 1   == 1   = ' , test_passed ( 7 ) print \"(A,L1)\" , 'pressure  => 1   == 1   = ' , test_passed ( 7 ) print \"(A,L1)\" , 'densities => 0.5 /= 0.1 = ' , test_passed ( 7 ) velocity = 1._R8P primitive1 = primitive_compressible_multispecie ( density = 1._R8P , velocity = velocity , pressure = 1._R8P , partial_densities = [ 0.5_R8P ]) velocity = 1._R8P primitive2 = primitive_compressible_multispecie ( density = 1._R8P , velocity = velocity , pressure = 1._R8P , partial_densities = [ 0.5_R8P ]) test_passed ( 8 ) = ( primitive1 == primitive2 ). eqv .(. true .) print \"(A)\" , new_line ( 'a' ) // 'all together true with densities' print \"(A,L1)\" , 'density   => 1   == 1   = ' , test_passed ( 8 ) print \"(A,L1)\" , 'velocity  => 1   == 1   = ' , test_passed ( 8 ) print \"(A,L1)\" , 'pressure  => 1   == 1   = ' , test_passed ( 8 ) print \"(A,L1)\" , 'densities => 0.5 == 0.5 = ' , test_passed ( 8 ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram flow_test_primitive_compressible_multispecie_eq","tags":"","loc":"sourcefile/flow_test_primitive_compressible_multispecie_eq.f90.html","title":"flow_test_primitive_compressible_multispecie_eq.f90 – FLOw"},{"text":"FLOw test. This File Depends On sourcefile~~flow_test_primitive_compressible_multispecie_mul.f90~~EfferentGraph sourcefile~flow_test_primitive_compressible_multispecie_mul.f90 flow_test_primitive_compressible_multispecie_mul.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_multispecie_mul.f90 sourcefile~flow_eos_compressible.f90 flow_eos_compressible.f90 sourcefile~penf.f90->sourcefile~flow_eos_compressible.f90 sourcefile~flow_field_scalar_vectorial.f90 flow_field_scalar_vectorial.f90 sourcefile~penf.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~flow_primitive_object.f90 flow_primitive_object.f90 sourcefile~penf.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_conservative_compressible.f90 flow_conservative_compressible.f90 sourcefile~penf.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_primitive_compressible.f90 flow_primitive_compressible.f90 sourcefile~penf.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_conservative_object.f90 flow_conservative_object.f90 sourcefile~penf.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_primitive_compressible_multispecie.f90 flow_primitive_compressible_multispecie.f90 sourcefile~penf.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_eos_object.f90 flow_eos_object.f90 sourcefile~penf.f90->sourcefile~flow_eos_object.f90 sourcefile~flow_field_object.f90 flow_field_object.f90 sourcefile~penf.f90->sourcefile~flow_field_object.f90 sourcefile~flow_compressible_transformations.f90 flow_compressible_transformations.f90 sourcefile~penf.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow.f90 flow.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_mul.f90 sourcefile~vecfor.f90 vecfor.F90 sourcefile~vecfor.f90->sourcefile~flow_test_primitive_compressible_multispecie_mul.f90 sourcefile~vecfor.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_object.f90 sourcefile~vecfor.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~vecfor.f90->sourcefile~flow_conservative_object.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~vecfor.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~flow_eos_compressible.f90->sourcefile~flow.f90 sourcefile~flow_field_scalar_vectorial.f90->sourcefile~flow.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_conservative_compressible.f90->sourcefile~flow.f90 sourcefile~flow_conservative_compressible.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_primitive_compressible.f90->sourcefile~flow.f90 sourcefile~flow_primitive_compressible.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_conservative_object.f90->sourcefile~flow.f90 sourcefile~flow_conservative_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_primitive_compressible_multispecie.f90->sourcefile~flow.f90 sourcefile~flow_eos_object.f90->sourcefile~flow.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_eos_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_field_object.f90->sourcefile~flow.f90 sourcefile~flow_field_object.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_field_object.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_compressible_transformations.f90->sourcefile~flow.f90 var pansourcefileflow_test_primitive_compressible_multispecie_mulf90EfferentGraph = svgPanZoom('#sourcefileflow_test_primitive_compressible_multispecie_mulf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs flow_test_primitive_compressible_multispecie_mul Source Code flow_test_primitive_compressible_multispecie_mul.f90 Source Code !< FLOw test. program flow_test_primitive_compressible_multispecie_mul !< FLOw test. use flow , only : primitive_compressible_multispecie use penf , only : I4P , R8P use vecfor , only : vector implicit none type ( primitive_compressible_multispecie ) :: primitive1 !< A primitive object. type ( primitive_compressible_multispecie ) :: primitive2 !< A primitive object. type ( primitive_compressible_multispecie ) :: primitive3 !< A primitive object. type ( vector ) :: velocity !< A vector object. logical :: test_passed ( 5 ) !< List of passed tests. test_passed = . false . velocity = 1._R8P primitive1 = primitive_compressible_multispecie ( density = 0.125_R8P , & velocity = velocity , & pressure = 1._R8P , & partial_densities = [ 0.125_R8P / 2 , 0.125_R8P / 2 ]) velocity = 2._R8P primitive2 = primitive_compressible_multispecie ( density = 1._R8P , & velocity = velocity , & pressure = 1._R8P , & partial_densities = [ 1._R8P / 2 , 1._R8P / 2 ]) primitive3 = primitive1 * primitive2 test_passed ( 1 ) = primitive3 == ( primitive1 * primitive2 ) print \"(A,F6.3)\" , 'density   => 0.125  * 1 = ' , primitive3 % density print \"(A,3(F6.3,1X))\" , 'velocity  => 1      * 2 = ' , primitive3 % velocity print \"(A,F6.3)\" , 'pressure  => 1      * 1 = ' , primitive3 % pressure print \"(A,2(F7.4,1X))\" , 'densities => 0.0625 * 0.5 = ' , primitive3 % partial_densities ( 1 ), primitive3 % partial_densities ( 2 ) call print_error ( test = 'primitive3 = primitive1 * primitive2' , is_test_passed = test_passed ( 1 )) primitive3 = 2._R8P * primitive1 test_passed ( 2 ) = primitive3 == ( 2._R8P * primitive1 ) print \"(A)\" , '' print \"(A,F6.3)\" , 'density   => 2.0 * 0.125  = ' , primitive3 % density print \"(A,3(F6.3,1X))\" , 'velocity  => 2.0 * 1      = ' , primitive3 % velocity print \"(A,F6.3)\" , 'pressure  => 2.0 * 1      = ' , primitive3 % pressure print \"(A,2(F7.4,1X))\" , 'densities => 2.0 * 0.0625 = ' , primitive3 % partial_densities ( 1 ), primitive3 % partial_densities ( 2 ) call print_error ( test = 'primitive3 = 2.0 * primitive1' , is_test_passed = test_passed ( 2 )) primitive3 = primitive1 * 2._R8P test_passed ( 3 ) = primitive3 == ( primitive1 * 2._R8P ) print \"(A)\" , '' print \"(A,F6.3)\" , 'density   => 0.125  * 2.0 = ' , primitive3 % density print \"(A,3(F6.3,1X))\" , 'velocity  => 1      * 2.0 = ' , primitive3 % velocity print \"(A,F6.3)\" , 'pressure  => 1      * 2.0 = ' , primitive3 % pressure print \"(A,2(F7.4,1X))\" , 'densities => 0.0625 * 2.0 = ' , primitive3 % partial_densities ( 1 ), primitive3 % partial_densities ( 2 ) call print_error ( test = 'primitive3 = primitive1 * 2.0' , is_test_passed = test_passed ( 3 )) primitive3 = 2_I4P * primitive1 test_passed ( 4 ) = primitive3 == ( 2_I4P * primitive1 ) print \"(A)\" , '' print \"(A,F6.3)\" , 'density   => 2 * 0.125  = ' , primitive3 % density print \"(A,3(F6.3,1X))\" , 'velocity  => 2 * 1      = ' , primitive3 % velocity print \"(A,F6.3)\" , 'pressure  => 2 * 1      = ' , primitive3 % pressure print \"(A,2(F7.4,1X))\" , 'densities => 2 * 0.0625 = ' , primitive3 % partial_densities ( 1 ), primitive3 % partial_densities ( 2 ) call print_error ( test = 'primitive3 = 2 * primitive1' , is_test_passed = test_passed ( 4 )) primitive3 = primitive1 * 2_I4P test_passed ( 5 ) = primitive3 == ( primitive1 * 2_I4P ) print \"(A)\" , '' print \"(A,F6.3)\" , 'density   => 0.125  * 2 = ' , primitive3 % density print \"(A,3(F6.3,1X))\" , 'velocity  => 1      * 2 = ' , primitive3 % velocity print \"(A,F6.3)\" , 'pressure  => 1      * 2 = ' , primitive3 % pressure print \"(A,2(F7.4,1X))\" , 'densities => 0.0625 * 2 = ' , primitive3 % partial_densities ( 1 ), primitive3 % partial_densities ( 2 ) call print_error ( test = 'primitive3 = primitive1 * 2' , is_test_passed = test_passed ( 5 )) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) contains subroutine print_error ( test , is_test_passed ) !< Print error message if test is failed. character ( * ), intent ( in ) :: test !< Test description. logical , intent ( in ) :: is_test_passed !< Test result. if (. not . is_test_passed ) then print * , '\"' // test // '\" failed!' print * , 'primitive1:' print \"(A,F6.3)\" , '  density   = ' , primitive1 % density print \"(A,3(F6.3,1X))\" , '  velocity  = ' , primitive1 % velocity print \"(A,F6.3)\" , '  pressure  = ' , primitive1 % pressure print \"(A,2(F7.4,1X))\" , '  densities = ' , primitive1 % partial_densities ( 1 ), primitive1 % partial_densities ( 2 ) print * , 'primitive2:' print \"(A,F6.3)\" , '  density   = ' , primitive2 % density print \"(A,3(F6.3,1X))\" , '  velocity  = ' , primitive2 % velocity print \"(A,F6.3)\" , '  pressure  = ' , primitive2 % pressure print \"(A,2(F7.4,1X))\" , '  densities = ' , primitive2 % partial_densities ( 1 ), primitive2 % partial_densities ( 2 ) print * , 'primitive3:' print \"(A,F6.3)\" , '  density   = ' , primitive3 % density print \"(A,3(F6.3,1X))\" , '  velocity  = ' , primitive3 % velocity print \"(A,F6.3)\" , '  pressure  = ' , primitive3 % pressure print \"(A,2(F7.4,1X))\" , '  densities = ' , primitive3 % partial_densities ( 1 ), primitive3 % partial_densities ( 2 ) endif endsubroutine print_error endprogram flow_test_primitive_compressible_multispecie_mul","tags":"","loc":"sourcefile/flow_test_primitive_compressible_multispecie_mul.f90.html","title":"flow_test_primitive_compressible_multispecie_mul.f90 – FLOw"},{"text":"FLOw test. This File Depends On sourcefile~~flow_test_primitive_compressible_multispecie_not_eq.f90~~EfferentGraph sourcefile~flow_test_primitive_compressible_multispecie_not_eq.f90 flow_test_primitive_compressible_multispecie_not_eq.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_multispecie_not_eq.f90 sourcefile~flow_eos_compressible.f90 flow_eos_compressible.f90 sourcefile~penf.f90->sourcefile~flow_eos_compressible.f90 sourcefile~flow_field_scalar_vectorial.f90 flow_field_scalar_vectorial.f90 sourcefile~penf.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~flow_primitive_object.f90 flow_primitive_object.f90 sourcefile~penf.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_conservative_compressible.f90 flow_conservative_compressible.f90 sourcefile~penf.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_primitive_compressible.f90 flow_primitive_compressible.f90 sourcefile~penf.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_conservative_object.f90 flow_conservative_object.f90 sourcefile~penf.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_primitive_compressible_multispecie.f90 flow_primitive_compressible_multispecie.f90 sourcefile~penf.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_eos_object.f90 flow_eos_object.f90 sourcefile~penf.f90->sourcefile~flow_eos_object.f90 sourcefile~flow_field_object.f90 flow_field_object.f90 sourcefile~penf.f90->sourcefile~flow_field_object.f90 sourcefile~flow_compressible_transformations.f90 flow_compressible_transformations.f90 sourcefile~penf.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow.f90 flow.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_not_eq.f90 sourcefile~vecfor.f90 vecfor.F90 sourcefile~vecfor.f90->sourcefile~flow_test_primitive_compressible_multispecie_not_eq.f90 sourcefile~vecfor.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_object.f90 sourcefile~vecfor.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~vecfor.f90->sourcefile~flow_conservative_object.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~vecfor.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~flow_eos_compressible.f90->sourcefile~flow.f90 sourcefile~flow_field_scalar_vectorial.f90->sourcefile~flow.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_conservative_compressible.f90->sourcefile~flow.f90 sourcefile~flow_conservative_compressible.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_primitive_compressible.f90->sourcefile~flow.f90 sourcefile~flow_primitive_compressible.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_conservative_object.f90->sourcefile~flow.f90 sourcefile~flow_conservative_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_primitive_compressible_multispecie.f90->sourcefile~flow.f90 sourcefile~flow_eos_object.f90->sourcefile~flow.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_eos_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_field_object.f90->sourcefile~flow.f90 sourcefile~flow_field_object.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_field_object.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_compressible_transformations.f90->sourcefile~flow.f90 var pansourcefileflow_test_primitive_compressible_multispecie_not_eqf90EfferentGraph = svgPanZoom('#sourcefileflow_test_primitive_compressible_multispecie_not_eqf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs flow_test_primitive_compressible_multispecie_not_eq Source Code flow_test_primitive_compressible_multispecie_not_eq.f90 Source Code !< FLOw test. program flow_test_primitive_compressible_multispecie_not_eq !< FLOw test. use flow , only : primitive_compressible_multispecie use penf , only : R8P use vecfor , only : vector implicit none type ( primitive_compressible_multispecie ) :: primitive1 !< A primitive object. type ( primitive_compressible_multispecie ) :: primitive2 !< A primitive object. type ( vector ) :: velocity !< A vector object. logical :: test_passed ( 8 ) !< List of passed tests. test_passed = . false . velocity = 1._R8P primitive1 = primitive_compressible_multispecie ( density = 0.125_R8P , velocity = velocity , pressure = 1._R8P ) velocity = 1._R8P primitive2 = primitive_compressible_multispecie ( density = 1._R8P , velocity = velocity , pressure = 1._R8P ) test_passed ( 1 ) = ( primitive1 /= primitive2 ). eqv .(. true .) print \"(A,L1)\" , 'density  => 0.125 /= 1 = ' , test_passed ( 1 ) velocity = 1._R8P primitive1 = primitive_compressible_multispecie ( density = 0.125_R8P , velocity = velocity , pressure = 1._R8P ) velocity = 2._R8P primitive2 = primitive_compressible_multispecie ( density = 0.125_R8P , velocity = velocity , pressure = 1._R8P ) test_passed ( 2 ) = ( primitive1 /= primitive2 ). eqv .(. true .) print \"(A,L1)\" , 'velocity => 1     /= 2 = ' , test_passed ( 2 ) velocity = 1._R8P primitive1 = primitive_compressible_multispecie ( density = 0.125_R8P , velocity = velocity , pressure = 1._R8P ) velocity = 2._R8P primitive2 = primitive_compressible_multispecie ( density = 0.125_R8P , velocity = velocity , pressure = 2._R8P ) test_passed ( 3 ) = ( primitive1 /= primitive2 ). eqv .(. true .) print \"(A,L1)\" , 'pressure => 1     /= 2 = ' , test_passed ( 3 ) velocity = 1._R8P primitive1 = primitive_compressible_multispecie ( density = 0.125_R8P , velocity = velocity , pressure = 1._R8P ) velocity = 2._R8P primitive2 = primitive_compressible_multispecie ( density = 1._R8P , velocity = velocity , pressure = 2._R8P ) test_passed ( 4 ) = ( primitive1 /= primitive2 ). eqv .(. true .) print \"(A)\" , new_line ( 'a' ) // 'all together' print \"(A,L1)\" , 'density  => 0.125 /= 1 = ' , test_passed ( 4 ) print \"(A,L1)\" , 'velocity => 1     /= 2 = ' , test_passed ( 4 ) print \"(A,L1)\" , 'pressure => 1     /= 2 = ' , test_passed ( 4 ) velocity = 1._R8P primitive1 = primitive_compressible_multispecie ( density = 1._R8P , velocity = velocity , pressure = 1._R8P ) velocity = 1._R8P primitive2 = primitive_compressible_multispecie ( density = 1._R8P , velocity = velocity , pressure = 1._R8P ) test_passed ( 5 ) = ( primitive1 /= primitive2 ). eqv .(. false .) print \"(A)\" , new_line ( 'a' ) // 'all together' print \"(A,L1)\" , 'density  => 0.125 /= 1 = ' , test_passed ( 5 ) print \"(A,L1)\" , 'velocity => 1     /= 2 = ' , test_passed ( 5 ) print \"(A,L1)\" , 'pressure => 1     /= 2 = ' , test_passed ( 5 ) velocity = 1._R8P primitive1 = primitive_compressible_multispecie ( density = 1._R8P , velocity = velocity , pressure = 1._R8P , partial_densities = [ 0.5_R8P ]) velocity = 1._R8P primitive2 = primitive_compressible_multispecie ( density = 1._R8P , velocity = velocity , pressure = 1._R8P ) test_passed ( 6 ) = ( primitive1 /= primitive2 ). eqv .(. true .) print \"(A)\" , new_line ( 'a' ) // 'all together true with densities' print \"(A,L1)\" , 'density   => 1   == 1    = ' , test_passed ( 6 ) print \"(A,L1)\" , 'velocity  => 1   == 1    = ' , test_passed ( 6 ) print \"(A,L1)\" , 'pressure  => 1   == 1    = ' , test_passed ( 6 ) print \"(A,L1)\" , 'densities => 0.5 /= null = ' , test_passed ( 6 ) velocity = 1._R8P primitive1 = primitive_compressible_multispecie ( density = 1._R8P , velocity = velocity , pressure = 1._R8P , partial_densities = [ 0.5_R8P ]) velocity = 1._R8P primitive2 = primitive_compressible_multispecie ( density = 1._R8P , velocity = velocity , pressure = 1._R8P , partial_densities = [ 0.1_R8P ]) test_passed ( 7 ) = ( primitive1 /= primitive2 ). eqv .(. true .) print \"(A)\" , new_line ( 'a' ) // 'all together true with densities' print \"(A,L1)\" , 'density   => 1   == 1   = ' , test_passed ( 7 ) print \"(A,L1)\" , 'velocity  => 1   == 1   = ' , test_passed ( 7 ) print \"(A,L1)\" , 'pressure  => 1   == 1   = ' , test_passed ( 7 ) print \"(A,L1)\" , 'densities => 0.5 /= 0.1 = ' , test_passed ( 7 ) velocity = 1._R8P primitive1 = primitive_compressible_multispecie ( density = 1._R8P , velocity = velocity , pressure = 1._R8P , partial_densities = [ 0.5_R8P ]) velocity = 1._R8P primitive2 = primitive_compressible_multispecie ( density = 1._R8P , velocity = velocity , pressure = 1._R8P , partial_densities = [ 0.5_R8P ]) test_passed ( 8 ) = ( primitive1 /= primitive2 ). eqv .(. false .) print \"(A)\" , new_line ( 'a' ) // 'all together true with densities' print \"(A,L1)\" , 'density   => 1   == 1   = ' , test_passed ( 8 ) print \"(A,L1)\" , 'velocity  => 1   == 1   = ' , test_passed ( 8 ) print \"(A,L1)\" , 'pressure  => 1   == 1   = ' , test_passed ( 8 ) print \"(A,L1)\" , 'densities => 0.5 == 0.5 = ' , test_passed ( 8 ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram flow_test_primitive_compressible_multispecie_not_eq","tags":"","loc":"sourcefile/flow_test_primitive_compressible_multispecie_not_eq.f90.html","title":"flow_test_primitive_compressible_multispecie_not_eq.f90 – FLOw"},{"text":"FLOw test. This File Depends On sourcefile~~flow_test_primitive_compressible_multispecie_pow.f90~~EfferentGraph sourcefile~flow_test_primitive_compressible_multispecie_pow.f90 flow_test_primitive_compressible_multispecie_pow.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_multispecie_pow.f90 sourcefile~flow_eos_compressible.f90 flow_eos_compressible.f90 sourcefile~penf.f90->sourcefile~flow_eos_compressible.f90 sourcefile~flow_field_scalar_vectorial.f90 flow_field_scalar_vectorial.f90 sourcefile~penf.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~flow_primitive_object.f90 flow_primitive_object.f90 sourcefile~penf.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_conservative_compressible.f90 flow_conservative_compressible.f90 sourcefile~penf.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_primitive_compressible.f90 flow_primitive_compressible.f90 sourcefile~penf.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_conservative_object.f90 flow_conservative_object.f90 sourcefile~penf.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_primitive_compressible_multispecie.f90 flow_primitive_compressible_multispecie.f90 sourcefile~penf.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_eos_object.f90 flow_eos_object.f90 sourcefile~penf.f90->sourcefile~flow_eos_object.f90 sourcefile~flow_field_object.f90 flow_field_object.f90 sourcefile~penf.f90->sourcefile~flow_field_object.f90 sourcefile~flow_compressible_transformations.f90 flow_compressible_transformations.f90 sourcefile~penf.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow.f90 flow.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_pow.f90 sourcefile~vecfor.f90 vecfor.F90 sourcefile~vecfor.f90->sourcefile~flow_test_primitive_compressible_multispecie_pow.f90 sourcefile~vecfor.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_object.f90 sourcefile~vecfor.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~vecfor.f90->sourcefile~flow_conservative_object.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~vecfor.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~flow_eos_compressible.f90->sourcefile~flow.f90 sourcefile~flow_field_scalar_vectorial.f90->sourcefile~flow.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_conservative_compressible.f90->sourcefile~flow.f90 sourcefile~flow_conservative_compressible.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_primitive_compressible.f90->sourcefile~flow.f90 sourcefile~flow_primitive_compressible.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_conservative_object.f90->sourcefile~flow.f90 sourcefile~flow_conservative_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_primitive_compressible_multispecie.f90->sourcefile~flow.f90 sourcefile~flow_eos_object.f90->sourcefile~flow.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_eos_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_field_object.f90->sourcefile~flow.f90 sourcefile~flow_field_object.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_field_object.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_compressible_transformations.f90->sourcefile~flow.f90 var pansourcefileflow_test_primitive_compressible_multispecie_powf90EfferentGraph = svgPanZoom('#sourcefileflow_test_primitive_compressible_multispecie_powf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs flow_test_primitive_compressible_multispecie_add Source Code flow_test_primitive_compressible_multispecie_pow.f90 Source Code !< FLOw test. program flow_test_primitive_compressible_multispecie_add !< FLOw test. use flow , only : primitive_compressible_multispecie use penf , only : I4P , R8P use vecfor , only : vector implicit none type ( primitive_compressible_multispecie ) :: primitive1 !< A primitive object. type ( primitive_compressible_multispecie ) :: primitive2 !< A primitive object. type ( vector ) :: velocity !< A vector object. logical :: test_passed ( 4 ) !< List of passed tests. test_passed = . false . velocity = 0.5_R8P primitive1 = primitive_compressible_multispecie ( density = 0.125_R8P , velocity = velocity , pressure = 1._R8P ) primitive2 = primitive1 ** 2_I4P print \"(A,F6.3)\" , 'density  => 0.125 ** 2 = ' , primitive2 % density print \"(A,3(F6.3,1X))\" , 'velocity => 0.5   ** 2 = ' , primitive2 % velocity print \"(A,F6.3)\" , 'pressure => 1     ** 2 = ' , primitive2 % pressure test_passed ( 1 ) = primitive2 % density == ( 0.125_R8P ** 2_I4P ) velocity = 0.5_R8P primitive1 = primitive_compressible_multispecie ( density = 0.125_R8P , & velocity = velocity , & pressure = 1._R8P , & partial_densities = [ 0.125_R8P , 0.125_R8P ]) primitive2 = primitive1 ** 2_I4P print \"(A,F6.3)\" , 'density   => 0.125 ** 2 = ' , primitive2 % density print \"(A,3(F6.3,1X))\" , 'velocity  => 0.5   ** 2 = ' , primitive2 % velocity print \"(A,F6.3)\" , 'pressure  => 1     ** 2 = ' , primitive2 % pressure print \"(A,2(F6.3,1X))\" , 'densities => 0.125 ** 2 = ' , primitive2 % partial_densities test_passed ( 2 ) = primitive2 % partial_densities ( 1 ) == ( 0.125_R8P ** 2_I4P ) velocity = 0.5_R8P primitive1 = primitive_compressible_multispecie ( density = 0.125_R8P , velocity = velocity , pressure = 1._R8P ) primitive2 = primitive1 ** 2._R8P print \"(A,F6.3)\" , 'density  => 0.125 ** 2.0 = ' , primitive2 % density print \"(A,3(F6.3,1X))\" , 'velocity => 0.5   ** 2.0 = ' , primitive2 % velocity print \"(A,F6.3)\" , 'pressure => 1     ** 2.0 = ' , primitive2 % pressure test_passed ( 3 ) = primitive2 % density == ( 0.125_R8P ** 2._R8P ) velocity = 0.5_R8P primitive1 = primitive_compressible_multispecie ( density = 0.125_R8P , & velocity = velocity , & pressure = 1._R8P , & partial_densities = [ 0.125_R8P , 0.125_R8P ]) primitive2 = primitive1 ** 2._R8P print \"(A,F6.3)\" , 'density   => 0.125 ** 2.0 = ' , primitive2 % density print \"(A,3(F6.3,1X))\" , 'velocity  => 0.5   ** 2.0 = ' , primitive2 % velocity print \"(A,F6.3)\" , 'pressure  => 1     ** 2.0 = ' , primitive2 % pressure print \"(A,2(F6.3,1X))\" , 'densities => 0.125 ** 2.0 = ' , primitive2 % partial_densities test_passed ( 4 ) = primitive2 % partial_densities ( 1 ) == ( 0.125_R8P ** 2._R8P ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram flow_test_primitive_compressible_multispecie_add","tags":"","loc":"sourcefile/flow_test_primitive_compressible_multispecie_pow.f90.html","title":"flow_test_primitive_compressible_multispecie_pow.f90 – FLOw"},{"text":"FLOw test. This File Depends On sourcefile~~flow_test_primitive_compressible_multispecie_sub.f90~~EfferentGraph sourcefile~flow_test_primitive_compressible_multispecie_sub.f90 flow_test_primitive_compressible_multispecie_sub.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_multispecie_sub.f90 sourcefile~flow_eos_compressible.f90 flow_eos_compressible.f90 sourcefile~penf.f90->sourcefile~flow_eos_compressible.f90 sourcefile~flow_field_scalar_vectorial.f90 flow_field_scalar_vectorial.f90 sourcefile~penf.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~flow_primitive_object.f90 flow_primitive_object.f90 sourcefile~penf.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_conservative_compressible.f90 flow_conservative_compressible.f90 sourcefile~penf.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_primitive_compressible.f90 flow_primitive_compressible.f90 sourcefile~penf.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_conservative_object.f90 flow_conservative_object.f90 sourcefile~penf.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_primitive_compressible_multispecie.f90 flow_primitive_compressible_multispecie.f90 sourcefile~penf.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_eos_object.f90 flow_eos_object.f90 sourcefile~penf.f90->sourcefile~flow_eos_object.f90 sourcefile~flow_field_object.f90 flow_field_object.f90 sourcefile~penf.f90->sourcefile~flow_field_object.f90 sourcefile~flow_compressible_transformations.f90 flow_compressible_transformations.f90 sourcefile~penf.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow.f90 flow.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_sub.f90 sourcefile~vecfor.f90 vecfor.F90 sourcefile~vecfor.f90->sourcefile~flow_test_primitive_compressible_multispecie_sub.f90 sourcefile~vecfor.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_object.f90 sourcefile~vecfor.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~vecfor.f90->sourcefile~flow_conservative_object.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~vecfor.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~flow_eos_compressible.f90->sourcefile~flow.f90 sourcefile~flow_field_scalar_vectorial.f90->sourcefile~flow.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_conservative_compressible.f90->sourcefile~flow.f90 sourcefile~flow_conservative_compressible.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_primitive_compressible.f90->sourcefile~flow.f90 sourcefile~flow_primitive_compressible.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_conservative_object.f90->sourcefile~flow.f90 sourcefile~flow_conservative_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_primitive_compressible_multispecie.f90->sourcefile~flow.f90 sourcefile~flow_eos_object.f90->sourcefile~flow.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_eos_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_field_object.f90->sourcefile~flow.f90 sourcefile~flow_field_object.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_field_object.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_compressible_transformations.f90->sourcefile~flow.f90 var pansourcefileflow_test_primitive_compressible_multispecie_subf90EfferentGraph = svgPanZoom('#sourcefileflow_test_primitive_compressible_multispecie_subf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs flow_test_primitive_compressible_multispecie_sub Source Code flow_test_primitive_compressible_multispecie_sub.f90 Source Code !< FLOw test. program flow_test_primitive_compressible_multispecie_sub !< FLOw test. use flow , only : primitive_compressible_multispecie use penf , only : R8P use vecfor , only : vector implicit none type ( primitive_compressible_multispecie ) :: primitive1 !< A primitive object. type ( primitive_compressible_multispecie ) :: primitive2 !< A primitive object. type ( primitive_compressible_multispecie ) :: primitive3 !< A primitive object. type ( vector ) :: velocity !< A vector object. logical :: test_passed ( 2 ) !< List of passed tests. test_passed = . false . velocity = 1._R8P primitive1 = primitive_compressible_multispecie ( density = 0.125_R8P , & velocity = velocity , & pressure = 1._R8P , & partial_densities = [ 0.125_R8P / 2 , 0.125_R8P / 2 ]) velocity = 2._R8P primitive2 = primitive_compressible_multispecie ( density = 1._R8P , & velocity = velocity , & pressure = 1._R8P , & partial_densities = [ 1._R8P / 2 , 1._R8P / 2 ]) primitive3 = primitive1 - primitive2 test_passed ( 1 ) = primitive3 == ( primitive1 - primitive2 ) print \"(A,F6.3)\" , 'density   => 0.125  - 1   = ' , primitive3 % density print \"(A,3(F6.3,1X))\" , 'velocity  => 1      - 2   = ' , primitive3 % velocity print \"(A,F6.3)\" , 'pressure  => 1      - 1   = ' , primitive3 % pressure print \"(A,2(F7.4,1X))\" , 'densities => 0.0625 - 0.5 = ' , primitive3 % partial_densities ( 1 ), primitive3 % partial_densities ( 2 ) velocity = - 1._R8P primitive1 = primitive_compressible_multispecie ( density = 0.125_R8P , velocity = velocity , pressure = 1._R8P , & partial_densities = [ 0.125_R8P / 2 , 0.125_R8P / 2 ]) primitive2 = - primitive1 test_passed ( 2 ) = primitive2 == - primitive1 print \"(A,F6.3)\" , 'density   => - (0.125)  = ' , primitive2 % density print \"(A,3(F6.3,1X))\" , 'velocity  => - (-1)     = ' , primitive2 % velocity print \"(A,F6.3)\" , 'pressure  => - (1)      = ' , primitive2 % pressure print \"(A,2(F7.4,1X))\" , 'densities => - (0.0625) = ' , primitive2 % partial_densities print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram flow_test_primitive_compressible_multispecie_sub","tags":"","loc":"sourcefile/flow_test_primitive_compressible_multispecie_sub.f90.html","title":"flow_test_primitive_compressible_multispecie_sub.f90 – FLOw"},{"text":"FLOw test. This File Depends On sourcefile~~flow_test_primitive_compressible_not_eq.f90~~EfferentGraph sourcefile~flow_test_primitive_compressible_not_eq.f90 flow_test_primitive_compressible_not_eq.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_not_eq.f90 sourcefile~flow_eos_compressible.f90 flow_eos_compressible.f90 sourcefile~penf.f90->sourcefile~flow_eos_compressible.f90 sourcefile~flow_field_scalar_vectorial.f90 flow_field_scalar_vectorial.f90 sourcefile~penf.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~flow_primitive_object.f90 flow_primitive_object.f90 sourcefile~penf.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_conservative_compressible.f90 flow_conservative_compressible.f90 sourcefile~penf.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_primitive_compressible.f90 flow_primitive_compressible.f90 sourcefile~penf.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_conservative_object.f90 flow_conservative_object.f90 sourcefile~penf.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_primitive_compressible_multispecie.f90 flow_primitive_compressible_multispecie.f90 sourcefile~penf.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_eos_object.f90 flow_eos_object.f90 sourcefile~penf.f90->sourcefile~flow_eos_object.f90 sourcefile~flow_field_object.f90 flow_field_object.f90 sourcefile~penf.f90->sourcefile~flow_field_object.f90 sourcefile~flow_compressible_transformations.f90 flow_compressible_transformations.f90 sourcefile~penf.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow.f90 flow.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_not_eq.f90 sourcefile~vecfor.f90 vecfor.F90 sourcefile~vecfor.f90->sourcefile~flow_test_primitive_compressible_not_eq.f90 sourcefile~vecfor.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_object.f90 sourcefile~vecfor.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~vecfor.f90->sourcefile~flow_conservative_object.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~vecfor.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~flow_eos_compressible.f90->sourcefile~flow.f90 sourcefile~flow_field_scalar_vectorial.f90->sourcefile~flow.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_conservative_compressible.f90->sourcefile~flow.f90 sourcefile~flow_conservative_compressible.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_primitive_compressible.f90->sourcefile~flow.f90 sourcefile~flow_primitive_compressible.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_conservative_object.f90->sourcefile~flow.f90 sourcefile~flow_conservative_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_primitive_compressible_multispecie.f90->sourcefile~flow.f90 sourcefile~flow_eos_object.f90->sourcefile~flow.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_eos_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_field_object.f90->sourcefile~flow.f90 sourcefile~flow_field_object.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_field_object.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_compressible_transformations.f90->sourcefile~flow.f90 var pansourcefileflow_test_primitive_compressible_not_eqf90EfferentGraph = svgPanZoom('#sourcefileflow_test_primitive_compressible_not_eqf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs flow_test_primitive_compressible_not_eq Source Code flow_test_primitive_compressible_not_eq.f90 Source Code !< FLOw test. program flow_test_primitive_compressible_not_eq !< FLOw test. use flow , only : primitive_compressible use penf , only : R8P use vecfor , only : vector implicit none type ( primitive_compressible ) :: primitive1 !< A primitive object. type ( primitive_compressible ) :: primitive2 !< A primitive object. type ( vector ) :: velocity !< A vector object. logical :: test_passed ( 5 ) !< List of passed tests. test_passed = . false . velocity = 1._R8P primitive1 = primitive_compressible ( density = 0.125_R8P , velocity = velocity , pressure = 1._R8P ) velocity = 1._R8P primitive2 = primitive_compressible ( density = 1._R8P , velocity = velocity , pressure = 1._R8P ) test_passed ( 1 ) = ( primitive1 /= primitive2 ). eqv .(. true .) print \"(A,L1)\" , 'density  => 0.125 /= 1 = ' , test_passed ( 1 ) velocity = 1._R8P primitive1 = primitive_compressible ( density = 0.125_R8P , velocity = velocity , pressure = 1._R8P ) velocity = 2._R8P primitive2 = primitive_compressible ( density = 0.125_R8P , velocity = velocity , pressure = 1._R8P ) test_passed ( 2 ) = ( primitive1 /= primitive2 ). eqv .(. true .) print \"(A,L1)\" , 'velocity => 1     /= 2 = ' , test_passed ( 2 ) velocity = 1._R8P primitive1 = primitive_compressible ( density = 0.125_R8P , velocity = velocity , pressure = 1._R8P ) velocity = 2._R8P primitive2 = primitive_compressible ( density = 0.125_R8P , velocity = velocity , pressure = 2._R8P ) test_passed ( 3 ) = ( primitive1 /= primitive2 ). eqv .(. true .) print \"(A,L1)\" , 'pressure => 1     /= 2 = ' , test_passed ( 3 ) velocity = 1._R8P primitive1 = primitive_compressible ( density = 0.125_R8P , velocity = velocity , pressure = 1._R8P ) velocity = 2._R8P primitive2 = primitive_compressible ( density = 1._R8P , velocity = velocity , pressure = 2._R8P ) test_passed ( 4 ) = ( primitive1 /= primitive2 ). eqv .(. true .) print \"(A)\" , new_line ( 'a' ) // 'all together' print \"(A,L1)\" , 'density  => 0.125 /= 1 = ' , test_passed ( 4 ) print \"(A,L1)\" , 'velocity => 1     /= 2 = ' , test_passed ( 4 ) print \"(A,L1)\" , 'pressure => 1     /= 2 = ' , test_passed ( 4 ) velocity = 1._R8P primitive1 = primitive_compressible ( density = 1._R8P , velocity = velocity , pressure = 1._R8P ) velocity = 1._R8P primitive2 = primitive_compressible ( density = 1._R8P , velocity = velocity , pressure = 1._R8P ) test_passed ( 5 ) = ( primitive1 /= primitive2 ). eqv .(. false .) print \"(A)\" , new_line ( 'a' ) // 'all together' print \"(A,L1)\" , 'density  => 0.125 /= 1 = ' , test_passed ( 5 ) print \"(A,L1)\" , 'velocity => 1     /= 2 = ' , test_passed ( 5 ) print \"(A,L1)\" , 'pressure => 1     /= 2 = ' , test_passed ( 5 ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram flow_test_primitive_compressible_not_eq","tags":"","loc":"sourcefile/flow_test_primitive_compressible_not_eq.f90.html","title":"flow_test_primitive_compressible_not_eq.f90 – FLOw"},{"text":"FLOw test. This File Depends On sourcefile~~flow_test_primitive_compressible_pow.f90~~EfferentGraph sourcefile~flow_test_primitive_compressible_pow.f90 flow_test_primitive_compressible_pow.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_pow.f90 sourcefile~flow_eos_compressible.f90 flow_eos_compressible.f90 sourcefile~penf.f90->sourcefile~flow_eos_compressible.f90 sourcefile~flow_field_scalar_vectorial.f90 flow_field_scalar_vectorial.f90 sourcefile~penf.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~flow_primitive_object.f90 flow_primitive_object.f90 sourcefile~penf.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_conservative_compressible.f90 flow_conservative_compressible.f90 sourcefile~penf.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_primitive_compressible.f90 flow_primitive_compressible.f90 sourcefile~penf.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_conservative_object.f90 flow_conservative_object.f90 sourcefile~penf.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_primitive_compressible_multispecie.f90 flow_primitive_compressible_multispecie.f90 sourcefile~penf.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_eos_object.f90 flow_eos_object.f90 sourcefile~penf.f90->sourcefile~flow_eos_object.f90 sourcefile~flow_field_object.f90 flow_field_object.f90 sourcefile~penf.f90->sourcefile~flow_field_object.f90 sourcefile~flow_compressible_transformations.f90 flow_compressible_transformations.f90 sourcefile~penf.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow.f90 flow.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_pow.f90 sourcefile~vecfor.f90 vecfor.F90 sourcefile~vecfor.f90->sourcefile~flow_test_primitive_compressible_pow.f90 sourcefile~vecfor.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_object.f90 sourcefile~vecfor.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~vecfor.f90->sourcefile~flow_conservative_object.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~vecfor.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~flow_eos_compressible.f90->sourcefile~flow.f90 sourcefile~flow_field_scalar_vectorial.f90->sourcefile~flow.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_conservative_compressible.f90->sourcefile~flow.f90 sourcefile~flow_conservative_compressible.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_primitive_compressible.f90->sourcefile~flow.f90 sourcefile~flow_primitive_compressible.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_conservative_object.f90->sourcefile~flow.f90 sourcefile~flow_conservative_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_primitive_compressible_multispecie.f90->sourcefile~flow.f90 sourcefile~flow_eos_object.f90->sourcefile~flow.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_eos_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_field_object.f90->sourcefile~flow.f90 sourcefile~flow_field_object.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_field_object.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_compressible_transformations.f90->sourcefile~flow.f90 var pansourcefileflow_test_primitive_compressible_powf90EfferentGraph = svgPanZoom('#sourcefileflow_test_primitive_compressible_powf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs flow_test_primitive_compressible_add Source Code flow_test_primitive_compressible_pow.f90 Source Code !< FLOw test. program flow_test_primitive_compressible_add !< FLOw test. use flow , only : primitive_compressible use penf , only : I4P , R8P use vecfor , only : vector implicit none type ( primitive_compressible ) :: primitive1 !< A primitive object. type ( primitive_compressible ) :: primitive2 !< A primitive object. type ( vector ) :: velocity !< A vector object. logical :: test_passed ( 2 ) !< List of passed tests. test_passed = . false . velocity = 0.5_R8P primitive1 = primitive_compressible ( density = 0.125_R8P , velocity = velocity , pressure = 1._R8P ) primitive2 = primitive1 ** 2_I4P print \"(A,F6.3)\" , 'density  => 0.125 ** 2 = ' , primitive2 % density print \"(A,3(F6.3,1X))\" , 'velocity => 0.5   ** 2 = ' , primitive2 % velocity print \"(A,F6.3)\" , 'pressure => 1     ** 2 = ' , primitive2 % pressure test_passed ( 1 ) = primitive2 % density == ( 0.125_R8P ** 2_I4P ) velocity = 0.5_R8P primitive1 = primitive_compressible ( density = 0.125_R8P , velocity = velocity , pressure = 1._R8P ) primitive2 = primitive1 ** 2._R8P print \"(A,F6.3)\" , 'density  => 0.125 ** 2.0 = ' , primitive2 % density print \"(A,3(F6.3,1X))\" , 'velocity => 0.5   ** 2.0 = ' , primitive2 % velocity print \"(A,F6.3)\" , 'pressure => 1     ** 2.0 = ' , primitive2 % pressure test_passed ( 2 ) = primitive2 % density == ( 0.125_R8P ** 2._R8P ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram flow_test_primitive_compressible_add","tags":"","loc":"sourcefile/flow_test_primitive_compressible_pow.f90.html","title":"flow_test_primitive_compressible_pow.f90 – FLOw"},{"text":"FLOw test. This File Depends On sourcefile~~flow_test_primitive_compressible_sub.f90~~EfferentGraph sourcefile~flow_test_primitive_compressible_sub.f90 flow_test_primitive_compressible_sub.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_sub.f90 sourcefile~flow_eos_compressible.f90 flow_eos_compressible.f90 sourcefile~penf.f90->sourcefile~flow_eos_compressible.f90 sourcefile~flow_field_scalar_vectorial.f90 flow_field_scalar_vectorial.f90 sourcefile~penf.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~flow_primitive_object.f90 flow_primitive_object.f90 sourcefile~penf.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_conservative_compressible.f90 flow_conservative_compressible.f90 sourcefile~penf.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_primitive_compressible.f90 flow_primitive_compressible.f90 sourcefile~penf.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_conservative_object.f90 flow_conservative_object.f90 sourcefile~penf.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_primitive_compressible_multispecie.f90 flow_primitive_compressible_multispecie.f90 sourcefile~penf.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_eos_object.f90 flow_eos_object.f90 sourcefile~penf.f90->sourcefile~flow_eos_object.f90 sourcefile~flow_field_object.f90 flow_field_object.f90 sourcefile~penf.f90->sourcefile~flow_field_object.f90 sourcefile~flow_compressible_transformations.f90 flow_compressible_transformations.f90 sourcefile~penf.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow.f90 flow.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_sub.f90 sourcefile~vecfor.f90 vecfor.F90 sourcefile~vecfor.f90->sourcefile~flow_test_primitive_compressible_sub.f90 sourcefile~vecfor.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_object.f90 sourcefile~vecfor.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~vecfor.f90->sourcefile~flow_conservative_object.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~vecfor.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~flow_eos_compressible.f90->sourcefile~flow.f90 sourcefile~flow_field_scalar_vectorial.f90->sourcefile~flow.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_conservative_compressible.f90->sourcefile~flow.f90 sourcefile~flow_conservative_compressible.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_primitive_compressible.f90->sourcefile~flow.f90 sourcefile~flow_primitive_compressible.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_conservative_object.f90->sourcefile~flow.f90 sourcefile~flow_conservative_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_primitive_compressible_multispecie.f90->sourcefile~flow.f90 sourcefile~flow_eos_object.f90->sourcefile~flow.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_eos_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_field_object.f90->sourcefile~flow.f90 sourcefile~flow_field_object.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_field_object.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_compressible_transformations.f90->sourcefile~flow.f90 var pansourcefileflow_test_primitive_compressible_subf90EfferentGraph = svgPanZoom('#sourcefileflow_test_primitive_compressible_subf90EfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Programs flow_test_primitive_compressible_sub Source Code flow_test_primitive_compressible_sub.f90 Source Code !< FLOw test. program flow_test_primitive_compressible_sub !< FLOw test. use flow , only : primitive_compressible use penf , only : R8P use vecfor , only : vector implicit none type ( primitive_compressible ) :: primitive1 !< A primitive object. type ( primitive_compressible ) :: primitive2 !< A primitive object. type ( primitive_compressible ) :: primitive3 !< A primitive object. type ( vector ) :: velocity !< A vector object. logical :: test_passed ( 2 ) !< List of passed tests. test_passed = . false . velocity = 1._R8P primitive1 = primitive_compressible ( density = 0.125_R8P , velocity = velocity , pressure = 1._R8P ) velocity = 2._R8P primitive2 = primitive_compressible ( density = 1._R8P , velocity = velocity , pressure = 1._R8P ) primitive3 = primitive1 - primitive2 test_passed ( 1 ) = primitive3 == ( primitive1 - primitive2 ) print \"(A,F6.3)\" , 'density   => 0.125  - 1   = ' , primitive3 % density print \"(A,3(F6.3,1X))\" , 'velocity  => 1      - 2   = ' , primitive3 % velocity print \"(A,F6.3)\" , 'pressure  => 1      - 1   = ' , primitive3 % pressure velocity = - 1._R8P primitive1 = primitive_compressible ( density = 0.125_R8P , velocity = velocity , pressure = 1._R8P ) primitive2 = - primitive1 test_passed ( 2 ) = primitive2 == - primitive1 print \"(A,F6.3)\" , 'density   => - (0.125) = ' , primitive2 % density print \"(A,3(F6.3,1X))\" , 'velocity  => - (-1)    = ' , primitive2 % velocity print \"(A,F6.3)\" , 'pressure  => - (1)     = ' , primitive2 % pressure print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram flow_test_primitive_compressible_sub","tags":"","loc":"sourcefile/flow_test_primitive_compressible_sub.f90.html","title":"flow_test_primitive_compressible_sub.f90 – FLOw"},{"text":"Portability Environment for Fortran poor people. This File Depends On sourcefile~~penf.f90~~EfferentGraph sourcefile~penf.f90 penf.F90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~penf.f90~~AfferentGraph sourcefile~penf.f90 penf.F90 sourcefile~flow_test_primitive_compressible_sub.f90 flow_test_primitive_compressible_sub.f90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_sub.f90 sourcefile~flow_test_conservative_compressible_assign.f90 flow_test_conservative_compressible_assign.f90 sourcefile~penf.f90->sourcefile~flow_test_conservative_compressible_assign.f90 sourcefile~flow_test_primitive_compressible_multispecie_not_eq.f90 flow_test_primitive_compressible_multispecie_not_eq.f90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_multispecie_not_eq.f90 sourcefile~flow_primitive_object.f90 flow_primitive_object.f90 sourcefile~penf.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_test_primitive_compressible_multispecie_add.f90 flow_test_primitive_compressible_multispecie_add.f90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_multispecie_add.f90 sourcefile~flow_test_primitive_compressible_multispecie_pow.f90 flow_test_primitive_compressible_multispecie_pow.f90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_multispecie_pow.f90 sourcefile~flow_test_conservative_compressible_div.f90 flow_test_conservative_compressible_div.f90 sourcefile~penf.f90->sourcefile~flow_test_conservative_compressible_div.f90 sourcefile~flow_test_conservative_compressible_eq.f90 flow_test_conservative_compressible_eq.f90 sourcefile~penf.f90->sourcefile~flow_test_conservative_compressible_eq.f90 sourcefile~flow_test_primitive_compressible_multispecie_assign.f90 flow_test_primitive_compressible_multispecie_assign.f90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_multispecie_assign.f90 sourcefile~flow_test_conservative_compressible_mul.f90 flow_test_conservative_compressible_mul.f90 sourcefile~penf.f90->sourcefile~flow_test_conservative_compressible_mul.f90 sourcefile~flow_test_conservative_compressible_not_eq.f90 flow_test_conservative_compressible_not_eq.f90 sourcefile~penf.f90->sourcefile~flow_test_conservative_compressible_not_eq.f90 sourcefile~flow_test_conservative_compressible_pow.f90 flow_test_conservative_compressible_pow.f90 sourcefile~penf.f90->sourcefile~flow_test_conservative_compressible_pow.f90 sourcefile~flow_test_conservative_compressible_sub.f90 flow_test_conservative_compressible_sub.f90 sourcefile~penf.f90->sourcefile~flow_test_conservative_compressible_sub.f90 sourcefile~flow_test_primitive_compressible_multispecie_sub.f90 flow_test_primitive_compressible_multispecie_sub.f90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_multispecie_sub.f90 sourcefile~flow_test_eos_compressible.f90 flow_test_eos_compressible.f90 sourcefile~penf.f90->sourcefile~flow_test_eos_compressible.f90 sourcefile~flow_test_primitive_compressible_add.f90 flow_test_primitive_compressible_add.f90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_add.f90 sourcefile~flow_test_primitive_compressible_multispecie_div.f90 flow_test_primitive_compressible_multispecie_div.f90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_multispecie_div.f90 sourcefile~flow_test_primitive_compressible_assign.f90 flow_test_primitive_compressible_assign.f90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_assign.f90 sourcefile~flow_test_primitive_compressible_div.f90 flow_test_primitive_compressible_div.f90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_div.f90 sourcefile~flow_test_primitive_compressible_eq.f90 flow_test_primitive_compressible_eq.f90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_eq.f90 sourcefile~flow_test_compressible_transformations.f90 flow_test_compressible_transformations.f90 sourcefile~penf.f90->sourcefile~flow_test_compressible_transformations.f90 sourcefile~flow_test_primitive_compressible_not_eq.f90 flow_test_primitive_compressible_not_eq.f90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_not_eq.f90 sourcefile~flow_test_conservative_compressible_add.f90 flow_test_conservative_compressible_add.f90 sourcefile~penf.f90->sourcefile~flow_test_conservative_compressible_add.f90 sourcefile~flow_compressible_transformations.f90 flow_compressible_transformations.f90 sourcefile~penf.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_test_primitive_compressible_multispecie_eq.f90 flow_test_primitive_compressible_multispecie_eq.f90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_multispecie_eq.f90 sourcefile~flow_eos_compressible.f90 flow_eos_compressible.f90 sourcefile~penf.f90->sourcefile~flow_eos_compressible.f90 sourcefile~flow_field_scalar_vectorial.f90 flow_field_scalar_vectorial.f90 sourcefile~penf.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~flow_conservative_compressible.f90 flow_conservative_compressible.f90 sourcefile~penf.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_primitive_compressible.f90 flow_primitive_compressible.f90 sourcefile~penf.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_test_primitive_compressible_pow.f90 flow_test_primitive_compressible_pow.f90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_pow.f90 sourcefile~flow_primitive_compressible_multispecie.f90 flow_primitive_compressible_multispecie.f90 sourcefile~penf.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_eos_object.f90 flow_eos_object.f90 sourcefile~penf.f90->sourcefile~flow_eos_object.f90 sourcefile~flow_test_primitive_compressible_multispecie_mul.f90 flow_test_primitive_compressible_multispecie_mul.f90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_multispecie_mul.f90 sourcefile~flow_field_object.f90 flow_field_object.f90 sourcefile~penf.f90->sourcefile~flow_field_object.f90 sourcefile~flow_conservative_object.f90 flow_conservative_object.f90 sourcefile~penf.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_test_primitive_compressible_mul.f90 flow_test_primitive_compressible_mul.f90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_mul.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow.f90 flow.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow.f90 sourcefile~flow_compressible_transformations.f90->sourcefile~flow.f90 sourcefile~flow_eos_compressible.f90->sourcefile~flow.f90 sourcefile~flow_field_scalar_vectorial.f90->sourcefile~flow.f90 sourcefile~flow_conservative_compressible.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_conservative_compressible.f90->sourcefile~flow.f90 sourcefile~flow_primitive_compressible.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_primitive_compressible.f90->sourcefile~flow.f90 sourcefile~flow_primitive_compressible_multispecie.f90->sourcefile~flow.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_eos_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_eos_object.f90->sourcefile~flow.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~flow_field_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_field_object.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow.f90 sourcefile~flow_conservative_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_conservative_object.f90->sourcefile~flow.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_sub.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_assign.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_not_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_add.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_pow.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_div.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_assign.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_mul.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_not_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_pow.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_sub.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_sub.f90 sourcefile~flow.f90->sourcefile~flow_test_eos_compressible.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_add.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_div.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_assign.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_div.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_compressible_transformations.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_not_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_add.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_pow.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_mul.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_mul.f90 var pansourcefilepenff90AfferentGraph = svgPanZoom('#sourcefilepenff90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules penf Source Code penf.F90 Source Code !< Portability Environment for Fortran poor people. module penf !----------------------------------------------------------------------------------------------------------------------------------- !< Portability Environment for Fortran poor people. !----------------------------------------------------------------------------------------------------------------------------------- use penf_global_parameters_variables #ifdef __GFORTRAN__ use penf_b_size , only : bit_size , byte_size #else use penf_b_size #endif use penf_stringify , only : str , strz , cton , bstr , bcton !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private save ! Global parameters and variables public :: endianL , endianB , endian , is_initialized public :: R16P , FR16P , DR16P , MinR16P , MaxR16P , BIR16P , BYR16P , smallR16P , ZeroR16 public :: R8P , FR8P , DR8P , MinR8P , MaxR8P , BIR8P , BYR8P , smallR8P , ZeroR8 public :: R4P , FR4P , DR4P , MinR4P , MaxR4P , BIR4P , BYR4P , smallR4P , ZeroR4 public :: R_P , FR_P , DR_P , MinR_P , MaxR_P , BIR_P , BYR_P , smallR_P , Zero public :: I8P , FI8P , DI8P , MinI8P , MaxI8P , BII8P , BYI8P public :: I4P , FI4P , DI4P , MinI4P , MaxI4P , BII4P , BYI4P public :: I2P , FI2P , DI2P , MinI2P , MaxI2P , BII2P , BYI2P public :: I1P , FI1P , DI1P , MinI1P , MaxI1P , BII1P , BYI1P public :: I_P , FI_P , DI_P , MinI_P , MaxI_P , BII_P , BYI_P public :: REAL_KINDS_LIST , REAL_FORMATS_LIST public :: INTEGER_KINDS_LIST , INTEGER_FORMATS_LIST ! Bit/byte size functions public :: bit_size , byte_size ! Stringify facility public :: str , strz , cton public :: bstr , bcton ! Miscellanea facility public :: check_endian public :: digit public :: penf_Init public :: penf_print !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- #ifdef __GFORTRAN__ ! work-around for strange gfortran bug... interface bit_size !< Overloading of the intrinsic *bit_size* function for computing the number of bits of (also) real and character variables. endinterface #endif !----------------------------------------------------------------------------------------------------------------------------------- interface digit !< Compute the number of digits in decimal base of the input integer. module procedure digit_I8 , digit_I4 , digit_I2 , digit_I1 endinterface !----------------------------------------------------------------------------------------------------------------------------------- contains subroutine check_endian () !--------------------------------------------------------------------------------------------------------------------------------- !< Check the type of bit ordering (big or little endian) of the running architecture. !< !> @note The result is stored into the *endian* global variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( is_little_endian ()) then endian = endianL else endian = endianB endif return !--------------------------------------------------------------------------------------------------------------------------------- contains pure function is_little_endian () result ( is_little ) !------------------------------------------------------------------------------------------------------------------------------- !< Check if the type of the bit ordering of the running architecture is little endian. !------------------------------------------------------------------------------------------------------------------------------- logical :: is_little !< Logical output: true is the running architecture uses little endian ordering, false otherwise. integer ( I1P ) :: int1 ( 1 : 4 ) !< One byte integer array for casting 4 bytes integer. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- int1 = transfer ( 1_I4P , int1 ) is_little = ( int1 ( 1 ) == 1_I1P ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction is_little_endian endsubroutine check_endian elemental function digit_I8 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Input integer. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I8 elemental function digit_I4 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Input integer. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I4 elemental function digit_I2 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Input integer. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I2 elemental function digit_I1 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Input integer. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I1 subroutine penf_init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize PENF's variables that are not initialized into the definition specification. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call check_endian BIR8P = bit_size ( MaxR8P ) ; BYR8P = BIR8P / 8_I1P BIR4P = bit_size ( MaxR4P ) ; BYR4P = BIR4P / 8_I1P BIR_P = bit_size ( MaxR_P ) ; BYR_P = BIR_P / 8_I1P #ifdef r16p BIR16P = bit_size ( MaxR16P ) ; BYR16P = BIR16P / 8_I2P #else BIR16P = int ( BIR8P , kind = I2P ) ; BYR16P = BIR16P / 8_I2P #endif is_initialized = . true . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine penf_init subroutine penf_print ( unit , pref , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Print to the specified unit the PENF's environment data. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: unit !< Logic unit. character ( * ), intent ( in ), optional :: pref !< Prefixing string. integer ( I4P ), intent ( out ), optional :: iostat !< IO error. character ( * ), intent ( out ), optional :: iomsg !< IO error message. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< Temporary variable for IO error message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . is_initialized ) call penf_init prefd = '' ; if ( present ( pref )) prefd = pref if ( endian == endianL ) then write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' This architecture has LITTLE Endian bit ordering' else write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' This architecture has BIG Endian bit ordering' endif write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals kind, format and characters number:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = R16P ) // ',' // FR16P // ',' // str ( n = DR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = R8P ) // ',' // FR8P // ',' // str ( n = DR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = R4P ) // ',' // FR4P // ',' // str ( n = DR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integers kind, format and characters number:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = I8P ) // ',' // FI8P // ',' // str ( n = DI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = I4P ) // ',' // FI4P // ',' // str ( n = DI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = I2P ) // ',' // FI2P // ',' // str ( n = DI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = I1P ) // ',' // FI1P // ',' // str ( n = DI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals minimum and maximum values:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = MinR16P ) // ',' // str ( n = MaxR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = MinR8P ) // ',' // str ( n = MaxR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = MinR4P ) // ',' // str ( n = MaxR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integergs minimum and maximum values:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = MinI8P ) // ',' // str ( n = MaxI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = MinI4P ) // ',' // str ( n = MaxI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = MinI2P ) // ',' // str ( n = MaxI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = MinI1P ) // ',' // str ( n = MaxI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals bits/bytes sizes:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = BIR16P ) // '/' // str ( n = BYR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = BIR8P ) // '/' // str ( n = BYR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = BIR4P ) // '/' // str ( n = BYR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integers bits/bytes sizes:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = BII8P ) // '/' // str ( n = BYI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = BII4P ) // '/' // str ( n = BYI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = BII2P ) // '/' // str ( n = BYI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = BII1P ) // '/' // str ( n = BYI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Machine precisions' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR16: ' // str ( ZeroR16 ,. true .) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR8:  ' // str ( ZeroR8 ,. true .) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR4:  ' // str ( ZeroR4 ,. true .) if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = iomsgd return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine penf_print endmodule penf","tags":"","loc":"sourcefile/penf.f90.html","title":"penf.F90 – FLOw"},{"text":"This File Depends On sourcefile~~penf_b_size.f90~~EfferentGraph sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~penf_b_size.f90~~AfferentGraph sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~flow_test_primitive_compressible_sub.f90 flow_test_primitive_compressible_sub.f90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_sub.f90 sourcefile~flow_test_conservative_compressible_assign.f90 flow_test_conservative_compressible_assign.f90 sourcefile~penf.f90->sourcefile~flow_test_conservative_compressible_assign.f90 sourcefile~flow_test_primitive_compressible_multispecie_not_eq.f90 flow_test_primitive_compressible_multispecie_not_eq.f90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_multispecie_not_eq.f90 sourcefile~flow_primitive_object.f90 flow_primitive_object.f90 sourcefile~penf.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_test_primitive_compressible_multispecie_add.f90 flow_test_primitive_compressible_multispecie_add.f90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_multispecie_add.f90 sourcefile~flow_test_primitive_compressible_multispecie_pow.f90 flow_test_primitive_compressible_multispecie_pow.f90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_multispecie_pow.f90 sourcefile~flow_test_conservative_compressible_div.f90 flow_test_conservative_compressible_div.f90 sourcefile~penf.f90->sourcefile~flow_test_conservative_compressible_div.f90 sourcefile~flow_test_conservative_compressible_eq.f90 flow_test_conservative_compressible_eq.f90 sourcefile~penf.f90->sourcefile~flow_test_conservative_compressible_eq.f90 sourcefile~flow_test_primitive_compressible_multispecie_assign.f90 flow_test_primitive_compressible_multispecie_assign.f90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_multispecie_assign.f90 sourcefile~flow_test_conservative_compressible_mul.f90 flow_test_conservative_compressible_mul.f90 sourcefile~penf.f90->sourcefile~flow_test_conservative_compressible_mul.f90 sourcefile~flow_test_conservative_compressible_not_eq.f90 flow_test_conservative_compressible_not_eq.f90 sourcefile~penf.f90->sourcefile~flow_test_conservative_compressible_not_eq.f90 sourcefile~flow_test_conservative_compressible_pow.f90 flow_test_conservative_compressible_pow.f90 sourcefile~penf.f90->sourcefile~flow_test_conservative_compressible_pow.f90 sourcefile~flow_test_conservative_compressible_sub.f90 flow_test_conservative_compressible_sub.f90 sourcefile~penf.f90->sourcefile~flow_test_conservative_compressible_sub.f90 sourcefile~flow_test_primitive_compressible_multispecie_sub.f90 flow_test_primitive_compressible_multispecie_sub.f90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_multispecie_sub.f90 sourcefile~flow_test_eos_compressible.f90 flow_test_eos_compressible.f90 sourcefile~penf.f90->sourcefile~flow_test_eos_compressible.f90 sourcefile~flow_test_primitive_compressible_add.f90 flow_test_primitive_compressible_add.f90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_add.f90 sourcefile~flow_test_primitive_compressible_multispecie_div.f90 flow_test_primitive_compressible_multispecie_div.f90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_multispecie_div.f90 sourcefile~flow_test_primitive_compressible_assign.f90 flow_test_primitive_compressible_assign.f90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_assign.f90 sourcefile~flow_test_primitive_compressible_div.f90 flow_test_primitive_compressible_div.f90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_div.f90 sourcefile~flow_test_primitive_compressible_eq.f90 flow_test_primitive_compressible_eq.f90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_eq.f90 sourcefile~flow_test_compressible_transformations.f90 flow_test_compressible_transformations.f90 sourcefile~penf.f90->sourcefile~flow_test_compressible_transformations.f90 sourcefile~flow_test_primitive_compressible_not_eq.f90 flow_test_primitive_compressible_not_eq.f90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_not_eq.f90 sourcefile~flow_test_conservative_compressible_add.f90 flow_test_conservative_compressible_add.f90 sourcefile~penf.f90->sourcefile~flow_test_conservative_compressible_add.f90 sourcefile~flow_compressible_transformations.f90 flow_compressible_transformations.f90 sourcefile~penf.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_test_primitive_compressible_multispecie_eq.f90 flow_test_primitive_compressible_multispecie_eq.f90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_multispecie_eq.f90 sourcefile~flow_eos_compressible.f90 flow_eos_compressible.f90 sourcefile~penf.f90->sourcefile~flow_eos_compressible.f90 sourcefile~flow_field_scalar_vectorial.f90 flow_field_scalar_vectorial.f90 sourcefile~penf.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~flow_conservative_compressible.f90 flow_conservative_compressible.f90 sourcefile~penf.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_primitive_compressible.f90 flow_primitive_compressible.f90 sourcefile~penf.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_test_primitive_compressible_pow.f90 flow_test_primitive_compressible_pow.f90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_pow.f90 sourcefile~flow_primitive_compressible_multispecie.f90 flow_primitive_compressible_multispecie.f90 sourcefile~penf.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_eos_object.f90 flow_eos_object.f90 sourcefile~penf.f90->sourcefile~flow_eos_object.f90 sourcefile~flow_test_primitive_compressible_multispecie_mul.f90 flow_test_primitive_compressible_multispecie_mul.f90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_multispecie_mul.f90 sourcefile~flow_field_object.f90 flow_field_object.f90 sourcefile~penf.f90->sourcefile~flow_field_object.f90 sourcefile~flow_conservative_object.f90 flow_conservative_object.f90 sourcefile~penf.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_test_primitive_compressible_mul.f90 flow_test_primitive_compressible_mul.f90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_mul.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow.f90 flow.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow.f90 sourcefile~flow_compressible_transformations.f90->sourcefile~flow.f90 sourcefile~flow_eos_compressible.f90->sourcefile~flow.f90 sourcefile~flow_field_scalar_vectorial.f90->sourcefile~flow.f90 sourcefile~flow_conservative_compressible.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_conservative_compressible.f90->sourcefile~flow.f90 sourcefile~flow_primitive_compressible.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_primitive_compressible.f90->sourcefile~flow.f90 sourcefile~flow_primitive_compressible_multispecie.f90->sourcefile~flow.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_eos_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_eos_object.f90->sourcefile~flow.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~flow_field_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_field_object.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow.f90 sourcefile~flow_conservative_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_conservative_object.f90->sourcefile~flow.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_sub.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_assign.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_not_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_add.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_pow.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_div.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_assign.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_mul.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_not_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_pow.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_sub.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_sub.f90 sourcefile~flow.f90->sourcefile~flow_test_eos_compressible.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_add.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_div.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_assign.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_div.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_compressible_transformations.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_not_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_add.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_pow.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_mul.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_mul.f90 var pansourcefilepenf_b_sizef90AfferentGraph = svgPanZoom('#sourcefilepenf_b_sizef90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules penf_b_size Source Code penf_b_size.F90 Source Code module penf_b_size !----------------------------------------------------------------------------------------------------------------------------------- !< PENF bit/byte size functions. !----------------------------------------------------------------------------------------------------------------------------------- use penf_global_parameters_variables !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private save public :: bit_size , byte_size !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface bit_size !< Overloading of the intrinsic *bit_size* function for computing the number of bits of (also) real and character variables. module procedure & #ifdef r16p bit_size_R16P , & #endif bit_size_R8P , & bit_size_R4P , & bit_size_chr endinterface !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface byte_size !< Compute the number of bytes of a variable. module procedure & byte_size_I8P , & byte_size_I4P , & byte_size_I2P , & byte_size_I1P , & #ifdef r16p byte_size_R16p , & #endif byte_size_R8P , & byte_size_R4P , & byte_size_chr endinterface !----------------------------------------------------------------------------------------------------------------------------------- contains elemental function bit_size_R16P ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I2P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I2P ) * 8_I2P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R16P elemental function bit_size_R8P ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I1P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I1P ) * 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R8P elemental function bit_size_R4P ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I1P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I1P ) * 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R4P elemental function bit_size_chr ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a character variable. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: i !< Character variable whose number of bits must be computed. integer ( I4P ) :: bits !< Number of bits of c. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I4P ) * 8_I4P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_chr elemental function byte_size_I8P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I8P elemental function byte_size_I4P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I4P elemental function byte_size_I2P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I2P elemental function byte_size_I1P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I1P elemental function byte_size_R16P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R16P elemental function byte_size_R8P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R8P elemental function byte_size_R4P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R4P elemental function byte_size_chr ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a character variable. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: i !< Character variable whose number of bytes must be computed. integer ( I4P ) :: bytes !< Number of bytes of c. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I4P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_chr endmodule penf_b_size","tags":"","loc":"sourcefile/penf_b_size.f90.html","title":"penf_b_size.F90 – FLOw"},{"text":"Files Dependent On This One sourcefile~~penf_global_parameters_variables.f90~~AfferentGraph sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 sourcefile~penf.f90 penf.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf.f90 sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_b_size.f90->sourcefile~penf.f90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~flow_test_primitive_compressible_sub.f90 flow_test_primitive_compressible_sub.f90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_sub.f90 sourcefile~flow_test_conservative_compressible_assign.f90 flow_test_conservative_compressible_assign.f90 sourcefile~penf.f90->sourcefile~flow_test_conservative_compressible_assign.f90 sourcefile~flow_test_primitive_compressible_multispecie_not_eq.f90 flow_test_primitive_compressible_multispecie_not_eq.f90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_multispecie_not_eq.f90 sourcefile~flow_primitive_object.f90 flow_primitive_object.f90 sourcefile~penf.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_test_primitive_compressible_multispecie_add.f90 flow_test_primitive_compressible_multispecie_add.f90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_multispecie_add.f90 sourcefile~flow_test_primitive_compressible_multispecie_pow.f90 flow_test_primitive_compressible_multispecie_pow.f90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_multispecie_pow.f90 sourcefile~flow_test_conservative_compressible_div.f90 flow_test_conservative_compressible_div.f90 sourcefile~penf.f90->sourcefile~flow_test_conservative_compressible_div.f90 sourcefile~flow_test_conservative_compressible_eq.f90 flow_test_conservative_compressible_eq.f90 sourcefile~penf.f90->sourcefile~flow_test_conservative_compressible_eq.f90 sourcefile~flow_test_primitive_compressible_multispecie_assign.f90 flow_test_primitive_compressible_multispecie_assign.f90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_multispecie_assign.f90 sourcefile~flow_test_conservative_compressible_mul.f90 flow_test_conservative_compressible_mul.f90 sourcefile~penf.f90->sourcefile~flow_test_conservative_compressible_mul.f90 sourcefile~flow_test_conservative_compressible_not_eq.f90 flow_test_conservative_compressible_not_eq.f90 sourcefile~penf.f90->sourcefile~flow_test_conservative_compressible_not_eq.f90 sourcefile~flow_test_conservative_compressible_pow.f90 flow_test_conservative_compressible_pow.f90 sourcefile~penf.f90->sourcefile~flow_test_conservative_compressible_pow.f90 sourcefile~flow_test_conservative_compressible_sub.f90 flow_test_conservative_compressible_sub.f90 sourcefile~penf.f90->sourcefile~flow_test_conservative_compressible_sub.f90 sourcefile~flow_test_primitive_compressible_multispecie_sub.f90 flow_test_primitive_compressible_multispecie_sub.f90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_multispecie_sub.f90 sourcefile~flow_test_eos_compressible.f90 flow_test_eos_compressible.f90 sourcefile~penf.f90->sourcefile~flow_test_eos_compressible.f90 sourcefile~flow_test_primitive_compressible_add.f90 flow_test_primitive_compressible_add.f90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_add.f90 sourcefile~flow_test_primitive_compressible_multispecie_div.f90 flow_test_primitive_compressible_multispecie_div.f90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_multispecie_div.f90 sourcefile~flow_test_primitive_compressible_assign.f90 flow_test_primitive_compressible_assign.f90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_assign.f90 sourcefile~flow_test_primitive_compressible_div.f90 flow_test_primitive_compressible_div.f90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_div.f90 sourcefile~flow_test_primitive_compressible_eq.f90 flow_test_primitive_compressible_eq.f90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_eq.f90 sourcefile~flow_test_compressible_transformations.f90 flow_test_compressible_transformations.f90 sourcefile~penf.f90->sourcefile~flow_test_compressible_transformations.f90 sourcefile~flow_test_primitive_compressible_not_eq.f90 flow_test_primitive_compressible_not_eq.f90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_not_eq.f90 sourcefile~flow_test_conservative_compressible_add.f90 flow_test_conservative_compressible_add.f90 sourcefile~penf.f90->sourcefile~flow_test_conservative_compressible_add.f90 sourcefile~flow_compressible_transformations.f90 flow_compressible_transformations.f90 sourcefile~penf.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_test_primitive_compressible_multispecie_eq.f90 flow_test_primitive_compressible_multispecie_eq.f90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_multispecie_eq.f90 sourcefile~flow_eos_compressible.f90 flow_eos_compressible.f90 sourcefile~penf.f90->sourcefile~flow_eos_compressible.f90 sourcefile~flow_field_scalar_vectorial.f90 flow_field_scalar_vectorial.f90 sourcefile~penf.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~flow_conservative_compressible.f90 flow_conservative_compressible.f90 sourcefile~penf.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_primitive_compressible.f90 flow_primitive_compressible.f90 sourcefile~penf.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_test_primitive_compressible_pow.f90 flow_test_primitive_compressible_pow.f90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_pow.f90 sourcefile~flow_primitive_compressible_multispecie.f90 flow_primitive_compressible_multispecie.f90 sourcefile~penf.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_eos_object.f90 flow_eos_object.f90 sourcefile~penf.f90->sourcefile~flow_eos_object.f90 sourcefile~flow_test_primitive_compressible_multispecie_mul.f90 flow_test_primitive_compressible_multispecie_mul.f90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_multispecie_mul.f90 sourcefile~flow_field_object.f90 flow_field_object.f90 sourcefile~penf.f90->sourcefile~flow_field_object.f90 sourcefile~flow_conservative_object.f90 flow_conservative_object.f90 sourcefile~penf.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_test_primitive_compressible_mul.f90 flow_test_primitive_compressible_mul.f90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_mul.f90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow.f90 flow.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow.f90 sourcefile~flow_compressible_transformations.f90->sourcefile~flow.f90 sourcefile~flow_eos_compressible.f90->sourcefile~flow.f90 sourcefile~flow_field_scalar_vectorial.f90->sourcefile~flow.f90 sourcefile~flow_conservative_compressible.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_conservative_compressible.f90->sourcefile~flow.f90 sourcefile~flow_primitive_compressible.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_primitive_compressible.f90->sourcefile~flow.f90 sourcefile~flow_primitive_compressible_multispecie.f90->sourcefile~flow.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_eos_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_eos_object.f90->sourcefile~flow.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~flow_field_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_field_object.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow.f90 sourcefile~flow_conservative_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_conservative_object.f90->sourcefile~flow.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_sub.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_assign.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_not_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_add.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_pow.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_div.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_assign.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_mul.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_not_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_pow.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_sub.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_sub.f90 sourcefile~flow.f90->sourcefile~flow_test_eos_compressible.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_add.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_div.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_assign.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_div.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_compressible_transformations.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_not_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_add.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_pow.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_mul.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_mul.f90 var pansourcefilepenf_global_parameters_variablesf90AfferentGraph = svgPanZoom('#sourcefilepenf_global_parameters_variablesf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules penf_global_parameters_variables Source Code penf_global_parameters_variables.F90 Source Code module penf_global_parameters_variables !----------------------------------------------------------------------------------------------------------------------------------- !< PENF global (exposed) parameters and variables. !< !< @note All module defined entities are public. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none public save !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- logical :: is_initialized = . false . !< Check the initialization of some variables that must be initialized. integer , parameter :: endianL = 1 !< Little endian parameter. integer , parameter :: endianB = 0 !< Big endian parameter. integer :: endian = endianL !< Bit ordering: Little endian (endianL), or Big endian (endianB). !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Portable kind parameters #ifdef r16p integer , parameter :: R16P = selected_real_kind ( 33 , 4931 ) !< 33 digits, range [10&#94;{-4931}, 10&#94;{+4931} - 1]; 128 bits. #else integer , parameter :: R16P = selected_real_kind ( 15 , 307 ) !< Defined as R8P; 64 bits. #endif integer , parameter :: R8P = selected_real_kind ( 15 , 307 ) !< 15 digits, range [10&#94;{-307} , 10&#94;{+307}  - 1]; 64 bits. integer , parameter :: R4P = selected_real_kind ( 6 , 37 ) !< 6  digits, range [10&#94;{-37}  , 10&#94;{+37}   - 1]; 32 bits. integer , parameter :: R_P = R8P !< Default real precision. integer , parameter :: I8P = selected_int_kind ( 18 ) !< Range [-2&#94;{63},+2&#94;{63} - 1], 19 digits plus sign; 64 bits. integer , parameter :: I4P = selected_int_kind ( 9 ) !< Range [-2&#94;{31},+2&#94;{31} - 1], 10 digits plus sign; 32 bits. integer , parameter :: I2P = selected_int_kind ( 4 ) !< Range [-2&#94;{15},+2&#94;{15} - 1], 5  digits plus sign; 16 bits. integer , parameter :: I1P = selected_int_kind ( 2 ) !< Range [-2&#94;{7} ,+2&#94;{7}  - 1], 3  digits plus sign; 8  bits. integer , parameter :: I_P = I4P !< Default integer precision. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Format parameters #ifdef r16p character ( * ), parameter :: FR16P = '(E42.33E4)' !< Output format for kind=R16P real. #else character ( * ), parameter :: FR16P = '(E23.15E3)' !< Output format for kind=R16P real. #endif character ( * ), parameter :: FR8P = '(E23.15E3)' !< Output format for kind=R8P real. character ( * ), parameter :: FR4P = '(E13.6E2)' !< Output format for kind=R4P real. character ( * ), parameter :: FR_P = FR8P !< Output format for kind=R_P real. character ( * ), parameter :: FI8P = '(I20)' !< Output format for kind=I8P integer. character ( * ), parameter :: FI8PZP = '(I20.19)' !< Output format for kind=I8P integer with zero prefixing. character ( * ), parameter :: FI4P = '(I11)' !< Output format for kind=I4P integer. character ( * ), parameter :: FI4PZP = '(I11.10)' !< Output format for kind=I4P integer with zero prefixing. character ( * ), parameter :: FI2P = '(I6)' !< Output format for kind=I2P integer. character ( * ), parameter :: FI2PZP = '(I6.5)' !< Output format for kind=I2P integer with zero prefixing. character ( * ), parameter :: FI1P = '(I4)' !< Output format for kind=I1P integer. character ( * ), parameter :: FI1PZP = '(I4.3)' !< Output format for kind=I1P integer with zero prefixing. character ( * ), parameter :: FI_P = FI4P !< Output format for kind=I_P integer. character ( * ), parameter :: FI_PZP = FI4PZP !< Output format for kind=I_P integer with zero prefixing. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Length (number of digits) of formatted numbers #ifdef r16p integer , parameter :: DR16P = 42 !< Number of digits of output format FR16P. #else integer , parameter :: DR16P = 23 !< Number of digits of output format FR16P. #endif integer , parameter :: DR8P = 23 !< Number of digits of output format FR8P. integer , parameter :: DR4P = 13 !< Number of digits of output format FR4P. integer , parameter :: DR_P = DR8P !< Number of digits of output format FR_P. integer , parameter :: DI8P = 20 !< Number of digits of output format I8P. integer , parameter :: DI4P = 11 !< Number of digits of output format I4P. integer , parameter :: DI2P = 6 !< Number of digits of output format I2P. integer , parameter :: DI1P = 4 !< Number of digits of output format I1P. integer , parameter :: DI_P = DI4P !< Number of digits of output format I_P. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! List of kinds integer , parameter :: REAL_KINDS_LIST ( 1 : 4 ) = [ R16P , R8P , R4P , R_P ] !< List of real kinds. character ( * ), parameter :: REAL_FORMATS_LIST ( 1 : 4 ) = [ FR16P , FR8P , FR4P // ' ' , FR_P ] !< List of real formats. integer , parameter :: INTEGER_KINDS_LIST ( 1 : 5 ) = [ I8P , I4P , I2P , I1P , I_P ] !< List of integer kinds. character ( * ), parameter :: INTEGER_FORMATS_LIST ( 1 : 5 ) = [ FI8P , FI4P , FI2P // ' ' , FI1P // ' ' , FI_P ] !< List of integer formats. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Minimum and maximum (representable) values real ( R16P ), parameter :: MinR16P = - huge ( 1._R16P ) !< Minimum value of kind=R16P real. real ( R16P ), parameter :: MaxR16P = huge ( 1._R16P ) !< Maximum value of kind=R16P real. real ( R8P ), parameter :: MinR8P = - huge ( 1._R8P ) !< Minimum value of kind=R8P real. real ( R8P ), parameter :: MaxR8P = huge ( 1._R8P ) !< Maximum value of kind=R8P real. real ( R4P ), parameter :: MinR4P = - huge ( 1._R4P ) !< Minimum value of kind=R4P real. real ( R4P ), parameter :: MaxR4P = huge ( 1._R4P ) !< Maximum value of kind=R4P real. real ( R_P ), parameter :: MinR_P = MinR8P !< Minimum value of kind=R_P real. real ( R_P ), parameter :: MaxR_P = MaxR8P !< Maximum value of kind=R_P real. integer ( I8P ), parameter :: MinI8P = - huge ( 1_I8P ) !< Minimum value of kind=I8P integer. integer ( I4P ), parameter :: MinI4P = - huge ( 1_I4P ) !< Minimum value of kind=I4P integer. integer ( I2P ), parameter :: MinI2P = - huge ( 1_I2P ) !< Minimum value of kind=I2P integer. integer ( I1P ), parameter :: MinI1P = - huge ( 1_I1P ) !< Minimum value of kind=I1P integer. integer ( I_P ), parameter :: MinI_P = MinI4P !< Minimum value of kind=I_P integer. integer ( I8P ), parameter :: MaxI8P = huge ( 1_I8P ) !< Maximum value of kind=I8P integer. integer ( I4P ), parameter :: MaxI4P = huge ( 1_I4P ) !< Maximum value of kind=I4P integer. integer ( I2P ), parameter :: MaxI2P = huge ( 1_I2P ) !< Maximum value of kind=I2P integer. integer ( I1P ), parameter :: MaxI1P = huge ( 1_I1P ) !< Maximum value of kind=I1P integer. integer ( I_P ), parameter :: MaxI_P = MaxI4P !< Maximum value of kind=I_P integer. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Real smallest (representable) values real ( R16P ), parameter :: smallR16P = tiny ( 1._R16P ) !< Smallest representable value of kind=R16P real. real ( R8P ), parameter :: smallR8P = tiny ( 1._R8P ) !< Smallest representable value of kind=R8P real. real ( R4P ), parameter :: smallR4P = tiny ( 1._R4P ) !< Smallest representable value of kind=R4P real. real ( R_P ), parameter :: smallR_P = smallR8P !< Smallest representable value of kind=R_P real. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Smallest real representable difference by the running calculator real ( R16P ), parameter :: ZeroR16 = nearest ( 1._R16P , 1._R16P ) - & nearest ( 1._R16P , - 1._R16P ) !< Smallest representable difference of kind=R16P real. real ( R8P ), parameter :: ZeroR8 = nearest ( 1._R8P , 1._R8P ) - & nearest ( 1._R8P , - 1._R8P ) !< Smallest representable difference of kind=R8P real. real ( R4P ), parameter :: ZeroR4 = nearest ( 1._R4P , 1._R4P ) - & nearest ( 1._R4P , - 1._R4P ) !< Smallest representable difference of kind=R4P real. real ( R_P ), parameter :: Zero = ZeroR8 !< Smallest representable difference of kind=R_P real. !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- ! Bits/bytes memory requirements (real variables must be computed at runtime) integer ( I2P ) :: BIR16P !< Number of bits of kind=R16P real. integer ( I1P ) :: BIR8P !< Number of bits of kind=R8P real. integer ( I1P ) :: BIR4P !< Number of bits of kind=R4P real. integer ( I1P ) :: BIR_P !< Number of bits of kind=R_P real. integer ( I2P ) :: BYR16P !< Number of bytes of kind=R16P real. integer ( I1P ) :: BYR8P !< Number of bytes of kind=R8P real. integer ( I1P ) :: BYR4P !< Number of bytes of kind=R4P real. integer ( I1P ) :: BYR_P !< Number of bytes of kind=R_P real. integer ( I8P ), parameter :: BII8P = bit_size ( MaxI8P ) !< Number of bits of kind=I8P integer. integer ( I4P ), parameter :: BII4P = bit_size ( MaxI4P ) !< Number of bits of kind=I4P integer. integer ( I2P ), parameter :: BII2P = bit_size ( MaxI2P ) !< Number of bits of kind=I2P integer. integer ( I1P ), parameter :: BII1P = bit_size ( MaxI1P ) !< Number of bits of kind=I1P integer. integer ( I_P ), parameter :: BII_P = bit_size ( MaxI_P ) !< Number of bits of kind=I_P integer. integer ( I8P ), parameter :: BYI8P = bit_size ( MaxI8P ) / 8_I8P !< Number of bytes of kind=I8P integer. integer ( I4P ), parameter :: BYI4P = bit_size ( MaxI4P ) / 8_I4P !< Number of bytes of kind=I4P integer. integer ( I2P ), parameter :: BYI2P = bit_size ( MaxI2P ) / 8_I2P !< Number of bytes of kind=I2P integer. integer ( I1P ), parameter :: BYI1P = bit_size ( MaxI1P ) / 8_I1P !< Number of bytes of kind=I1P integer. integer ( I_P ), parameter :: BYI_P = bit_size ( MaxI_P ) / 8_I_P !< Number of bytes of kind=I_P integer. !----------------------------------------------------------------------------------------------------------------------------------- endmodule penf_global_parameters_variables","tags":"","loc":"sourcefile/penf_global_parameters_variables.f90.html","title":"penf_global_parameters_variables.F90 – FLOw"},{"text":"This File Depends On sourcefile~~penf_stringify.f90~~EfferentGraph sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf_b_size.f90 penf_b_size.F90 sourcefile~penf_b_size.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90 penf_global_parameters_variables.F90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_stringify.f90 sourcefile~penf_global_parameters_variables.f90->sourcefile~penf_b_size.f90 Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Files Dependent On This One sourcefile~~penf_stringify.f90~~AfferentGraph sourcefile~penf_stringify.f90 penf_stringify.F90 sourcefile~penf.f90 penf.F90 sourcefile~penf_stringify.f90->sourcefile~penf.f90 sourcefile~flow_test_primitive_compressible_sub.f90 flow_test_primitive_compressible_sub.f90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_sub.f90 sourcefile~flow_test_conservative_compressible_assign.f90 flow_test_conservative_compressible_assign.f90 sourcefile~penf.f90->sourcefile~flow_test_conservative_compressible_assign.f90 sourcefile~flow_test_primitive_compressible_multispecie_not_eq.f90 flow_test_primitive_compressible_multispecie_not_eq.f90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_multispecie_not_eq.f90 sourcefile~flow_primitive_object.f90 flow_primitive_object.f90 sourcefile~penf.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_test_primitive_compressible_multispecie_add.f90 flow_test_primitive_compressible_multispecie_add.f90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_multispecie_add.f90 sourcefile~flow_test_primitive_compressible_multispecie_pow.f90 flow_test_primitive_compressible_multispecie_pow.f90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_multispecie_pow.f90 sourcefile~flow_test_conservative_compressible_div.f90 flow_test_conservative_compressible_div.f90 sourcefile~penf.f90->sourcefile~flow_test_conservative_compressible_div.f90 sourcefile~flow_test_conservative_compressible_eq.f90 flow_test_conservative_compressible_eq.f90 sourcefile~penf.f90->sourcefile~flow_test_conservative_compressible_eq.f90 sourcefile~flow_test_primitive_compressible_multispecie_assign.f90 flow_test_primitive_compressible_multispecie_assign.f90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_multispecie_assign.f90 sourcefile~flow_test_conservative_compressible_mul.f90 flow_test_conservative_compressible_mul.f90 sourcefile~penf.f90->sourcefile~flow_test_conservative_compressible_mul.f90 sourcefile~flow_test_conservative_compressible_not_eq.f90 flow_test_conservative_compressible_not_eq.f90 sourcefile~penf.f90->sourcefile~flow_test_conservative_compressible_not_eq.f90 sourcefile~flow_test_conservative_compressible_pow.f90 flow_test_conservative_compressible_pow.f90 sourcefile~penf.f90->sourcefile~flow_test_conservative_compressible_pow.f90 sourcefile~flow_test_conservative_compressible_sub.f90 flow_test_conservative_compressible_sub.f90 sourcefile~penf.f90->sourcefile~flow_test_conservative_compressible_sub.f90 sourcefile~flow_test_primitive_compressible_multispecie_sub.f90 flow_test_primitive_compressible_multispecie_sub.f90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_multispecie_sub.f90 sourcefile~flow_test_eos_compressible.f90 flow_test_eos_compressible.f90 sourcefile~penf.f90->sourcefile~flow_test_eos_compressible.f90 sourcefile~flow_test_primitive_compressible_add.f90 flow_test_primitive_compressible_add.f90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_add.f90 sourcefile~flow_test_primitive_compressible_multispecie_div.f90 flow_test_primitive_compressible_multispecie_div.f90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_multispecie_div.f90 sourcefile~flow_test_primitive_compressible_assign.f90 flow_test_primitive_compressible_assign.f90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_assign.f90 sourcefile~flow_test_primitive_compressible_div.f90 flow_test_primitive_compressible_div.f90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_div.f90 sourcefile~flow_test_primitive_compressible_eq.f90 flow_test_primitive_compressible_eq.f90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_eq.f90 sourcefile~flow_test_compressible_transformations.f90 flow_test_compressible_transformations.f90 sourcefile~penf.f90->sourcefile~flow_test_compressible_transformations.f90 sourcefile~flow_test_primitive_compressible_not_eq.f90 flow_test_primitive_compressible_not_eq.f90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_not_eq.f90 sourcefile~flow_test_conservative_compressible_add.f90 flow_test_conservative_compressible_add.f90 sourcefile~penf.f90->sourcefile~flow_test_conservative_compressible_add.f90 sourcefile~flow_compressible_transformations.f90 flow_compressible_transformations.f90 sourcefile~penf.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_test_primitive_compressible_multispecie_eq.f90 flow_test_primitive_compressible_multispecie_eq.f90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_multispecie_eq.f90 sourcefile~flow_eos_compressible.f90 flow_eos_compressible.f90 sourcefile~penf.f90->sourcefile~flow_eos_compressible.f90 sourcefile~flow_field_scalar_vectorial.f90 flow_field_scalar_vectorial.f90 sourcefile~penf.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~flow_conservative_compressible.f90 flow_conservative_compressible.f90 sourcefile~penf.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_primitive_compressible.f90 flow_primitive_compressible.f90 sourcefile~penf.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_test_primitive_compressible_pow.f90 flow_test_primitive_compressible_pow.f90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_pow.f90 sourcefile~flow_primitive_compressible_multispecie.f90 flow_primitive_compressible_multispecie.f90 sourcefile~penf.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_eos_object.f90 flow_eos_object.f90 sourcefile~penf.f90->sourcefile~flow_eos_object.f90 sourcefile~flow_test_primitive_compressible_multispecie_mul.f90 flow_test_primitive_compressible_multispecie_mul.f90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_multispecie_mul.f90 sourcefile~flow_field_object.f90 flow_field_object.f90 sourcefile~penf.f90->sourcefile~flow_field_object.f90 sourcefile~flow_conservative_object.f90 flow_conservative_object.f90 sourcefile~penf.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_test_primitive_compressible_mul.f90 flow_test_primitive_compressible_mul.f90 sourcefile~penf.f90->sourcefile~flow_test_primitive_compressible_mul.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow.f90 flow.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow.f90 sourcefile~flow_compressible_transformations.f90->sourcefile~flow.f90 sourcefile~flow_eos_compressible.f90->sourcefile~flow.f90 sourcefile~flow_field_scalar_vectorial.f90->sourcefile~flow.f90 sourcefile~flow_conservative_compressible.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_conservative_compressible.f90->sourcefile~flow.f90 sourcefile~flow_primitive_compressible.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_primitive_compressible.f90->sourcefile~flow.f90 sourcefile~flow_primitive_compressible_multispecie.f90->sourcefile~flow.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_eos_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_eos_object.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_eos_object.f90->sourcefile~flow.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~flow_field_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_field_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_field_object.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_field_object.f90->sourcefile~flow.f90 sourcefile~flow_conservative_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_conservative_object.f90->sourcefile~flow.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_sub.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_assign.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_not_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_add.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_pow.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_div.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_assign.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_mul.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_not_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_pow.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_sub.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_sub.f90 sourcefile~flow.f90->sourcefile~flow_test_eos_compressible.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_add.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_div.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_assign.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_div.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_compressible_transformations.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_not_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_add.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_pow.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_mul.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_mul.f90 var pansourcefilepenf_stringifyf90AfferentGraph = svgPanZoom('#sourcefilepenf_stringifyf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules penf_stringify Source Code penf_stringify.F90 Source Code module penf_stringify !----------------------------------------------------------------------------------------------------------------------------------- !< PENF string-to-number (and viceversa) facility. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: ISO_FORTRAN_ENV , only : stderr => ERROR_UNIT use penf_b_size use penf_global_parameters_variables !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private save public :: str , strz , cton public :: bstr , bcton !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface str !< Convert number (real and integer) to string (number to string type casting). module procedure & #ifdef r16p strf_R16P , str_R16P , & #endif strf_R8P , str_R8P , & strf_R4P , str_R4P , & strf_I8P , str_I8P , & strf_I4P , str_I4P , & strf_I2P , str_I2P , & strf_I1P , str_I1P , & str_bol , & #ifdef r16p str_a_R16P , & #endif str_a_R8P , & str_a_R4P , & str_a_I8P , & str_a_I4P , & str_a_I2P , & str_a_I1P endinterface !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface strz !< Convert integer, to string, prefixing with the right number of zeros (integer to string type casting with zero padding). module procedure strz_I8P , strz_I4P , strz_I2P , strz_I1P endinterface !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface cton !< Convert string to number (real and integer, string to number type casting). module procedure & #ifdef r16p ctor_R16P , & #endif ctor_R8P , & ctor_R4P , & ctoi_I8P , & ctoi_I4P , & ctoi_I2P , & ctoi_I1P endinterface !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface bstr !< Convert number (real and integer) to bit-string (number to bit-string type casting). module procedure & #ifdef r16p bstr_R16P , & #endif bstr_R8P , & bstr_R4P , & bstr_I8P , & bstr_I4P , & bstr_I2P , & bstr_I1P endinterface !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- interface bcton !< Convert bit-string to number (real and integer, bit-string to number type casting). module procedure & #ifdef r16p bctor_R16P , & #endif bctor_R8P , & bctor_R4P , & bctoi_I8P , & bctoi_I4P , & bctoi_I2P , & bctoi_I1P endinterface !----------------------------------------------------------------------------------------------------------------------------------- contains elemental function strf_R16P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R16P ), intent ( in ) :: n !< Real to be converted. character ( DR16P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R16P elemental function strf_R8P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R8P ), intent ( in ) :: n !< Real to be converted. character ( DR8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R8P elemental function strf_R4P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R4P ), intent ( in ) :: n !< Real to be converted. character ( DR4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R4P elemental function strf_I8P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I8P ), intent ( in ) :: n !< Integer to be converted. character ( DI8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I8P elemental function strf_I4P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I4P ), intent ( in ) :: n !< Integer to be converted. character ( DI4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I4P elemental function strf_I2P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I2P ), intent ( in ) :: n !< Integer to be converted. character ( DI2P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I2P elemental function strf_I1P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I1P ), intent ( in ) :: n !< Integer to be converted. character ( DI1P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I1P elemental function str_R16P ( n , no_sign , compact ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. logical , intent ( in ), optional :: compact !< Flag for *compacting* string encoding. character ( DR16P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR16P ) n ! Casting of n to string. if ( n > 0._R16P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. if ( present ( compact )) then if ( compact ) call compact_real_string ( string = str ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R16P elemental function str_R8P ( n , no_sign , compact ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. logical , intent ( in ), optional :: compact !< Flag for *compacting* string encoding. character ( DR8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR8P ) n ! Casting of n to string. if ( n > 0._R8P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. if ( present ( compact )) then if ( compact ) call compact_real_string ( string = str ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R8P elemental function str_R4P ( n , no_sign , compact ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. logical , intent ( in ), optional :: compact !< Flag for *compacting* string encoding. character ( DR4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR4P ) n ! Casting of n to string. if ( n > 0._R4P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. if ( present ( compact )) then if ( compact ) call compact_real_string ( string = str ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R4P elemental function str_I8P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I8P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I8P elemental function str_I4P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Converting integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I4P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I4P elemental function str_I2P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I2P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I2P elemental function str_I1P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I1P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I1P elemental function str_bol ( n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert logical to string. !--------------------------------------------------------------------------------------------------------------------------------- logical , intent ( in ) :: n !< Logical to be converted. character ( 1 ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , '(L1)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_bol pure function str_a_R16P ( n , no_sign , separator , delimiters , compact ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Converting real array to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator ( 1 ) !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. logical , intent ( in ), optional :: compact !< Flag for *compacting* string encoding. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR16P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- str = '' sep = ',' if ( present ( separator )) sep = separator ( 1 ) do i = 1 , size ( n ) strn = str_R16P ( no_sign = no_sign , compact = compact , n = n ( i )) str = str // sep // trim ( strn ) enddo str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R16P pure function str_a_R8P ( n , no_sign , separator , delimiters , compact ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real array to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. logical , intent ( in ), optional :: compact !< Flag for *compacting* string encoding. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR8P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- str = '' sep = ',' if ( present ( separator )) sep = separator do i = 1 , size ( n ) strn = str_R8P ( no_sign = no_sign , compact = compact , n = n ( i )) str = str // sep // trim ( strn ) enddo str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R8P pure function str_a_R4P ( n , no_sign , separator , delimiters , compact ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real array to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. logical , intent ( in ), optional :: compact !< Flag for *compacting* string encoding. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR4P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- str = '' sep = ',' if ( present ( separator )) sep = separator do i = 1 , size ( n ) strn = str_R4P ( no_sign = no_sign , compact = compact , n = n ( i )) str = str // sep // trim ( strn ) enddo str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R4P pure function str_a_I8P ( n , no_sign , separator , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI8P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- str = '' sep = ',' if ( present ( separator )) sep = separator if ( present ( no_sign )) then do i = 1 , size ( n ) strn = str_I8P ( no_sign = no_sign , n = n ( i )) str = str // sep // trim ( strn ) enddo else do i = 1 , size ( n ) strn = str_I8P ( n = n ( i )) str = str // sep // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I8P pure function str_a_I4P ( n , no_sign , separator , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI4P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- str = '' sep = ',' if ( present ( separator )) sep = separator if ( present ( no_sign )) then do i = 1 , size ( n ) strn = str_I4P ( no_sign = no_sign , n = n ( i )) str = str // sep // trim ( strn ) enddo else do i = 1 , size ( n ) strn = str_I4P ( n = n ( i )) str = str // sep // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I4P pure function str_a_I2P ( n , no_sign , separator , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI2P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- str = '' sep = ',' if ( present ( separator )) sep = separator if ( present ( no_sign )) then do i = 1 , size ( n ) strn = str_I2P ( no_sign = no_sign , n = n ( i )) str = str // sep // trim ( strn ) enddo else do i = 1 , size ( n ) strn = str_I2P ( n = n ( i )) str = str // sep // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I2P pure function str_a_I1P ( n , no_sign , separator , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI1P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- str = '' sep = ',' if ( present ( separator )) sep = separator if ( present ( no_sign )) then do i = 1 , size ( n ) strn = str_I1P ( no_sign = no_sign , n = n ( i )) str = str // sep // trim ( strn ) enddo else do i = 1 , size ( n ) strn = str_I1P ( n = n ( i )) str = str // sep // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I1P pure subroutine compact_real_string ( string ) !--------------------------------------------------------------------------------------------------------------------------------- !< author: Izaak Beekman !< date: 02/24/2015 !< !< Compact a string representing a real number, so that the same value is displayed with fewer characters. !--------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( inout ) :: string !< string representation of a real number. character ( len = len ( string )) :: significand !< Significand characters. character ( len = len ( string )) :: expnt !< Exponent characters. character ( len = 2 ) :: separator !< Separator characters. integer ( I4P ) :: exp_start !< Start position of exponent. integer ( I4P ) :: decimal_pos !< Decimal positions. integer ( I4P ) :: sig_trim !< Signature trim. integer ( I4P ) :: exp_trim !< Exponent trim. integer ( I4P ) :: i !< counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- string = adjustl ( string ) exp_start = scan ( string , 'eEdD' ) if ( exp_start == 0 ) exp_start = scan ( string , '-+' , back = . true .) decimal_pos = scan ( string , '.' ) if ( exp_start /= 0 ) separator = string ( exp_start : exp_start ) if ( exp_start < decimal_pos ) then ! possibly signed, exponent-less float significand = string sig_trim = len ( trim ( significand )) do i = len ( trim ( significand )), decimal_pos + 2 , - 1 ! look from right to left at 0s, but save one after the decimal place if ( significand ( i : i ) == '0' ) then sig_trim = i - 1 else exit endif enddo string = trim ( significand ( 1 : sig_trim )) elseif ( exp_start > decimal_pos ) then ! float has exponent significand = string ( 1 : exp_start - 1 ) sig_trim = len ( trim ( significand )) do i = len ( trim ( significand )), decimal_pos + 2 , - 1 ! look from right to left at 0s if ( significand ( i : i ) == '0' ) then sig_trim = i - 1 else exit endif enddo expnt = adjustl ( string ( exp_start + 1 :)) if ( expnt ( 1 : 1 ) == '+' . or . expnt ( 1 : 1 ) == '-' ) then separator = trim ( adjustl ( separator )) // expnt ( 1 : 1 ) exp_start = exp_start + 1 expnt = adjustl ( string ( exp_start + 1 :)) endif exp_trim = 1 do i = 1 ,( len ( trim ( expnt )) - 1 ) ! look at exponent leading zeros saving last if ( expnt ( i : i ) == '0' ) then exp_trim = i + 1 else exit endif enddo string = trim ( adjustl ( significand ( 1 : sig_trim ))) // & trim ( adjustl ( separator )) // & trim ( adjustl ( expnt ( exp_trim :))) !else ! mal-formed real, BUT this code should be unreachable endif !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine compact_real_string elemental function strz_I8P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Converting integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI8P - nz_pad : DI8P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I8P elemental function strz_I4P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI4P - nz_pad : DI4P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I4P elemental function strz_I2P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI2P - nz_pad : DI2P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I2P elemental function strz_I1P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI1P - nz_pad : DI1P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I1P function ctor_R16P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. real ( R16P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R16P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R16P function ctor_R8P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. real ( R8P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R8P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R8P function ctor_R4P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. real ( R4P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R4P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R4P function ctoi_I8P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I8P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I8P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I8P function ctoi_I4P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I4P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I4P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I4P function ctoi_I2P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I2P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I2P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I2P function ctoi_I1P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I1P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I1P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I1P elemental function bstr_R16P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string of bits. !< !< @note It is assumed that R16P is represented by means of 128 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n !< Real to be converted. character ( 128 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B128.128)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R16P elemental function bstr_R8P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string of bits. !< !< @note It is assumed that R8P is represented by means of 64 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n !< Real to be converted. character ( 64 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B64.64)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R8P elemental function bstr_R4P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string of bits. !< !< @note It is assumed that R4P is represented by means of 32 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n !< Real to be converted. character ( 32 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B32.32)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R4P elemental function bstr_I8P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I8P is represented by means of 64 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Real to be converted. character ( 64 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B64.64)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I8P elemental function bstr_I4P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I4P is represented by means of 32 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Real to be converted. character ( 32 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B32.32)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I4P elemental function bstr_I2P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I2P is represented by means of 16 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Real to be converted. character ( 16 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B16.16)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I2P elemental function bstr_I1P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I1P is represented by means of 8 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Real to be converted. character ( 8 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B8.8)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I1P elemental function bctor_R16P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R16P ), intent ( in ) :: knd !< Number kind. real ( R16P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R16P elemental function bctor_R8P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R8P ), intent ( in ) :: knd !< Number kind. real ( R8P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R8P elemental function bctor_R4P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R4P ), intent ( in ) :: knd !< Number kind. real ( R4P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R4P elemental function bctoi_I8P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I8P ), intent ( in ) :: knd !< Number kind. integer ( I8P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I8P elemental function bctoi_I4P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I4P ), intent ( in ) :: knd !< Number kind. integer ( I4P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I4P elemental function bctoi_I2P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I2P ), intent ( in ) :: knd !< Number kind. integer ( I2P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I2P elemental function bctoi_I1P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I1P ), intent ( in ) :: knd !< Number kind. integer ( I1P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I1P endmodule penf_stringify","tags":"","loc":"sourcefile/penf_stringify.f90.html","title":"penf_stringify.F90 – FLOw"},{"text":"Module definition of class Vector. Files Dependent On This One sourcefile~~vecfor.f90~~AfferentGraph sourcefile~vecfor.f90 vecfor.F90 sourcefile~flow_test_primitive_compressible_sub.f90 flow_test_primitive_compressible_sub.f90 sourcefile~vecfor.f90->sourcefile~flow_test_primitive_compressible_sub.f90 sourcefile~flow_test_conservative_compressible_assign.f90 flow_test_conservative_compressible_assign.f90 sourcefile~vecfor.f90->sourcefile~flow_test_conservative_compressible_assign.f90 sourcefile~flow_test_primitive_compressible_multispecie_not_eq.f90 flow_test_primitive_compressible_multispecie_not_eq.f90 sourcefile~vecfor.f90->sourcefile~flow_test_primitive_compressible_multispecie_not_eq.f90 sourcefile~flow_primitive_object.f90 flow_primitive_object.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_object.f90 sourcefile~flow_test_conservative_compressible_add.f90 flow_test_conservative_compressible_add.f90 sourcefile~vecfor.f90->sourcefile~flow_test_conservative_compressible_add.f90 sourcefile~flow_test_primitive_compressible_multispecie_pow.f90 flow_test_primitive_compressible_multispecie_pow.f90 sourcefile~vecfor.f90->sourcefile~flow_test_primitive_compressible_multispecie_pow.f90 sourcefile~flow_test_conservative_compressible_div.f90 flow_test_conservative_compressible_div.f90 sourcefile~vecfor.f90->sourcefile~flow_test_conservative_compressible_div.f90 sourcefile~flow_test_conservative_compressible_eq.f90 flow_test_conservative_compressible_eq.f90 sourcefile~vecfor.f90->sourcefile~flow_test_conservative_compressible_eq.f90 sourcefile~flow_compressible_transformations.f90 flow_compressible_transformations.f90 sourcefile~vecfor.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_test_conservative_compressible_mul.f90 flow_test_conservative_compressible_mul.f90 sourcefile~vecfor.f90->sourcefile~flow_test_conservative_compressible_mul.f90 sourcefile~flow_test_conservative_compressible_not_eq.f90 flow_test_conservative_compressible_not_eq.f90 sourcefile~vecfor.f90->sourcefile~flow_test_conservative_compressible_not_eq.f90 sourcefile~flow_test_conservative_compressible_pow.f90 flow_test_conservative_compressible_pow.f90 sourcefile~vecfor.f90->sourcefile~flow_test_conservative_compressible_pow.f90 sourcefile~flow_test_conservative_compressible_sub.f90 flow_test_conservative_compressible_sub.f90 sourcefile~vecfor.f90->sourcefile~flow_test_conservative_compressible_sub.f90 sourcefile~flow_test_primitive_compressible_add.f90 flow_test_primitive_compressible_add.f90 sourcefile~vecfor.f90->sourcefile~flow_test_primitive_compressible_add.f90 sourcefile~flow_test_primitive_compressible_assign.f90 flow_test_primitive_compressible_assign.f90 sourcefile~vecfor.f90->sourcefile~flow_test_primitive_compressible_assign.f90 sourcefile~flow_test_primitive_compressible_div.f90 flow_test_primitive_compressible_div.f90 sourcefile~vecfor.f90->sourcefile~flow_test_primitive_compressible_div.f90 sourcefile~flow_test_primitive_compressible_eq.f90 flow_test_primitive_compressible_eq.f90 sourcefile~vecfor.f90->sourcefile~flow_test_primitive_compressible_eq.f90 sourcefile~flow_test_primitive_compressible_mul.f90 flow_test_primitive_compressible_mul.f90 sourcefile~vecfor.f90->sourcefile~flow_test_primitive_compressible_mul.f90 sourcefile~flow_test_primitive_compressible_multispecie_add.f90 flow_test_primitive_compressible_multispecie_add.f90 sourcefile~vecfor.f90->sourcefile~flow_test_primitive_compressible_multispecie_add.f90 sourcefile~flow_test_primitive_compressible_multispecie_assign.f90 flow_test_primitive_compressible_multispecie_assign.f90 sourcefile~vecfor.f90->sourcefile~flow_test_primitive_compressible_multispecie_assign.f90 sourcefile~flow_test_primitive_compressible_multispecie_eq.f90 flow_test_primitive_compressible_multispecie_eq.f90 sourcefile~vecfor.f90->sourcefile~flow_test_primitive_compressible_multispecie_eq.f90 sourcefile~flow_test_primitive_compressible_multispecie_div.f90 flow_test_primitive_compressible_multispecie_div.f90 sourcefile~vecfor.f90->sourcefile~flow_test_primitive_compressible_multispecie_div.f90 sourcefile~flow_field_scalar_vectorial.f90 flow_field_scalar_vectorial.f90 sourcefile~vecfor.f90->sourcefile~flow_field_scalar_vectorial.f90 sourcefile~flow_conservative_compressible.f90 flow_conservative_compressible.f90 sourcefile~vecfor.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_primitive_compressible.f90 flow_primitive_compressible.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_test_primitive_compressible_pow.f90 flow_test_primitive_compressible_pow.f90 sourcefile~vecfor.f90->sourcefile~flow_test_primitive_compressible_pow.f90 sourcefile~flow_primitive_compressible_multispecie.f90 flow_primitive_compressible_multispecie.f90 sourcefile~vecfor.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow_test_primitive_compressible_multispecie_sub.f90 flow_test_primitive_compressible_multispecie_sub.f90 sourcefile~vecfor.f90->sourcefile~flow_test_primitive_compressible_multispecie_sub.f90 sourcefile~flow_test_primitive_compressible_multispecie_mul.f90 flow_test_primitive_compressible_multispecie_mul.f90 sourcefile~vecfor.f90->sourcefile~flow_test_primitive_compressible_multispecie_mul.f90 sourcefile~flow_test_primitive_compressible_not_eq.f90 flow_test_primitive_compressible_not_eq.f90 sourcefile~vecfor.f90->sourcefile~flow_test_primitive_compressible_not_eq.f90 sourcefile~flow_conservative_object.f90 flow_conservative_object.f90 sourcefile~vecfor.f90->sourcefile~flow_conservative_object.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow_primitive_compressible.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow_primitive_compressible_multispecie.f90 sourcefile~flow.f90 flow.f90 sourcefile~flow_primitive_object.f90->sourcefile~flow.f90 sourcefile~flow_compressible_transformations.f90->sourcefile~flow.f90 sourcefile~flow_field_scalar_vectorial.f90->sourcefile~flow.f90 sourcefile~flow_conservative_compressible.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_conservative_compressible.f90->sourcefile~flow.f90 sourcefile~flow_primitive_compressible.f90->sourcefile~flow_compressible_transformations.f90 sourcefile~flow_primitive_compressible.f90->sourcefile~flow.f90 sourcefile~flow_primitive_compressible_multispecie.f90->sourcefile~flow.f90 sourcefile~flow_conservative_object.f90->sourcefile~flow_conservative_compressible.f90 sourcefile~flow_conservative_object.f90->sourcefile~flow.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_sub.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_assign.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_not_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_add.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_pow.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_div.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_mul.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_not_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_pow.f90 sourcefile~flow.f90->sourcefile~flow_test_conservative_compressible_sub.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_add.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_assign.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_div.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_mul.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_add.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_assign.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_eq.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_div.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_pow.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_sub.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_multispecie_mul.f90 sourcefile~flow.f90->sourcefile~flow_test_primitive_compressible_not_eq.f90 sourcefile~flow_test_eos_compressible.f90 flow_test_eos_compressible.f90 sourcefile~flow.f90->sourcefile~flow_test_eos_compressible.f90 sourcefile~flow_test_compressible_transformations.f90 flow_test_compressible_transformations.f90 sourcefile~flow.f90->sourcefile~flow_test_compressible_transformations.f90 var pansourcefilevecforf90AfferentGraph = svgPanZoom('#sourcefilevecforf90AfferentGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which depends upon it. A file \n    is dependent upon another if the latter must be compiled before the former\n    can be. Modules VecFor Source Code vecfor.F90 Source Code !< Module definition of class Vector. module VecFor !< Module definition of class Vector. !< !< This derived type is useful for manipulating vectors in 3D space. The components of the vectors are reals with !< parametrized kind as defined by the library module. The components are defined in a three-dimensional cartesian frame of !< reference. !< All the vectorial math procedures (cross, dot products, parallel...) assume a three-dimensional cartesian frame of reference. !< The operators of assignment (`=`), multiplication (`*`), division (`/`), sum (`+`) and subtraction (`-`) have been overloaded. !< Furthermore the *dot* and *cross* products have been defined. !< Therefore this module provides a far-complete algebra based on Vector derived type. !----------------------------------------------------------------------------------------------------------------------------------- use , intrinsic :: ISO_FORTRAN_ENV , only : stdout => OUTPUT_UNIT !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- implicit none private public :: ex , ey , ez public :: sq_norm public :: normL2 public :: normalize public :: face_normal3 , face_normal4 !----------------------------------------------------------------------------------------------------------------------------------- !----------------------------------------------------------------------------------------------------------------------------------- #ifdef r16p integer , parameter :: R16P = selected_real_kind ( 33 , 4931 ) !< 33  digits, range [10&#94;{-4931}, 10&#94;{+4931} - 1]; 128 bits. #else integer , parameter :: R16P = selected_real_kind ( 15 , 307 ) !< Defined as R8P; 64 bits. #endif integer , parameter :: R8P = selected_real_kind ( 15 , 307 ) !< 15  digits, range [10&#94;{-307} , 10&#94;{+307}  - 1]; 64 bits. integer , parameter :: R4P = selected_real_kind ( 6 , 37 ) !< 6   digits, range [10&#94;{-37}  , 10&#94;{+37}   - 1]; 32 bits. integer , parameter :: I8P = selected_int_kind ( 18 ) !< Range [-2&#94;{63},+2&#94;{63} - 1], 19 digits plus sign; 64 bits. integer , parameter :: I4P = selected_int_kind ( 9 ) !< Range [-2&#94;{31},+2&#94;{31} - 1], 10 digits plus sign; 32 bits. integer , parameter :: I2P = selected_int_kind ( 4 ) !< Range [-2&#94;{15},+2&#94;{15} - 1], 5  digits plus sign; 16 bits. integer , parameter :: I1P = selected_int_kind ( 2 ) !< Range [-2&#94;{7} ,+2&#94;{7}  - 1], 3  digits plus sign; 8  bits. real ( R8P ), parameter :: smallR8P = tiny ( 1._R8P ) !< Smallest (module) representable value of kind=R8P variable. integer , parameter :: DR8P = 23 !< Number of digits of output format FR8P. character ( 10 ), parameter :: FR8P = '(E23.15E3)' !< Output format for kind=R8P variable. type , public :: Vector !< Vector class. real ( R8P ) :: x = 0._R8P !< Cartesian component in x direction. real ( R8P ) :: y = 0._R8P !< Cartesian component in y direction. real ( R8P ) :: z = 0._R8P !< Cartesian component in z direction. contains procedure :: init => init_vector_self ! Procedure for initializing vector components. procedure :: set => set_vector_self ! Procedure for setting vector components. procedure :: iolen => iolen_vector_self ! Procedure for computing IO length. procedure :: load => load_vector_self ! Procedure for loading Vector data. procedure :: save => save_vector_self ! Procedure for saving Vector data. procedure :: print => print_vector_self ! Procedure for printing vector components with a \"pretty\" format. procedure :: sq_norm => sq_norm_self ! Procedure for computing the square of the norm of a vector. procedure :: normL2 => normL2_self ! Procedure for computing the norm L2 of a vector. procedure :: normalize => normalize_self ! Procedure for normalizing a vector. procedure :: normalized => normalized_self ! Procedure for obtaining a normalized copy of a vector. procedure :: face_normal4 => face_normal4_self ! Procedure for calculating the normal of the face defined by 4 points vector. procedure :: face_normal3 => face_normal3_self ! Procedure for calculating the normal of the face defined by 3 points vector. generic :: operator (. cross .) => crossproduct ! Procedure for computing the cross product of 2 vectors. generic :: operator (. dot .) => dotproduct ! Procedure for computing the scalar (dot) product of 2 vectors. generic :: operator (. paral .) => parallel ! Procedure for computing the component of vec1 parallel to vec2. generic :: operator (. ortho .) => orthogonal ! Procedure for computign the component of vec1 orthogonal to vec2. procedure , pass ( vec1 ), private :: crossproduct procedure , pass ( vec1 ), private :: dotproduct procedure , pass ( vec1 ), private :: parallel procedure , pass ( vec1 ), private :: orthogonal ! operators overloading generic :: assignment ( = ) => assign_self , & #ifdef r16p assign_ScalR16P ,& #endif assign_ScalR8P , assign_ScalR4P , assign_ScalI8P , assign_ScalI4P , assign_ScalI2P , assign_ScalI1P #ifdef r16p procedure , pass ( self ), private :: assign_ScalR16P #endif procedure , pass ( self1 ), private :: assign_self procedure , pass ( self ), private :: assign_ScalR8P procedure , pass ( self ), private :: assign_ScalR4P procedure , pass ( self ), private :: assign_ScalI8P procedure , pass ( self ), private :: assign_ScalI4P procedure , pass ( self ), private :: assign_ScalI2P procedure , pass ( self ), private :: assign_ScalI1P generic :: operator ( * ) => self_mul_self , & #ifdef r16p ScalR16P_mul_self , self_mul_ScalR16P , & #endif ScalR8P_mul_self , self_mul_ScalR8P , ScalR4P_mul_self , self_mul_ScalR4P , ScalI8P_mul_self , self_mul_ScalI8P ,& ScalI4P_mul_self , self_mul_ScalI4P , ScalI2P_mul_self , self_mul_ScalI2P , ScalI1P_mul_self , self_mul_ScalI1P #ifdef r16p procedure , pass ( self ), private :: ScalR16P_mul_self procedure , pass ( self ), private :: self_mul_ScalR16P #endif procedure , pass ( self1 ), private :: self_mul_self procedure , pass ( self ), private :: ScalR8P_mul_self procedure , pass ( self ), private :: ScalR4P_mul_self procedure , pass ( self ), private :: ScalI8P_mul_self procedure , pass ( self ), private :: ScalI4P_mul_self procedure , pass ( self ), private :: ScalI2P_mul_self procedure , pass ( self ), private :: ScalI1P_mul_self procedure , pass ( self ), private :: self_mul_ScalR8P procedure , pass ( self ), private :: self_mul_ScalR4P procedure , pass ( self ), private :: self_mul_ScalI8P procedure , pass ( self ), private :: self_mul_ScalI4P procedure , pass ( self ), private :: self_mul_ScalI2P procedure , pass ( self ), private :: self_mul_ScalI1P generic :: operator ( / ) => self_div_self , & #ifdef r16p self_div_ScalR16P ,& #endif self_div_ScalR8P , self_div_ScalR4P , self_div_ScalI8P , self_div_ScalI4P , self_div_ScalI2P , self_div_ScalI1P #ifdef r16p procedure , pass ( self ), private :: self_div_ScalR16P #endif procedure , pass ( self1 ), private :: self_div_self procedure , pass ( self ), private :: self_div_ScalR8P procedure , pass ( self ), private :: self_div_ScalR4P procedure , pass ( self ), private :: self_div_ScalI8P procedure , pass ( self ), private :: self_div_ScalI4P procedure , pass ( self ), private :: self_div_ScalI2P procedure , pass ( self ), private :: self_div_ScalI1P generic :: operator ( + ) => positive_self , self_sum_self , & #ifdef r16p ScalR16P_sum_self , self_sum_ScalR16P , & #endif ScalR8P_sum_self , self_sum_ScalR8P , ScalR4P_sum_self , self_sum_ScalR4P , ScalI8P_sum_self , self_sum_ScalI8P ,& ScalI4P_sum_self , self_sum_ScalI4P , ScalI2P_sum_self , self_sum_ScalI2P , ScalI1P_sum_self , self_sum_ScalI1P #ifdef r16p procedure , pass ( self ), private :: ScalR16P_sum_self procedure , pass ( self ), private :: self_sum_ScalR16P #endif procedure , pass ( self ), private :: positive_self procedure , pass ( self1 ), private :: self_sum_self procedure , pass ( self ), private :: ScalR8P_sum_self procedure , pass ( self ), private :: ScalR4P_sum_self procedure , pass ( self ), private :: ScalI8P_sum_self procedure , pass ( self ), private :: ScalI4P_sum_self procedure , pass ( self ), private :: ScalI2P_sum_self procedure , pass ( self ), private :: ScalI1P_sum_self procedure , pass ( self ), private :: self_sum_ScalR8P procedure , pass ( self ), private :: self_sum_ScalR4P procedure , pass ( self ), private :: self_sum_ScalI8P procedure , pass ( self ), private :: self_sum_ScalI4P procedure , pass ( self ), private :: self_sum_ScalI2P procedure , pass ( self ), private :: self_sum_ScalI1P generic :: operator ( - ) => negative_self , self_sub_self , & #ifdef r16p ScalR16P_sub_self , self_sub_ScalR16P , & #endif ScalR8P_sub_self , self_sub_ScalR8P , ScalR4P_sub_self , self_sub_ScalR4P , ScalI8P_sub_self , self_sub_ScalI8P ,& ScalI4P_sub_self , self_sub_ScalI4P , ScalI2P_sub_self , self_sub_ScalI2P , ScalI1P_sub_self , self_sub_ScalI1P #ifdef r16p procedure , pass ( self ), private :: ScalR16P_sub_self procedure , pass ( self ), private :: self_sub_ScalR16P #endif procedure , pass ( self ), private :: negative_self procedure , pass ( self1 ), private :: self_sub_self procedure , pass ( self ), private :: ScalR8P_sub_self procedure , pass ( self ), private :: ScalR4P_sub_self procedure , pass ( self ), private :: ScalI8P_sub_self procedure , pass ( self ), private :: ScalI4P_sub_self procedure , pass ( self ), private :: ScalI2P_sub_self procedure , pass ( self ), private :: ScalI1P_sub_self procedure , pass ( self ), private :: self_sub_ScalR8P procedure , pass ( self ), private :: self_sub_ScalR4P procedure , pass ( self ), private :: self_sub_ScalI8P procedure , pass ( self ), private :: self_sub_ScalI4P procedure , pass ( self ), private :: self_sub_ScalI2P procedure , pass ( self ), private :: self_sub_ScalI1P generic :: operator ( /= ) => self_not_eq_self , & #ifdef r16p R16P_not_eq_self , self_not_eq_R16P , & #endif R8P_not_eq_self , self_not_eq_R8P , R4P_not_eq_self , self_not_eq_R4P , I8P_not_eq_self , self_not_eq_I8P ,& I4P_not_eq_self , self_not_eq_I4P , I2P_not_eq_self , self_not_eq_I2P , I1P_not_eq_self , self_not_eq_I1P generic :: operator ( < ) => self_low_self , & #ifdef r16p R16P_low_self , self_low_R16P , & #endif R8P_low_self , self_low_R8P , R4P_low_self , self_low_R4P , I8P_low_self , self_low_I8P ,& I4P_low_self , self_low_I4P , I2P_low_self , self_low_I2P , I1P_low_self , self_low_I1P generic :: operator ( <= ) => self_low_eq_self , & #ifdef r16p R16P_low_eq_self , self_low_eq_R16P , & #endif R8P_low_eq_self , self_low_eq_R8P , R4P_low_eq_self , self_low_eq_R4P , I8P_low_eq_self , self_low_eq_I8P ,& I4P_low_eq_self , self_low_eq_I4P , I2P_low_eq_self , self_low_eq_I2P , I1P_low_eq_self , self_low_eq_I1P generic :: operator ( == ) => self_eq_self , & #ifdef r16p R16P_eq_self , self_eq_R16P , & #endif R8P_eq_self , self_eq_R8P , R4P_eq_self , self_eq_R4P , I8P_eq_self , self_eq_I8P ,& I4P_eq_self , self_eq_I4P , I2P_eq_self , self_eq_I2P , I1P_eq_self , self_eq_I1P generic :: operator ( >= ) => self_great_eq_self , & #ifdef r16p R16P_great_eq_self , self_great_eq_R16P , & #endif R8P_great_eq_self , self_great_eq_R8P , R4P_great_eq_self , self_great_eq_R4P , I8P_great_eq_self ,& self_great_eq_I8P , I4P_great_eq_self , self_great_eq_I4P , I2P_great_eq_self , self_great_eq_I2P ,& I1P_great_eq_self , self_great_eq_I1P generic :: operator ( > ) => self_great_self , & #ifdef r16p R16P_great_self , self_great_R16P , & #endif R8P_great_self , self_great_R8P , R4P_great_self , self_great_R4P , I8P_great_self , self_great_I8P ,& I4P_great_self , self_great_I4P , I2P_great_self , self_great_I2P , I1P_great_self , self_great_I1P #ifdef r16p procedure , pass ( self ), private :: R16P_not_eq_self procedure , pass ( self ), private :: self_not_eq_R16P procedure , pass ( self ), private :: R16P_low_self procedure , pass ( self ), private :: self_low_R16P procedure , pass ( self ), private :: R16P_low_eq_self procedure , pass ( self ), private :: self_low_eq_R16P procedure , pass ( self ), private :: R16P_eq_self procedure , pass ( self ), private :: self_eq_R16P procedure , pass ( self ), private :: R16P_great_eq_self procedure , pass ( self ), private :: self_great_eq_R16P procedure , pass ( self ), private :: R16P_great_self procedure , pass ( self ), private :: self_great_R16P #endif procedure , pass ( self1 ), private :: self_not_eq_self procedure , pass ( self ), private :: R8P_not_eq_self procedure , pass ( self ), private :: R4P_not_eq_self procedure , pass ( self ), private :: I8P_not_eq_self procedure , pass ( self ), private :: I4P_not_eq_self procedure , pass ( self ), private :: I2P_not_eq_self procedure , pass ( self ), private :: I1P_not_eq_self procedure , pass ( self ), private :: self_not_eq_R8P procedure , pass ( self ), private :: self_not_eq_R4P procedure , pass ( self ), private :: self_not_eq_I8P procedure , pass ( self ), private :: self_not_eq_I4P procedure , pass ( self ), private :: self_not_eq_I2P procedure , pass ( self ), private :: self_not_eq_I1P procedure , pass ( self1 ), private :: self_low_self procedure , pass ( self ), private :: R8P_low_self procedure , pass ( self ), private :: R4P_low_self procedure , pass ( self ), private :: I8P_low_self procedure , pass ( self ), private :: I4P_low_self procedure , pass ( self ), private :: I2P_low_self procedure , pass ( self ), private :: I1P_low_self procedure , pass ( self ), private :: self_low_R8P procedure , pass ( self ), private :: self_low_R4P procedure , pass ( self ), private :: self_low_I8P procedure , pass ( self ), private :: self_low_I4P procedure , pass ( self ), private :: self_low_I2P procedure , pass ( self ), private :: self_low_I1P procedure , pass ( self1 ), private :: self_low_eq_self procedure , pass ( self ), private :: R8P_low_eq_self procedure , pass ( self ), private :: R4P_low_eq_self procedure , pass ( self ), private :: I8P_low_eq_self procedure , pass ( self ), private :: I4P_low_eq_self procedure , pass ( self ), private :: I2P_low_eq_self procedure , pass ( self ), private :: I1P_low_eq_self procedure , pass ( self ), private :: self_low_eq_R8P procedure , pass ( self ), private :: self_low_eq_R4P procedure , pass ( self ), private :: self_low_eq_I8P procedure , pass ( self ), private :: self_low_eq_I4P procedure , pass ( self ), private :: self_low_eq_I2P procedure , pass ( self ), private :: self_low_eq_I1P procedure , pass ( self1 ), private :: self_eq_self procedure , pass ( self ), private :: R8P_eq_self procedure , pass ( self ), private :: R4P_eq_self procedure , pass ( self ), private :: I8P_eq_self procedure , pass ( self ), private :: I4P_eq_self procedure , pass ( self ), private :: I2P_eq_self procedure , pass ( self ), private :: I1P_eq_self procedure , pass ( self ), private :: self_eq_R8P procedure , pass ( self ), private :: self_eq_R4P procedure , pass ( self ), private :: self_eq_I8P procedure , pass ( self ), private :: self_eq_I4P procedure , pass ( self ), private :: self_eq_I2P procedure , pass ( self ), private :: self_eq_I1P procedure , pass ( self1 ), private :: self_great_eq_self procedure , pass ( self ), private :: R8P_great_eq_self procedure , pass ( self ), private :: R4P_great_eq_self procedure , pass ( self ), private :: I8P_great_eq_self procedure , pass ( self ), private :: I4P_great_eq_self procedure , pass ( self ), private :: I2P_great_eq_self procedure , pass ( self ), private :: I1P_great_eq_self procedure , pass ( self ), private :: self_great_eq_R8P procedure , pass ( self ), private :: self_great_eq_R4P procedure , pass ( self ), private :: self_great_eq_I8P procedure , pass ( self ), private :: self_great_eq_I4P procedure , pass ( self ), private :: self_great_eq_I2P procedure , pass ( self ), private :: self_great_eq_I1P procedure , pass ( self1 ), private :: self_great_self procedure , pass ( self ), private :: R8P_great_self procedure , pass ( self ), private :: R4P_great_self procedure , pass ( self ), private :: I8P_great_self procedure , pass ( self ), private :: I4P_great_self procedure , pass ( self ), private :: I2P_great_self procedure , pass ( self ), private :: I1P_great_self procedure , pass ( self ), private :: self_great_R8P procedure , pass ( self ), private :: self_great_R4P procedure , pass ( self ), private :: self_great_I8P procedure , pass ( self ), private :: self_great_I4P procedure , pass ( self ), private :: self_great_I2P procedure , pass ( self ), private :: self_great_I1P endtype Vector type , public :: Vector_Ptr !< Pointer of Vector for creating array of pointers of Vector. type ( Vector ), pointer :: p => null () endtype Vector_Ptr type ( Vector ), parameter :: ex = Vector ( 1._R8P , 0._R8P , 0._R8P ) !< X direction versor. type ( Vector ), parameter :: ey = Vector ( 0._R8P , 1._R8P , 0._R8P ) !< Y direction versor. type ( Vector ), parameter :: ez = Vector ( 0._R8P , 0._R8P , 1._R8P ) !< Z direction versor. !----------------------------------------------------------------------------------------------------------------------------------- contains elemental function sq_norm ( vec ) result ( sq ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the square of the norm of a vector. !< !< The square norm if defined as  N = x&#94;2  + y&#94;2  + z&#94;2 . !--------------------------------------------------------------------------------------------------------------------------------- type ( Vector ), intent ( IN ) :: vec !< Vector. real ( R8P ) :: sq !< Square of the Norm. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- sq = ( vec % x * vec % x ) + ( vec % y * vec % y ) + ( vec % z * vec % z ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sq_norm elemental function normL2 ( vec ) result ( norm ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the norm L2 of a vector. !< !< The norm L2 if defined as  N = \\sqrt {x&#94;2  + y&#94;2  + z&#94;2 } . !--------------------------------------------------------------------------------------------------------------------------------- type ( Vector ), intent ( IN ) :: vec !< Vector. real ( R8P ) :: norm !< Norm L2. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- norm = sqrt (( vec % x * vec % x ) + ( vec % y * vec % y ) + ( vec % z * vec % z )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction normL2 elemental function normalize ( vec ) result ( norm ) !--------------------------------------------------------------------------------------------------------------------------------- !< Normalize a vector. !< !< The normalization is made by means of norm L2. If the norm L2 of the vector is less than the parameter smallR8P the !< normalization value is set to normL2(vec)+smallR8P. !--------------------------------------------------------------------------------------------------------------------------------- type ( Vector ), intent ( IN ) :: vec !< Vector to be normalized. type ( Vector ) :: norm !< Vector normalized. real ( R8P ) :: nm !< Norm L2 of vector. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- nm = normL2 ( vec ) if ( nm < smallR8P ) then nm = nm + smallR8P endif norm % x = vec % x / nm norm % y = vec % y / nm norm % z = vec % z / nm return !--------------------------------------------------------------------------------------------------------------------------------- endfunction normalize elemental function face_normal4 ( pt1 , pt2 , pt3 , pt4 , norm ) result ( fnormal ) !--------------------------------------------------------------------------------------------------------------------------------- !< Calculate the normal of the face defined by 4 points vector pt1, pt2, pt3 and pt4. !< !< The convention for the points numeration is the following: !<``` !< 1.----------.2 !<  |          | !<  |          | !<  |          | !<  |          | !< 4.----------.3 !<``` !< The normal is calculated by the cross product of the diagonal d13 for the diagonal d24: d13 x d24. !< The normal is normalized if the variable *norm* is passed (with any value). !--------------------------------------------------------------------------------------------------------------------------------- type ( Vector ), intent ( IN ) :: pt1 !< First face point. type ( Vector ), intent ( IN ) :: pt2 !< Second face point. type ( Vector ), intent ( IN ) :: pt3 !< Third face point. type ( Vector ), intent ( IN ) :: pt4 !< Fourth face point. character ( 1 ), intent ( IN ), optional :: norm !< If 'norm' is passed as argument the normal is normalized. type ( Vector ) :: fnormal !< Face normal. type ( Vector ) :: d13 !< Face 1-3 diagonal. type ( Vector ) :: d24 !< Face 2-4 diagonal. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- d13 = pt3 - pt1 d24 = pt4 - pt2 if ( present ( norm )) then fnormal = normalize ( d13 . cross . d24 ) else fnormal = 0.5_R8P * ( d13 . cross . d24 ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction face_normal4 elemental function face_normal3 ( pt1 , pt2 , pt3 , norm ) result ( fnormal ) !--------------------------------------------------------------------------------------------------------------------------------- !< Calculate the normal of the face defined by the 3 points vector pt1, pt2 and pt3. !< !< The convention for the points numeration is the following: !<``` !< 1.----.2 !<   \\   | !<    \\  | !<     \\ | !<      \\| !<       .3 !<``` !< The normal is calculated by the cross product of the side s12 for the side s13: s12 x s13. !< The normal is normalized if the variable 'norm' is passed (with any value). !--------------------------------------------------------------------------------------------------------------------------------- type ( Vector ), intent ( IN ) :: pt1 !< First face point. type ( Vector ), intent ( IN ) :: pt2 !< Second face point. type ( Vector ), intent ( IN ) :: pt3 !< Third face point. character ( 1 ), intent ( IN ), optional :: norm !< If 'norm' is passed as argument the normal is normalized. type ( Vector ) :: fnormal !< Face normal. type ( Vector ) :: s12 !< Face 1-2 diagonals. type ( Vector ) :: s13 !< Face 1-3 diagonals. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- s12 = pt2 - pt1 s13 = pt3 - pt1 if ( present ( norm )) then fnormal = normalize ( s12 . cross . s13 ) else fnormal = 0.5_R8P * ( s12 . cross . s13 ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction face_normal3 elemental subroutine init_vector_self ( vec ) !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize components of Vector variable. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( INOUT ) :: vec !< Vector. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- vec % x = 0._R8P vec % y = 0._R8P vec % z = 0._R8P return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init_vector_self elemental subroutine set_vector_self ( vec , x , y , z ) !--------------------------------------------------------------------------------------------------------------------------------- !< Set components of Vector variable. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( INOUT ) :: vec !< Vector. real ( R8P ), intent ( IN ), optional :: x !< Cartesian component in x direction. real ( R8P ), intent ( IN ), optional :: y !< Cartesian component in y direction. real ( R8P ), intent ( IN ), optional :: z !< Cartesian component in z direction. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( x )) vec % x = x if ( present ( y )) vec % y = y if ( present ( z )) vec % z = z return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine set_vector_self function iolen_vector_self ( vec ) result ( iolen ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute IO length. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: vec !< Vector. integer ( I4P ) :: iolen !< IO length. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- inquire ( iolength = iolen ) vec % x , vec % y , vec % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction iolen_vector_self subroutine load_vector_self ( vec , unit , pos , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Load Vector data. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( INOUT ) :: vec !< Vector data. integer ( I4P ), intent ( IN ) :: unit !< Logic unit. integer ( I8P ), optional , intent ( IN ) :: pos !< Position specifier. integer ( I4P ), optional , intent ( OUT ) :: iostat !< IO error. character ( * ), optional , intent ( OUT ) :: iomsg !< IO error message. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< Temporary variable for IO error message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( pos )) then read ( unit = unit , pos = pos , iostat = iostatd , iomsg = iomsgd ) vec % x , vec % y , vec % z else read ( unit = unit , iostat = iostatd , iomsg = iomsgd ) vec % x , vec % y , vec % z endif if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = trim ( adjustl ( iomsgd )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine load_vector_self subroutine save_vector_self ( vec , unit , pos , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save Vector data. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: vec !< Vector data. integer ( I4P ), intent ( IN ) :: unit !< Logic unit. integer ( I8P ), optional , intent ( IN ) :: pos !< Position specifier. integer ( I4P ), optional , intent ( OUT ) :: iostat !< IO error. character ( * ), optional , intent ( OUT ) :: iomsg !< IO error message. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< Temporary variable for IO error message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( pos )) then write ( unit = unit , pos = pos , iostat = iostatd , iomsg = iomsgd ) vec % x , vec % y , vec % z else write ( unit = unit , iostat = iostatd , iomsg = iomsgd ) vec % x , vec % y , vec % z endif if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = trim ( adjustl ( iomsgd )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_vector_self subroutine print_vector_self ( vec , unit , pref , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Print in a pretty ascii format the components of type Vector. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: vec !< Vector. integer ( I4P ), optional , intent ( IN ) :: unit !< Logic unit. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string for outputs. integer ( I4P ), optional , intent ( OUT ) :: iostat !< IO error. character ( * ), optional , intent ( OUT ) :: iomsg !< IO error message. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: unitd !< Logic unit. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< Temporary variable for IO error message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- unitd = stdout ; if ( present ( unit )) unitd = unit prefd = '' ; if ( present ( pref )) prefd = pref write ( unitd , '(A)' , iostat = iostatd , iomsg = iomsgd ) pref // ' Component x ' // str ( n = vec % x ) write ( unitd , '(A)' , iostat = iostatd , iomsg = iomsgd ) pref // ' Component y ' // str ( n = vec % y ) write ( unitd , '(A)' , iostat = iostatd , iomsg = iomsgd ) pref // ' Component z ' // str ( n = vec % z ) if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = trim ( adjustl ( iomsgd )) return !--------------------------------------------------------------------------------------------------------------------------------- contains elemental function str ( n ) result ( str_ ) !------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting real to string. This function achieves casting of real to string. !------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( IN ) :: n !< Real to be converted. character ( DR8P ) :: str_ !< Returned string containing input number. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- write ( str_ , FR8P ) n ! Casting of n to string. if ( n > 0._R8P ) str_ ( 1 : 1 ) = '+' ! Prefixing plus if n>0. return !------------------------------------------------------------------------------------------------------------------------------- endfunction str endsubroutine print_vector_self elemental subroutine normalize_self ( vec ) !--------------------------------------------------------------------------------------------------------------------------------- !< Normalize a vector. !< !< The normalization is made by means of norm L2. If the norm L2 of the vector is less than the parameter smallR8P the !< normalization value is set to normL2(vec)+smallR8P. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( INOUT ) :: vec !< Vector to be normalized. real ( R8P ) :: nm !< Norm L2 of vector. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- nm = normL2 ( vec ) if ( nm < smallR8P ) then nm = nm + smallR8P endif vec % x = vec % x / nm vec % y = vec % y / nm vec % z = vec % z / nm return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine normalize_self elemental function normalized_self ( vec ) result ( norm ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get a normalized copy of a vector. !< !< The normalization is made by means of norm L2. If the norm L2 of the vector is less than the parameter smallR8P the !< normalization value is set to normL2(vec)+smallR8P. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: vec !< Vector to be normalized. type ( Vector ) :: norm !< Normalized copy. real ( R8P ) :: nm !< Norm L2 of vector. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- nm = normL2 ( vec ) if ( nm < smallR8P ) then nm = nm + smallR8P endif norm % x = vec % x / nm norm % y = vec % y / nm norm % z = vec % z / nm return !--------------------------------------------------------------------------------------------------------------------------------- endfunction normalized_self elemental function sq_norm_self ( vec ) result ( sq ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the square of the norm of a vector. !< !< The square norm if defined as  N = x&#94;2  + y&#94;2  + z&#94;2 . !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: vec !< Vector. real ( R8P ) :: sq !< Square of the Norm. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- sq = ( vec % x * vec % x ) + ( vec % y * vec % y ) + ( vec % z * vec % z ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sq_norm_self elemental function normL2_self ( vec ) result ( norm ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the norm L2 of a vector. !< !< The norm L2 if defined as  N = \\sqrt {x&#94;2  + y&#94;2  + z&#94;2 } . !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: vec !< Vector. real ( R8P ) :: norm !< Norm L2. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- norm = sqrt (( vec % x * vec % x ) + ( vec % y * vec % y ) + ( vec % z * vec % z )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction normL2_self elemental subroutine face_normal4_self ( fnormal , pt1 , pt2 , pt3 , pt4 , norm ) !< Calculate the normal of the face defined by 4 points vector pt1, pt2, pt3 and pt4. !< !< The convention for the points numeration is the following: !<``` !< 1.----------.2 !<  |          | !<  |          | !<  |          | !<  |          | !< 4.----------.3 !<``` !< The normal is calculated by the cross product of the diagonal d13 for the diagonal d24: d13 x d24. !< The normal is normalized if the variable *norm* is passed (with any value). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( INOUT ) :: fnormal !< Face normal. type ( Vector ), intent ( IN ) :: pt1 !< First face point. type ( Vector ), intent ( IN ) :: pt2 !< Second face point. type ( Vector ), intent ( IN ) :: pt3 !< Third face point. type ( Vector ), intent ( IN ) :: pt4 !< Fourth face point. character ( 1 ), optional , intent ( IN ) :: norm !< If 'norm' is passed as argument the normal is normalized. type ( Vector ) :: d13 !< Face 1-3 diagonals. type ( Vector ) :: d24 !< Face 2-4 diagonals. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- d13 = pt3 - pt1 d24 = pt4 - pt2 if ( present ( norm )) then fnormal = normalize ( d13 . cross . d24 ) else fnormal = 0.5_R8P * ( d13 . cross . d24 ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine face_normal4_self elemental subroutine face_normal3_self ( fnormal , pt1 , pt2 , pt3 , norm ) !--------------------------------------------------------------------------------------------------------------------------------- !< Calculate the normal of the face defined by the 3 points vector pt1, pt2 and pt3. !< !< The convention for the points numeration is the following: !<``` !< 1.----.2 !<   \\   | !<    \\  | !<     \\ | !<      \\| !<       .3 !<``` !< The normal is calculated by the cross product of the side s12 for the side s13: s12 x s13. !< The normal is normalized if the variable *norm* is passed (with any value). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( INOUT ) :: fnormal !< Face normal. type ( Vector ), intent ( IN ) :: pt1 !< First face point. type ( Vector ), intent ( IN ) :: pt2 !< Second face point. type ( Vector ), intent ( IN ) :: pt3 !< Third face point. character ( 1 ), optional , intent ( IN ) :: norm !< If 'norm' is passed as argument the normal is normalized. type ( Vector ) :: s12 !< Face 1-2 diagonals. type ( Vector ) :: s13 !< Face 1-3 diagonals. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- s12 = pt2 - pt1 s13 = pt3 - pt1 if ( present ( norm )) then fnormal = normalize ( s12 . cross . s13 ) else fnormal = 0.5_R8P * ( s12 . cross . s13 ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine face_normal3_self elemental function crossproduct ( vec1 , vec2 ) result ( cross ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the cross product of 2 vectors. !< !<  \\vec V=\\left({y_1 z_2 - z_1 y_2}\\right)\\vec i + !<           \\left({z_1 x_2 - x_1 z_2}\\right)\\vec j + !<           \\left({x_1 y_2 - y_1 x_2}\\right)\\vec k  !< where  x_i ,  y_i  and  z_i   i=1,2  are the components of the vectors. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: vec1 !< First vector. type ( Vector ), intent ( IN ) :: vec2 !< Second vector. type ( Vector ) :: cross !< Cross product vector. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- cross % x = ( vec1 % y * vec2 % z ) - ( vec1 % z * vec2 % y ) cross % y = ( vec1 % z * vec2 % x ) - ( vec1 % x * vec2 % z ) cross % z = ( vec1 % x * vec2 % y ) - ( vec1 % y * vec2 % x ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction crossproduct elemental function dotproduct ( vec1 , vec2 ) result ( dot ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the scalar (dot) product of 2 vectors. !< !<  {\\rm D}= x_1 \\cdot x_2 + y_1 \\cdot y_2 + z_1 \\cdot z_2  !< where  x_i ,  y_i  and  z_i   i=1,2  are the components of the vectors. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: vec1 !< First vector. type ( Vector ), intent ( IN ) :: vec2 !< Second vector. real ( R8P ) :: dot !< Dot product. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- dot = ( vec1 % x * vec2 % x ) + ( vec1 % y * vec2 % y ) + ( vec1 % z * vec2 % z ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction dotproduct elemental function parallel ( vec1 , vec2 ) result ( paral ) !--------------------------------------------------------------------------------------------------------------------------------- !> Compute the component of vec1 parallel to vec2. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: vec1 !< First vector. type ( Vector ), intent ( IN ) :: vec2 !< Second vector. type ( Vector ) :: paral !< Component of of vec1 parallel to vec2. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- paral = ( vec1 . dot . vec2 ) * normalize ( vec2 ) / normL2 ( vec2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction parallel elemental function orthogonal ( vec1 , vec2 ) result ( ortho ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the component of vec1 orthogonal to vec2. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: vec1 !< First vector. type ( Vector ), intent ( IN ) :: vec2 !< Second vector. type ( Vector ) :: ortho !< Component of of vec1 orthogonal to vec2. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ortho = vec1 - ( vec1 . paral . vec2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction orthogonal ! Operators overloading. ! Operator (=) pure subroutine assign_self ( self1 , self2 ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment between two selfs. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( INOUT ) :: self1 class ( Vector ), intent ( IN ) :: self2 !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self1 % x = self2 % x self1 % y = self2 % y self1 % z = self2 % z return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_self elemental subroutine assign_ScalR16P ( self , scal ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment between a scalar (real R16P) and self. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( INOUT ) :: self real ( R16P ), intent ( IN ) :: scal !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % x = real ( scal , R8P ) self % y = real ( scal , R8P ) self % z = real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_ScalR16P elemental subroutine assign_ScalR8P ( self , scal ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment between a scalar (real R8P) and self. !--------------------------------------------------------------------------------------------------------------------------------- implicit none class ( Vector ), intent ( INOUT ) :: self real ( R8P ), intent ( IN ) :: scal !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % x = real ( scal , R8P ) self % y = real ( scal , R8P ) self % z = real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_ScalR8P elemental subroutine assign_ScalR4P ( self , scal ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment between a scalar (real R4P) and self. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( INOUT ) :: self real ( R4P ), intent ( IN ) :: scal !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % x = real ( scal , R8P ) self % y = real ( scal , R8P ) self % z = real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_ScalR4P elemental subroutine assign_ScalI8P ( self , scal ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment between a scalar (integer I8P) and self. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( INOUT ) :: self integer ( I8P ), intent ( IN ) :: scal !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % x = real ( scal , R8P ) self % y = real ( scal , R8P ) self % z = real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_ScalI8P elemental subroutine assign_ScalI4P ( self , scal ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment between a scalar (integer I4P) and self. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( INOUT ) :: self integer ( I4P ), intent ( IN ) :: scal !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % x = real ( scal , R8P ) self % y = real ( scal , R8P ) self % z = real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_ScalI4P elemental subroutine assign_ScalI2P ( self , scal ) !--------------------------------------------------------------------------------------------------------------------------------- !> Assignment between a scalar (integer I2P) and self. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( INOUT ) :: self integer ( I2P ), intent ( IN ) :: scal !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % x = real ( scal , R8P ) self % y = real ( scal , R8P ) self % z = real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_ScalI2P elemental subroutine assign_ScalI1P ( self , scal ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment between a scalar (integer I1P) and self. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( INOUT ) :: self integer ( I1P ), intent ( IN ) :: scal !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % x = real ( scal , R8P ) self % y = real ( scal , R8P ) self % z = real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_ScalI1P ! Operator (*) elemental function self_mul_self ( self1 , self2 ) result ( mul ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply (by components) two selfs. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self1 type ( Vector ), intent ( IN ) :: self2 type ( Vector ) :: mul !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- mul % x = self1 % x * self2 % x mul % y = self1 % y * self2 % y mul % z = self1 % z * self2 % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_mul_self elemental function ScalR16P_mul_self ( scal , self ) result ( mul ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply scalar (real R16P) for self. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: mul !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- mul % x = real ( scal , R8P ) * self % x mul % y = real ( scal , R8P ) * self % y mul % z = real ( scal , R8P ) * self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalR16P_mul_self elemental function self_mul_ScalR16P ( self , scal ) result ( mul ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply self for scalar (real R16P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self real ( R16P ), intent ( IN ) :: scal type ( Vector ) :: mul !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- mul % x = real ( scal , R8P ) * self % x mul % y = real ( scal , R8P ) * self % y mul % z = real ( scal , R8P ) * self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_mul_ScalR16P elemental function ScalR8P_mul_self ( scal , self ) result ( mul ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply scalar (real R8P) for self. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: mul !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- mul % x = real ( scal , R8P ) * self % x mul % y = real ( scal , R8P ) * self % y mul % z = real ( scal , R8P ) * self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalR8P_mul_self elemental function self_mul_ScalR8P ( self , scal ) result ( mul ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply self for scalar (real R8P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self real ( R8P ), intent ( IN ) :: scal type ( Vector ) :: mul !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- mul % x = real ( scal , R8P ) * self % x mul % y = real ( scal , R8P ) * self % y mul % z = real ( scal , R8P ) * self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_mul_ScalR8P elemental function ScalR4P_mul_self ( scal , self ) result ( mul ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply scalar (real R4P) for self. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: mul !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- mul % x = real ( scal , R8P ) * self % x mul % y = real ( scal , R8P ) * self % y mul % z = real ( scal , R8P ) * self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalR4P_mul_self elemental function self_mul_ScalR4P ( self , scal ) result ( mul ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply self for scalar (real R4P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self real ( R4P ), intent ( IN ) :: scal type ( Vector ) :: mul !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- mul % x = real ( scal , R8P ) * self % x mul % y = real ( scal , R8P ) * self % y mul % z = real ( scal , R8P ) * self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_mul_ScalR4P elemental function ScalI8P_mul_self ( scal , self ) result ( mul ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply scalar (integer I8P) for self. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: mul !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- mul % x = real ( scal , R8P ) * self % x mul % y = real ( scal , R8P ) * self % y mul % z = real ( scal , R8P ) * self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalI8P_mul_self elemental function self_mul_ScalI8P ( self , scal ) result ( mul ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply self for scalar (integer I8P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I8P ), intent ( IN ) :: scal type ( Vector ) :: mul !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- mul % x = real ( scal , R8P ) * self % x mul % y = real ( scal , R8P ) * self % y mul % z = real ( scal , R8P ) * self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_mul_ScalI8P elemental function ScalI4P_mul_self ( scal , self ) result ( mul ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply scalar (integer I4P) for self. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: mul !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- mul % x = real ( scal , R8P ) * self % x mul % y = real ( scal , R8P ) * self % y mul % z = real ( scal , R8P ) * self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalI4P_mul_self elemental function self_mul_ScalI4P ( self , scal ) result ( mul ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply self for scalar (integer I4P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I4P ), intent ( IN ) :: scal type ( Vector ) :: mul !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- mul % x = real ( scal , R8P ) * self % x mul % y = real ( scal , R8P ) * self % y mul % z = real ( scal , R8P ) * self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_mul_ScalI4P elemental function ScalI2P_mul_self ( scal , self ) result ( mul ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply scalar (integer I2P) for self. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: mul !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- mul % x = real ( scal , R8P ) * self % x mul % y = real ( scal , R8P ) * self % y mul % z = real ( scal , R8P ) * self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalI2P_mul_self elemental function self_mul_ScalI2P ( self , scal ) result ( mul ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply self for scalar (integer I2P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I2P ), intent ( IN ) :: scal type ( Vector ) :: mul !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- mul % x = real ( scal , R8P ) * self % x mul % y = real ( scal , R8P ) * self % y mul % z = real ( scal , R8P ) * self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_mul_ScalI2P elemental function ScalI1P_mul_self ( scal , self ) result ( mul ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply scalar (integer I1P) for self. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: mul !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- mul % x = real ( scal , R8P ) * self % x mul % y = real ( scal , R8P ) * self % y mul % z = real ( scal , R8P ) * self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalI1P_mul_self elemental function self_mul_ScalI1P ( self , scal ) result ( mul ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply self for scalar (integer I1P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I1P ), intent ( IN ) :: scal type ( Vector ) :: mul !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- mul % x = real ( scal , R8P ) * self % x mul % y = real ( scal , R8P ) * self % y mul % z = real ( scal , R8P ) * self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_mul_ScalI1P ! Operator (/) elemental function self_div_self ( self1 , self2 ) result ( div ) !--------------------------------------------------------------------------------------------------------------------------------- !< Divide self for self. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self1 type ( Vector ), intent ( IN ) :: self2 type ( Vector ) :: div !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- div % x = self1 % x / self2 % x div % y = self1 % y / self2 % y div % z = self1 % z / self2 % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_div_self elemental function self_div_ScalR16P ( self , scal ) result ( div ) !--------------------------------------------------------------------------------------------------------------------------------- !< Divide self for scalar (real R16P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self real ( R16P ), intent ( IN ) :: scal type ( Vector ) :: div !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- div % x = self % x / real ( scal , R8P ) div % y = self % y / real ( scal , R8P ) div % z = self % z / real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_div_ScalR16P elemental function self_div_ScalR8P ( self , scal ) result ( div ) !--------------------------------------------------------------------------------------------------------------------------------- !< Divide self for scalar (real R8P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self real ( R8P ), intent ( IN ) :: scal type ( Vector ) :: div !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- div % x = self % x / real ( scal , R8P ) div % y = self % y / real ( scal , R8P ) div % z = self % z / real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_div_ScalR8P elemental function self_div_ScalR4P ( self , scal ) result ( div ) !--------------------------------------------------------------------------------------------------------------------------------- !< Divide self for scalar (real R4P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self real ( R4P ), intent ( IN ) :: scal type ( Vector ) :: div !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- div % x = self % x / real ( scal , R8P ) div % y = self % y / real ( scal , R8P ) div % z = self % z / real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_div_ScalR4P elemental function self_div_ScalI8P ( self , scal ) result ( div ) !--------------------------------------------------------------------------------------------------------------------------------- !< Divide self for scalar (integer I8P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I8P ), intent ( IN ) :: scal type ( Vector ) :: div !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- div % x = self % x / real ( scal , R8P ) div % y = self % y / real ( scal , R8P ) div % z = self % z / real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_div_ScalI8P elemental function self_div_ScalI4P ( self , scal ) result ( div ) !--------------------------------------------------------------------------------------------------------------------------------- !< Divide self for scalar (integer I4P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I4P ), intent ( IN ) :: scal type ( Vector ) :: div !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- div % x = self % x / real ( scal , R8P ) div % y = self % y / real ( scal , R8P ) div % z = self % z / real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_div_ScalI4P elemental function self_div_ScalI2P ( self , scal ) result ( div ) !--------------------------------------------------------------------------------------------------------------------------------- !< Divide self for scalar (integer I2P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I2P ), intent ( IN ) :: scal type ( Vector ) :: div !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- div % x = self % x / real ( scal , R8P ) div % y = self % y / real ( scal , R8P ) div % z = self % z / real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_div_ScalI2P elemental function self_div_ScalI1P ( self , scal ) result ( div ) !--------------------------------------------------------------------------------------------------------------------------------- !< Divide self for scalar (integer I1P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I1P ), intent ( IN ) :: scal type ( Vector ) :: div !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- div % x = self % x / real ( scal , R8P ) div % y = self % y / real ( scal , R8P ) div % z = self % z / real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_div_ScalI1P ! Operator (+) elemental function positive_self ( self ) result ( pos ) !--------------------------------------------------------------------------------------------------------------------------------- !< Applay unary + to a self. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self type ( Vector ) :: pos !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pos % x = + self % x pos % y = + self % y pos % z = + self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction positive_self elemental function self_sum_self ( self1 , self2 ) result ( summ ) !--------------------------------------------------------------------------------------------------------------------------------- !< Sum self and self. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self1 type ( Vector ), intent ( IN ) :: self2 type ( Vector ) :: summ !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- summ % x = self1 % x + self2 % x summ % y = self1 % y + self2 % y summ % z = self1 % z + self2 % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_sum_self elemental function ScalR16P_sum_self ( scal , self ) result ( summ ) !--------------------------------------------------------------------------------------------------------------------------------- !< Sum scalar (real R16P) and self. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: summ !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- summ % x = real ( scal , R8P ) + self % x summ % y = real ( scal , R8P ) + self % y summ % z = real ( scal , R8P ) + self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalR16P_sum_self elemental function self_sum_ScalR16P ( self , scal ) result ( summ ) !--------------------------------------------------------------------------------------------------------------------------------- !< Sum self and scalar (real R16P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self real ( R16P ), intent ( IN ) :: scal type ( Vector ) :: summ !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- summ % x = real ( scal , R8P ) + self % x summ % y = real ( scal , R8P ) + self % y summ % z = real ( scal , R8P ) + self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_sum_ScalR16P elemental function ScalR8P_sum_self ( scal , self ) result ( summ ) !--------------------------------------------------------------------------------------------------------------------------------- !< Sum scalar (real R8P) and self. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: summ !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- summ % x = real ( scal , R8P ) + self % x summ % y = real ( scal , R8P ) + self % y summ % z = real ( scal , R8P ) + self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalR8P_sum_self elemental function self_sum_ScalR8P ( self , scal ) result ( summ ) !--------------------------------------------------------------------------------------------------------------------------------- !< Sum self and scalar (real R8P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self real ( R8P ), intent ( IN ) :: scal type ( Vector ) :: summ !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- summ % x = real ( scal , R8P ) + self % x summ % y = real ( scal , R8P ) + self % y summ % z = real ( scal , R8P ) + self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_sum_ScalR8P elemental function ScalR4P_sum_self ( scal , self ) result ( summ ) !--------------------------------------------------------------------------------------------------------------------------------- !< Sum scalar (real R4P) and self. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: summ !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- summ % x = real ( scal , R8P ) + self % x summ % y = real ( scal , R8P ) + self % y summ % z = real ( scal , R8P ) + self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalR4P_sum_self elemental function self_sum_ScalR4P ( self , scal ) result ( summ ) !--------------------------------------------------------------------------------------------------------------------------------- !< Sum self and scalar (real R4P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self real ( R4P ), intent ( IN ) :: scal type ( Vector ) :: summ !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- summ % x = real ( scal , R8P ) + self % x summ % y = real ( scal , R8P ) + self % y summ % z = real ( scal , R8P ) + self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_sum_ScalR4P elemental function ScalI8P_sum_self ( scal , self ) result ( summ ) !--------------------------------------------------------------------------------------------------------------------------------- !< Sum scalar (integer I8P) and self. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: summ !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- summ % x = real ( scal , R8P ) + self % x summ % y = real ( scal , R8P ) + self % y summ % z = real ( scal , R8P ) + self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalI8P_sum_self elemental function self_sum_ScalI8P ( self , scal ) result ( summ ) !--------------------------------------------------------------------------------------------------------------------------------- !< Sum self and scalar (integer I8P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I8P ), intent ( IN ) :: scal type ( Vector ) :: summ !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- summ % x = real ( scal , R8P ) + self % x summ % y = real ( scal , R8P ) + self % y summ % z = real ( scal , R8P ) + self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_sum_ScalI8P elemental function ScalI4P_sum_self ( scal , self ) result ( summ ) !--------------------------------------------------------------------------------------------------------------------------------- !< Sum scalar (integer I4P) and self. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: summ !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- summ % x = real ( scal , R8P ) + self % x summ % y = real ( scal , R8P ) + self % y summ % z = real ( scal , R8P ) + self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalI4P_sum_self elemental function self_sum_ScalI4P ( self , scal ) result ( summ ) !--------------------------------------------------------------------------------------------------------------------------------- !< Sum self and scalar (integer I4P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I4P ), intent ( IN ) :: scal type ( Vector ) :: summ !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- summ % x = real ( scal , R8P ) + self % x summ % y = real ( scal , R8P ) + self % y summ % z = real ( scal , R8P ) + self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_sum_ScalI4P elemental function ScalI2P_sum_self ( scal , self ) result ( summ ) !--------------------------------------------------------------------------------------------------------------------------------- !< Sum scalar (integer I2P) and self. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: summ !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- summ % x = real ( scal , R8P ) + self % x summ % y = real ( scal , R8P ) + self % y summ % z = real ( scal , R8P ) + self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalI2P_sum_self elemental function self_sum_ScalI2P ( self , scal ) result ( summ ) !--------------------------------------------------------------------------------------------------------------------------------- !< Sum self and scalar (integer I2P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I2P ), intent ( IN ) :: scal type ( Vector ) :: summ !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- summ % x = real ( scal , R8P ) + self % x summ % y = real ( scal , R8P ) + self % y summ % z = real ( scal , R8P ) + self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_sum_ScalI2P elemental function ScalI1P_sum_self ( scal , self ) result ( summ ) !--------------------------------------------------------------------------------------------------------------------------------- !< Sum scalar (integer I1P) and self. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: summ !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- summ % x = real ( scal , R8P ) + self % x summ % y = real ( scal , R8P ) + self % y summ % z = real ( scal , R8P ) + self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalI1P_sum_self elemental function self_sum_ScalI1P ( self , scal ) result ( summ ) !--------------------------------------------------------------------------------------------------------------------------------- !< Sum self and scalar (integer I1P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I1P ), intent ( IN ) :: scal type ( Vector ) :: summ !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- summ % x = real ( scal , R8P ) + self % x summ % y = real ( scal , R8P ) + self % y summ % z = real ( scal , R8P ) + self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_sum_ScalI1P ! Operator (-) elemental function negative_self ( self ) result ( neg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Applay unary - to a self. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self type ( Vector ) :: neg !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- neg % x = - self % x neg % y = - self % y neg % z = - self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction negative_self elemental function self_sub_self ( self1 , self2 ) result ( sub ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract self and self. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self1 type ( Vector ), intent ( IN ) :: self2 type ( Vector ) :: sub !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- sub % x = self1 % x - self2 % x sub % y = self1 % y - self2 % y sub % z = self1 % z - self2 % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_sub_self elemental function ScalR16P_sub_self ( scal , self ) result ( sub ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract scalar (real R16P) and self. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: sub !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- sub % x = real ( scal , R8P ) - self % x sub % y = real ( scal , R8P ) - self % y sub % z = real ( scal , R8P ) - self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalR16P_sub_self elemental function self_sub_ScalR16P ( self , scal ) result ( sub ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract self and scalar (real R16P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self real ( R16P ), intent ( IN ) :: scal type ( Vector ) :: sub !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- sub % x = self % x - real ( scal , R8P ) sub % y = self % y - real ( scal , R8P ) sub % z = self % z - real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_sub_ScalR16P elemental function ScalR8P_sub_self ( scal , self ) result ( sub ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract scalar (real R8P) and self. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: sub !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- sub % x = real ( scal , R8P ) - self % x sub % y = real ( scal , R8P ) - self % y sub % z = real ( scal , R8P ) - self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalR8P_sub_self elemental function self_sub_ScalR8P ( self , scal ) result ( sub ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract self and scalar (real R8P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self real ( R8P ), intent ( IN ) :: scal type ( Vector ) :: sub !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- sub % x = self % x - real ( scal , R8P ) sub % y = self % y - real ( scal , R8P ) sub % z = self % z - real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_sub_ScalR8P elemental function ScalR4P_sub_self ( scal , self ) result ( sub ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract scalar (real R4P) and self. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: sub !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- sub % x = real ( scal , R8P ) - self % x sub % y = real ( scal , R8P ) - self % y sub % z = real ( scal , R8P ) - self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalR4P_sub_self elemental function self_sub_ScalR4P ( self , scal ) result ( sub ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract self and scalar (real R4P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self real ( R4P ), intent ( IN ) :: scal type ( Vector ) :: sub !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- sub % x = self % x - real ( scal , R8P ) sub % y = self % y - real ( scal , R8P ) sub % z = self % z - real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_sub_ScalR4P elemental function ScalI8P_sub_self ( scal , self ) result ( sub ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract scalar (integer I8P) and self. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: sub !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- sub % x = real ( scal , R8P ) - self % x sub % y = real ( scal , R8P ) - self % y sub % z = real ( scal , R8P ) - self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalI8P_sub_self elemental function self_sub_ScalI8P ( self , scal ) result ( sub ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract self and scalar (integer I8P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I8P ), intent ( IN ) :: scal type ( Vector ) :: sub !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- sub % x = self % x - real ( scal , R8P ) sub % y = self % y - real ( scal , R8P ) sub % z = self % z - real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_sub_ScalI8P elemental function ScalI4P_sub_self ( scal , self ) result ( sub ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract scalar (integer I4P) and self. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: sub !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- sub % x = real ( scal , R8P ) - self % x sub % y = real ( scal , R8P ) - self % y sub % z = real ( scal , R8P ) - self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalI4P_sub_self elemental function self_sub_ScalI4P ( self , scal ) result ( sub ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract self and scalar (integer I4P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I4P ), intent ( IN ) :: scal type ( Vector ) :: sub !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- sub % x = self % x - real ( scal , R8P ) sub % y = self % y - real ( scal , R8P ) sub % z = self % z - real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_sub_ScalI4P elemental function ScalI2P_sub_self ( scal , self ) result ( sub ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract scalar (integer I2P) and self. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: sub !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- sub % x = real ( scal , R8P ) - self % x sub % y = real ( scal , R8P ) - self % y sub % z = real ( scal , R8P ) - self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalI2P_sub_self elemental function self_sub_ScalI2P ( self , scal ) result ( sub ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract self and scalar (integer I2P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I2P ), intent ( IN ) :: scal type ( Vector ) :: sub !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- sub % x = self % x - real ( scal , R8P ) sub % y = self % y - real ( scal , R8P ) sub % z = self % z - real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_sub_ScalI2P elemental function ScalI1P_sub_self ( scal , self ) result ( sub ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract scalar (integer I1P) and self. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: sub !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- sub % x = real ( scal , R8P ) - self % x sub % y = real ( scal , R8P ) - self % y sub % z = real ( scal , R8P ) - self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalI1P_sub_self elemental function self_sub_ScalI1P ( self , scal ) result ( sub ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract self and scalar (integer I1P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I1P ), intent ( IN ) :: scal type ( Vector ) :: sub !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- sub % x = self % x - real ( scal , R8P ) sub % y = self % y - real ( scal , R8P ) sub % z = self % z - real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_sub_ScalI1P ! Conditional operators ! Oprator /= elemental function self_not_eq_self ( self1 , self2 ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is /= with respect the normL2 of self2 or if the directions of self1 !< and self2 are different, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self1 !< First selftor. type ( Vector ), intent ( IN ) :: self2 !< Second selftor. logical :: compare !< The result of the comparison. type ( Vector ) :: n1 !< Normalizations of self1. type ( Vector ) :: n2 !< Normalizations of self2. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self1 ) /= normL2 ( self2 )) if (. not . compare ) then ! the normL2 are the same, checking the directions n1 = normalize ( self1 ) n2 = normalize ( self2 ) compare = (( n1 % x /= n2 % x ). OR .( n1 % y /= n2 % y ). OR .( n1 % z /= n2 % z )) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_not_eq_self elemental function R16P_not_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) /= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction R16P_not_eq_self elemental function self_not_eq_R16P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self real ( R16P ), intent ( IN ) :: scal logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) /= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_not_eq_R16P elemental function R8P_not_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) /= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction R8P_not_eq_self elemental function self_not_eq_R8P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self real ( R8P ), intent ( IN ) :: scal logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) /= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_not_eq_R8P elemental function R4P_not_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) /= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction R4P_not_eq_self elemental function self_not_eq_R4P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self real ( R4P ), intent ( IN ) :: scal logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) /= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_not_eq_R4P elemental function I8P_not_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) /= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I8P_not_eq_self elemental function self_not_eq_I8P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I8P ), intent ( IN ) :: scal logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) /= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_not_eq_I8P elemental function I4P_not_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) /= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I4P_not_eq_self elemental function self_not_eq_I4P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I4P ), intent ( IN ) :: scal logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) /= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_not_eq_I4P elemental function I2P_not_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) /= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I2P_not_eq_self elemental function self_not_eq_I2P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I2P ), intent ( IN ) :: scal logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) /= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_not_eq_I2P elemental function I1P_not_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) /= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I1P_not_eq_self elemental function self_not_eq_I1P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I1P ), intent ( IN ) :: scal logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) /= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_not_eq_I1P ! Oprator < elemental function self_low_self ( self1 , self2 ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is < with respect the normL2 of self2, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self1 type ( Vector ), intent ( IN ) :: self2 logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self1 ) < normL2 ( self2 )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_low_self elemental function R16P_low_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) < normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction R16P_low_self elemental function self_low_R16P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self real ( R16P ), intent ( IN ) :: scal logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) < real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_low_R16P elemental function R8P_low_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) < normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction R8P_low_self elemental function self_low_R8P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self real ( R8P ), intent ( IN ) :: scal logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) < real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_low_R8P elemental function R4P_low_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) < normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction R4P_low_self elemental function self_low_R4P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self real ( R4P ), intent ( IN ) :: scal logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) < real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_low_R4P elemental function I8P_low_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) < normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I8P_low_self elemental function self_low_I8P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I8P ), intent ( IN ) :: scal logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) < real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_low_I8P elemental function I4P_low_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) < normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I4P_low_self elemental function self_low_I4P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I4P ), intent ( IN ) :: scal logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) < real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_low_I4P elemental function I2P_low_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) < normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I2P_low_self elemental function self_low_I2P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I2P ), intent ( IN ) :: scal logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) < real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_low_I2P elemental function I1P_low_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) < normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I1P_low_self elemental function self_low_I1P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I1P ), intent ( IN ) :: scal logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) < real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_low_I1P ! Oprator <= elemental function self_low_eq_self ( self1 , self2 ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is <= with respect the normL2 of self2, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self1 ! First selftor. type ( Vector ), intent ( IN ) :: self2 ! Second selftor. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self1 ) <= normL2 ( self2 )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_low_eq_self elemental function R16P_low_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) <= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction R16P_low_eq_self elemental function self_low_eq_R16P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. real ( R16P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) <= real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_low_eq_R16P elemental function R8P_low_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) <= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction R8P_low_eq_self elemental function self_low_eq_R8P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. real ( R8P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) <= real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_low_eq_R8P elemental function R4P_low_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) <= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction R4P_low_eq_self elemental function self_low_eq_R4P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. real ( R4P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) <= real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_low_eq_R4P elemental function I8P_low_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) <= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I8P_low_eq_self elemental function self_low_eq_I8P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. integer ( I8P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) <= real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_low_eq_I8P elemental function I4P_low_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) <= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I4P_low_eq_self elemental function self_low_eq_I4P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. integer ( I4P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) <= real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_low_eq_I4P elemental function I2P_low_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) <= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I2P_low_eq_self elemental function self_low_eq_I2P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. integer ( I2P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) <= real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_low_eq_I2P elemental function I1P_low_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) <= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I1P_low_eq_self elemental function self_low_eq_I1P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. integer ( I1P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) <= real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_low_eq_I1P ! Oprator == elemental function self_eq_self ( self1 , self2 ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !> Return .true. if the normL2 of the self1 is = with respect the normL2 of self2 and the directions of !> self1 and self2 are the same, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self1 ! First selftor. type ( Vector ), intent ( IN ) :: self2 ! Second selftor. logical :: compare ! The result of the comparison. type ( Vector ) :: n1 ! Normalizations of self1. type ( Vector ) :: n2 ! Normalizations of self2. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self1 ) == normL2 ( self2 )) if ( compare ) then ! the normL2 are the same, checking the directions n1 = normalize ( self1 ) n2 = normalize ( self2 ) compare = (( n1 % x == n2 % x ). AND .( n1 % y == n2 % y ). AND .( n1 % z == n2 % z )) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_eq_self elemental function R16P_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) == real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction R16P_eq_self elemental function self_eq_R16P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. real ( R16P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) == real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_eq_R16P elemental function R8P_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) == real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction R8P_eq_self elemental function self_eq_R8P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. real ( R8P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) == real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_eq_R8P elemental function R4P_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) == real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction R4P_eq_self elemental function self_eq_R4P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. real ( R4P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) == real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_eq_R4P elemental function I8P_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) == real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I8P_eq_self elemental function self_eq_I8P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. integer ( I8P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) == real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_eq_I8P elemental function I4P_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< @brief Procedure returns .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) == real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I4P_eq_self elemental function self_eq_I4P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. integer ( I4P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) == real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_eq_I4P elemental function I2P_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) == real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I2P_eq_self elemental function self_eq_I2P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. integer ( I2P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) == real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_eq_I2P elemental function I1P_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) == real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I1P_eq_self elemental function self_eq_I1P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. integer ( I1P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) == real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_eq_I1P ! Oprator >= elemental function self_great_eq_self ( self1 , self2 ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is >= with respect the normL2 of self2, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self1 ! First selftor. type ( Vector ), intent ( IN ) :: self2 ! Second selftor. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self1 ) >= normL2 ( self2 )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_great_eq_self elemental function R16P_great_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) >= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction R16P_great_eq_self elemental function self_great_eq_R16P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. real ( R16P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) >= real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_great_eq_R16P elemental function R8P_great_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) >= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction R8P_great_eq_self elemental function self_great_eq_R8P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. real ( R8P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) >= real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_great_eq_R8P elemental function R4P_great_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) >= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction R4P_great_eq_self elemental function self_great_eq_R4P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. real ( R4P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) >= real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_great_eq_R4P elemental function I8P_great_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) >= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I8P_great_eq_self elemental function self_great_eq_I8P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. integer ( I8P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) >= real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_great_eq_I8P elemental function I4P_great_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) >= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I4P_great_eq_self elemental function self_great_eq_I4P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. integer ( I4P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) >= real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_great_eq_I4P elemental function I2P_great_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) >= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I2P_great_eq_self elemental function self_great_eq_I2P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. integer ( I2P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) >= real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_great_eq_I2P elemental function I1P_great_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) >= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I1P_great_eq_self elemental function self_great_eq_I1P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. integer ( I1P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) >= real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_great_eq_I1P ! Oprator > elemental function self_great_self ( self1 , self2 ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is > with respect the normL2 of self2, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self1 ! First selftor. type ( Vector ), intent ( IN ) :: self2 ! Second selftor. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self1 ) > normL2 ( self2 )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_great_self elemental function R16P_great_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) > normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction R16P_great_self elemental function self_great_R16P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. real ( R16P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) > real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_great_R16P elemental function R8P_great_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) > normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction R8P_great_self elemental function self_great_R8P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. real ( R8P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) > real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_great_R8P elemental function R4P_great_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) > normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction R4P_great_self elemental function self_great_R4P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. real ( R4P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) > real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_great_R4P elemental function I8P_great_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) > normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I8P_great_self elemental function self_great_I8P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. integer ( I8P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) > real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_great_I8P elemental function I4P_great_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) > normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I4P_great_self elemental function self_great_I4P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. integer ( I4P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) > real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_great_I4P elemental function I2P_great_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) > normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I2P_great_self elemental function self_great_I2P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. integer ( I2P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) > real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_great_I2P elemental function I1P_great_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) > normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I1P_great_self elemental function self_great_I1P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. integer ( I1P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) > real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_great_I1P endmodule VecFor","tags":"","loc":"sourcefile/vecfor.f90.html","title":"vecfor.F90 – FLOw"},{"text":"type, public, extends( conservative_object ) :: conservative_compressible type~~conservative_compressible~~InheritsGraph type~conservative_compressible conservative_compressible vector vector vector->type~conservative_compressible momentum type~conservative_object conservative_object type~conservative_object->type~conservative_compressible type~field_object field_object type~field_object->type~conservative_object Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Conservative compressible multispecie object. Variables density energy momentum Constructor conservative_compressible Type-Bound Procedures add array assign_field assign_real assignment(=) compute_fluxes compute_fluxes_from_primitive description destroy div div_integer div_real eq initialize integer_mul mul mul_integer mul_real negative not_eq operator(*) operator(**) operator(+) operator(-) operator(/) operator(/=) operator(==) positive pow_integer pow_real pressure real_mul sub velocity Source Code conservative_compressible Components Type Visibility Attributes Name Initial real(kind=R8P), public :: density = 0._R8P Density, rho . real(kind=R8P), public :: energy = 0._R8P Energy, rho * E , rho being the density and E the specific energy. type(vector), public :: momentum Momentum, rho * v , rho being the density and v the velocity vector. Constructor public interface conservative_compressible Overload conservative_compressible name with its constructor. private pure function conservative_compressible_instance (density, velocity, pressure) result(instance) Return and instance of conservative_compressible . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in), optional :: density Density field. type(vector), intent(in), optional :: velocity Velocity field. real(kind=R8P), intent(in), optional :: pressure Pressure field. Return Value type( conservative_compressible ) Instance of conservative_compressible . Type-Bound Procedures procedure, public, pass(lhs) :: add Operator + . private elemental function add (lhs, rhs) result(opr) Operator + . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(self) :: array Return serialized array of field. private pure function array (self) result(array_) Return serialized array of field. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: self Conservative. Return Value real(kind=R8P),\n  allocatable, (:) Serialized array of field. procedure, public, pass(lhs) :: assign_field Operator = . private elemental subroutine assign_field (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(inout) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. procedure, public, pass(lhs) :: assign_real Operator field = real . private elemental subroutine assign_real (lhs, rhs) Operator field = real . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(inout) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. generic, public :: assignment(=) => assign_field , assign_real Assignment overloading. private elemental subroutine assign_field (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(inout) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. private elemental subroutine assign_real (lhs, rhs) Operator field = real . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(inout) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. procedure, public, pass(self) :: compute_fluxes Compute conservative fluxes. private subroutine compute_fluxes (self, eos, normal, fluxes) Compute conservative fluxes. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: self Conservative. class( eos_object ), intent(in) :: eos Equation of state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(out) :: fluxes Conservative fluxes. procedure, public, pass(self) :: compute_fluxes_from_primitive Compute conservative fluxes from primitives at interface. private elemental subroutine compute_fluxes_from_primitive (self, eos, p, r, u, normal) Compute conservative fluxes from primitives at interface. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(inout) :: self Conservative. class( eos_object ), intent(in) :: eos Equation of state. real(kind=R8P), intent(in) :: p Pressure at interface. real(kind=R8P), intent(in) :: r Density at interface. real(kind=R8P), intent(in) :: u Velocity (normal component) at interface. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. procedure, public, pass(self) :: description Return pretty-printed object description. private pure function description (self, prefix) result(desc) Return a pretty-formatted object description. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: self Conservative. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. procedure, public, pass(self) :: destroy Destroy conservative. private elemental subroutine destroy (self) Destroy conservative. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(inout) :: self Conservative. procedure, public, pass(lhs) :: div Operator / . private elemental function div (lhs, rhs) result(opr) Operator / . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: div_integer Operator field / integer . private elemental function div_integer (lhs, rhs) result(opr) Operator field / integer . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: div_real Operator field / real . private elemental function div_real (lhs, rhs) result(opr) Operator field / real . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: eq Operator `=='. private elemental function eq (lhs, rhs) result(opr) Operator `=='. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. procedure, public, pass(self) :: initialize Initialize conservative. private subroutine initialize (self, initial_state) Initialize conservative. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(inout) :: self conservative. class( conservative_object ), intent(in), optional :: initial_state Initial state. procedure, public, pass(rhs) :: integer_mul Operator integer * field . private elemental function integer_mul (lhs, rhs) result(opr) Operator integer * field . Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: lhs Left hand side. class( conservative_compressible ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: mul Operator * . private elemental function mul (lhs, rhs) result(opr) Operator * . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: mul_integer Operator field * integer . private elemental function mul_integer (lhs, rhs) result(opr) Operator field * integer . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: mul_real Operator field * real . private elemental function mul_real (lhs, rhs) result(opr) Operator field * real . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(self) :: negative Unary operator - field . private function negative (self) result(opr) Unary operator - field . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: self conservative. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: not_eq Operator `/='. private elemental function not_eq (lhs, rhs) result(opr) Operator `/='. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. generic, public :: operator(*) => mul , mul_integer , integer_mul , real_mul , mul_real Operator * overloading. private elemental function mul (lhs, rhs) result(opr) Operator * . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function mul_integer (lhs, rhs) result(opr) Operator field * integer . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function integer_mul (lhs, rhs) result(opr) Operator integer * field . Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: lhs Left hand side. class( primitive_compressible_multispecie ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function real_mul (lhs, rhs) result(opr) Operator real * field . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs Left hand side. class( primitive_compressible_multispecie ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function mul_real (lhs, rhs) result(opr) Operator field * real . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. generic, public :: operator(**) => pow_integer , pow_real Operator ** overloading. private elemental function pow_integer (lhs, rhs) result(opr) Operator field ** integer . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function pow_real (lhs, rhs) result(opr) Operator field ** real . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. generic, public :: operator(+) => add , positive Operator + overloading. private elemental function add (lhs, rhs) result(opr) Operator + . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private function positive (self) result(opr) Unary operator + field . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: self Primitive. Return Value class( field_object ),\n  allocatable Operator result. generic, public :: operator(-) => sub , negative Operator - overloading. private elemental function sub (lhs, rhs) result(opr) Operator - . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private function negative (self) result(operator_result) Unary operator - field . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: self Primitive. Return Value class( field_object ),\n  allocatable Operator result. generic, public :: operator(/) => div , div_integer , div_real Operator / overloading. private elemental function div (lhs, rhs) result(opr) Operator / . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function div_integer (lhs, rhs) result(opr) Operator field / integer . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function div_real (lhs, rhs) result(opr) Operator field / real . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. generic, public :: operator(/=) => not_eq Operator /= overloading. private elemental function not_eq (lhs, rhs) result(opr) Operator `/='. Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. generic, public :: operator(==) => eq Operator /= overloading. private elemental function eq (lhs, rhs) result(opr) Operator `=='. Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. procedure, public, pass(self) :: positive Unary operator + field . private function positive (self) result(opr) Unary operator + field . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: self conservative. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: pow_integer Operator field ** integer . private elemental function pow_integer (lhs, rhs) result(opr) Operator field ** integer . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: pow_real Operator field ** real . private elemental function pow_real (lhs, rhs) result(opr) Operator field ** real . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(self) :: pressure Return pressure value. private elemental function pressure (self, eos) result(pressure_) Return pressure value. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: self Conservative. class( eos_object ), intent(in) :: eos Equation of state. Return Value real(kind=R8P) Pressure value. procedure, public, pass(rhs) :: real_mul Operator real * field . private elemental function real_mul (lhs, rhs) result(opr) Operator real * field . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs Left hand side. class( conservative_compressible ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: sub Operator - . private elemental function sub (lhs, rhs) result(opr) Operator - . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(self) :: velocity Return velocity vector. private elemental function velocity (self) result(velocity_) Return velocity vector. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: self Conservative. Return Value type(vector) Velocity vector. Source Code type , extends ( conservative_object ) :: conservative_compressible !< **Conservative** compressible multispecie object. real ( R8P ) :: density = 0._R8P !< Density, `rho`. type ( vector ) :: momentum !< Momentum, `rho * v`, `rho` being the density and `v` the velocity vector. real ( R8P ) :: energy = 0._R8P !< Energy, `rho * E`, `rho` being the density and `E` the specific energy. contains ! public methods procedure , pass ( self ) :: compute_fluxes_from_primitive !< Compute conservative fluxes from primitives at interface. ! deferred methods procedure , pass ( self ) :: array !< Return serialized array of field. procedure , pass ( self ) :: compute_fluxes !< Compute conservative fluxes. procedure , pass ( self ) :: description !< Return pretty-printed object description. procedure , pass ( self ) :: destroy !< Destroy conservative. procedure , pass ( self ) :: initialize !< Initialize conservative. procedure , pass ( self ) :: pressure !< Return pressure value. procedure , pass ( self ) :: velocity !< Return velocity vector. ! deferred operators procedure , pass ( lhs ) :: assign_field !< Operator `=`. procedure , pass ( lhs ) :: assign_real !< Operator `field = real`. procedure , pass ( self ) :: positive !< Unary operator `+ field`. procedure , pass ( lhs ) :: add !< Operator `+`. procedure , pass ( lhs ) :: div !< Operator `/`. procedure , pass ( lhs ) :: div_integer !< Operator `field / integer`. procedure , pass ( lhs ) :: div_real !< Operator `field / real`. procedure , pass ( lhs ) :: mul !< Operator `*`. procedure , pass ( lhs ) :: mul_integer !< Operator `field * integer`. procedure , pass ( rhs ) :: integer_mul !< Operator `integer * field`. procedure , pass ( lhs ) :: mul_real !< Operator `field * real`. procedure , pass ( rhs ) :: real_mul !< Operator `real * field`. procedure , pass ( self ) :: negative !< Unary operator `- field`. procedure , pass ( lhs ) :: sub !< Operator `-`. procedure , pass ( lhs ) :: pow_integer !< Operator `field ** integer`. procedure , pass ( lhs ) :: pow_real !< Operator `field ** real`. procedure , pass ( lhs ) :: eq !< Operator `=='. procedure , pass ( lhs ) :: not_eq !< Operator `/='. endtype conservative_compressible","tags":"","loc":"type/conservative_compressible.html","title":"conservative_compressible – FLOw "},{"text":"type, public, abstract, extends( field_object ) :: conservative_object type~~conservative_object~~InheritsGraph type~conservative_object conservative_object type~field_object field_object type~field_object->type~conservative_object Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). conservative object. Inherited By type~~conservative_object~~InheritedByGraph type~conservative_object conservative_object type~conservative_compressible conservative_compressible type~conservative_object->type~conservative_compressible Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Type-Bound Procedures add array assign_field assign_real assignment(=) compute_fluxes description destroy div div_integer div_real eq initialize integer_mul mul mul_integer mul_real negative not_eq operator(*) operator(**) operator(+) operator(-) operator(/) operator(/=) operator(==) positive pow_integer pow_real pressure real_mul sub velocity Source Code conservative_object Type-Bound Procedures procedure( symmetric_op_interface ), public, deferred, pass(lhs) :: add Operator + . elemental function symmetric_op_interface (lhs, rhs) result(opr) Prototype Operator field.op.field . Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure( array_interface ), public, deferred, pass(self) :: array Return serialized array of field. pure function array_interface (self) result(array_) Prototype Return serialized array of field. Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: self Field. Return Value real(kind=R8P),\n  allocatable, (:) Serialized array of field. procedure( assign_interface ), public, deferred, pass(lhs) :: assign_field Operator = . elemental subroutine assign_interface (lhs, rhs) Prototype Operator = . Arguments Type Intent Optional Attributes Name class( field_object ), intent(inout) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. procedure( assign_real_interface ), public, deferred, pass(lhs) :: assign_real Operator field = real . elemental subroutine assign_real_interface (lhs, rhs) Prototype Operator field = real . Arguments Type Intent Optional Attributes Name class( field_object ), intent(inout) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. generic, public :: assignment(=) => assign_field , assign_real Assignment overloading. private elemental subroutine assign_field (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(inout) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. private elemental subroutine assign_real (lhs, rhs) Operator field = real . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(inout) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. procedure( compute_fluxes_interface ), public, deferred, pass(self) :: compute_fluxes Compute conservative fluxes. subroutine compute_fluxes_interface (self, eos, normal, fluxes) Prototype Compute conservative fluxes. Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(in) :: self Conservative. class( eos_object ), intent(in) :: eos Equation of state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(out) :: fluxes Conservative fluxes. procedure( description_interface ), public, deferred, pass(self) :: description Return pretty-printed object description. pure function description_interface (self, prefix) result(desc) Prototype Return a pretty-formatted object description. Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: self Field. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. procedure( destroy_interface ), public, deferred, pass(self) :: destroy Destroy conservative. elemental subroutine destroy_interface (self) Prototype Destroy conservative. Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(inout) :: self conservative. procedure( symmetric_op_interface ), public, deferred, pass(lhs) :: div Operator / . elemental function symmetric_op_interface (lhs, rhs) result(opr) Prototype Operator field.op.field . Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure( field_op_integer_interface ), public, deferred, pass(lhs) :: div_integer Operator field / integer . elemental function field_op_integer_interface (lhs, rhs) result(opr) Prototype Operator field.op.integer . Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure( field_op_real_interface ), public, deferred, pass(lhs) :: div_real Operator field / real . elemental function field_op_real_interface (lhs, rhs) result(opr) Prototype Operator field.op.real . Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure( compare_interface ), public, deferred, pass(lhs) :: eq Operator `=='. elemental function compare_interface (lhs, rhs) result(opr) Prototype Operator `field.compare.field'. Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. procedure( initialize_interface ), public, deferred, pass(self) :: initialize Initialize conservative. subroutine initialize_interface (self, initial_state) Prototype Initialize conservative. Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(inout) :: self conservative. class( conservative_object ), intent(in), optional :: initial_state Initial state. procedure( integer_op_field_interface ), public, deferred, pass(rhs) :: integer_mul Operator integer * field . elemental function integer_op_field_interface (lhs, rhs) result(opr) Prototype Operator field.op.integer . Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure( symmetric_op_interface ), public, deferred, pass(lhs) :: mul Operator * . elemental function symmetric_op_interface (lhs, rhs) result(opr) Prototype Operator field.op.field . Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure( field_op_integer_interface ), public, deferred, pass(lhs) :: mul_integer Operator field * integer . elemental function field_op_integer_interface (lhs, rhs) result(opr) Prototype Operator field.op.integer . Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure( field_op_real_interface ), public, deferred, pass(lhs) :: mul_real Operator field * real . elemental function field_op_real_interface (lhs, rhs) result(opr) Prototype Operator field.op.real . Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure( unary_operator ), public, deferred, pass(self) :: negative Unary operator - field . function unary_operator (self) result(opr) Prototype Unary operator .op.field . Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: self Field. Return Value class( field_object ),\n  allocatable Operator result. procedure( compare_interface ), public, deferred, pass(lhs) :: not_eq Operator `/='. elemental function compare_interface (lhs, rhs) result(opr) Prototype Operator `field.compare.field'. Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. generic, public :: operator(*) => mul , mul_integer , integer_mul , real_mul , mul_real Operator * overloading. private elemental function mul (lhs, rhs) result(opr) Operator * . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function mul_integer (lhs, rhs) result(opr) Operator field * integer . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function integer_mul (lhs, rhs) result(opr) Operator integer * field . Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: lhs Left hand side. class( primitive_compressible_multispecie ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function real_mul (lhs, rhs) result(opr) Operator real * field . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs Left hand side. class( primitive_compressible_multispecie ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function mul_real (lhs, rhs) result(opr) Operator field * real . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. generic, public :: operator(**) => pow_integer , pow_real Operator ** overloading. private elemental function pow_integer (lhs, rhs) result(opr) Operator field ** integer . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function pow_real (lhs, rhs) result(opr) Operator field ** real . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. generic, public :: operator(+) => add , positive Operator + overloading. private elemental function add (lhs, rhs) result(opr) Operator + . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private function positive (self) result(opr) Unary operator + field . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: self Primitive. Return Value class( field_object ),\n  allocatable Operator result. generic, public :: operator(-) => sub , negative Operator - overloading. private elemental function sub (lhs, rhs) result(opr) Operator - . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private function negative (self) result(operator_result) Unary operator - field . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: self Primitive. Return Value class( field_object ),\n  allocatable Operator result. generic, public :: operator(/) => div , div_integer , div_real Operator / overloading. private elemental function div (lhs, rhs) result(opr) Operator / . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function div_integer (lhs, rhs) result(opr) Operator field / integer . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function div_real (lhs, rhs) result(opr) Operator field / real . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. generic, public :: operator(/=) => not_eq Operator /= overloading. private elemental function not_eq (lhs, rhs) result(opr) Operator `/='. Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. generic, public :: operator(==) => eq Operator /= overloading. private elemental function eq (lhs, rhs) result(opr) Operator `=='. Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. procedure( unary_operator ), public, deferred, pass(self) :: positive Unary operator + field . function unary_operator (self) result(opr) Prototype Unary operator .op.field . Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: self Field. Return Value class( field_object ),\n  allocatable Operator result. procedure( field_op_integer_interface ), public, deferred, pass(lhs) :: pow_integer Operator field ** integer . elemental function field_op_integer_interface (lhs, rhs) result(opr) Prototype Operator field.op.integer . Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure( field_op_real_interface ), public, deferred, pass(lhs) :: pow_real Operator field ** real . elemental function field_op_real_interface (lhs, rhs) result(opr) Prototype Operator field.op.real . Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure( pressure_interface ), public, deferred, pass(self) :: pressure Return pressure value. elemental function pressure_interface (self, eos) result(pressure_) Prototype Return pressure value. Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(in) :: self Conservative. class( eos_object ), intent(in) :: eos Equation of state. Return Value real(kind=R8P) Pressure value. procedure( real_op_field_interface ), public, deferred, pass(rhs) :: real_mul Operator real * field . elemental function real_op_field_interface (lhs, rhs) result(opr) Prototype Operator real.op.field . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure( symmetric_op_interface ), public, deferred, pass(lhs) :: sub Operator - . elemental function symmetric_op_interface (lhs, rhs) result(opr) Prototype Operator field.op.field . Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure( velocity_interface ), public, deferred, pass(self) :: velocity Return velocity vector. elemental function velocity_interface (self) result(velocity_) Prototype Return velocity vector. Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(in) :: self Conservative. Return Value type(vector) Velocity vector. Source Code type , extends ( field_object ), abstract :: conservative_object !< **conservative** object. contains ! deferred methods procedure ( compute_fluxes_interface ), pass ( self ), deferred :: compute_fluxes !< Compute conservative fluxes. procedure ( destroy_interface ), pass ( self ), deferred :: destroy !< Destroy conservative. procedure ( initialize_interface ), pass ( self ), deferred :: initialize !< Initialize conservative. procedure ( pressure_interface ), pass ( self ), deferred :: pressure !< Return pressure value. procedure ( velocity_interface ), pass ( self ), deferred :: velocity !< Return velocity vector. endtype conservative_object","tags":"","loc":"type/conservative_object.html","title":"conservative_object – FLOw "},{"text":"type, public, extends( eos_object ) :: eos_compressible type~~eos_compressible~~InheritsGraph type~eos_compressible eos_compressible type~eos_object eos_object type~eos_object->type~eos_compressible Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Equation of state (EOS) of ideal compressible object class. Variables R_ cp_ cv_ delta_ eta_ g_ gm1_ gp1_ Constructor eos_compressible Type-Bound Procedures R assignment(=) compute_derivate cp cv delta density description eos_assign_eos eta g gm1 gp1 internal_energy pressure speed_of_sound temperature total_entalpy Source Code eos_compressible Components Type Visibility Attributes Name Initial real(kind=R8P), private :: R_ = 0._R8P Fluid constant R = cp - cv . real(kind=R8P), private :: cp_ = 0._R8P Specific heat at constant pressure cp . real(kind=R8P), private :: cv_ = 0._R8P Specific heat at constant volume cv . real(kind=R8P), private :: delta_ = 0._R8P (gamma - 1) / 2 . real(kind=R8P), private :: eta_ = 0._R8P 2 * gamma / (gamma - 1) . real(kind=R8P), private :: g_ = 0._R8P Specific heats ratio gamma = cp / cv . real(kind=R8P), private :: gm1_ = 0._R8P gamma - 1 . real(kind=R8P), private :: gp1_ = 0._R8P gamma + 1 . Constructor public interface eos_compressible Overload eos_compressible name with its constructor. private elemental function eos_compressible_instance (cp, cv, gam, R) result(instance) Return and instance of eos_compressible . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in), optional :: cp Specific heat at constant pressure cp value. real(kind=R8P), intent(in), optional :: cv Specific heat at constant volume cv value. real(kind=R8P), intent(in), optional :: gam Specific heats ratio gamma=cp/cv value. real(kind=R8P), intent(in), optional :: R Fluid constant R=cp-cv value. Return Value type( eos_compressible ) Instance of eos_compressible . Type-Bound Procedures procedure, public, pass(self) :: R Return fluid constant R=cp-cv . private elemental function R (self) result(R_) Return fluid constant R=cp-cv . Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. Return Value real(kind=R8P) Fluid constant value. generic, public :: assignment(=) => eos_assign_eos Overload = . private pure subroutine eos_assign_eos (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(inout) :: lhs Left hand side. class( eos_object ), intent(in) :: rhs Right hand side. procedure, public, pass(self) :: compute_derivate Compute derivate quantities (from cp and cv ). private elemental subroutine compute_derivate (self) Compute derivate quantities (from cp and cv ). Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(inout) :: self Equation of state. procedure, public, pass(self) :: cp Return specific heat at constant pressure. private elemental function cp (self) result(cp_) Return specific heat at constant pressure. Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. Return Value real(kind=R8P) cp value. procedure, public, pass(self) :: cv Return specific heat at constant volume. private elemental function cv (self) result(cv_) Return specific heat at constant volume. Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. Return Value real(kind=R8P) cv value. procedure, public, pass(self) :: delta Return (gamma - 1) / 2 . private elemental function delta (self) result(delta_) Return (gamma - 1) / 2 . Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. Return Value real(kind=R8P) (gamma - 1) / 2 value. procedure, public, pass(self) :: density Return density. private elemental function density (self, pressure, speed_of_sound) result(density_) Return density. Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. real(kind=R8P), intent(in) :: pressure Pressure value. real(kind=R8P), intent(in) :: speed_of_sound Speed of sound value. Return Value real(kind=R8P) Density value. procedure, public, pass(self) :: description Return pretty-printed object description. private pure function description (self, prefix) result(desc) Return a pretty-formatted object description. Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. procedure, public, pass(lhs) :: eos_assign_eos Operator = . private pure subroutine eos_assign_eos (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(inout) :: lhs Left hand side. class( eos_object ), intent(in) :: rhs Right hand side. procedure, public, pass(self) :: eta Return 2 * gamma / (gamma - 1) . private elemental function eta (self) result(eta_) Return 2 * gamma / (gamma - 1) . Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. Return Value real(kind=R8P) 2 * gamma / (gamma - 1) value. procedure, public, pass(self) :: g Return specific heats ratio gamma=cp/cv . private elemental function g (self) result(g_) Return specific heats ratio gamma=cp/cv . Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. Return Value real(kind=R8P) Specific heats ratio value. procedure, public, pass(self) :: gm1 Return gamma - 1 . private elemental function gm1 (self) result(gm1_) Return gamma - 1 . Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. Return Value real(kind=R8P) gamma - 1 value. procedure, public, pass(self) :: gp1 Return gamma + 1 . private elemental function gp1 (self) result(gp1_) Return gamma + 1 . Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. Return Value real(kind=R8P) gamma + 1 value. procedure, public, pass(self) :: internal_energy Return specific internal energy. private elemental function internal_energy (self, density, pressure, temperature) result(energy_) Return specific internal energy. Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. real(kind=R8P), intent(in), optional :: density Density value. real(kind=R8P), intent(in), optional :: pressure Pressure value. real(kind=R8P), intent(in), optional :: temperature Temperature value. Return Value real(kind=R8P) Energy value. procedure, public, pass(self) :: pressure Return pressure. private elemental function pressure (self, density, energy, temperature) result(pressure_) Return pressure. Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. real(kind=R8P), intent(in), optional :: density Density value. real(kind=R8P), intent(in), optional :: energy Specific internal energy value. real(kind=R8P), intent(in), optional :: temperature Temperature value. Return Value real(kind=R8P) Pressure value. procedure, public, pass(self) :: speed_of_sound Return speed of sound. private elemental function speed_of_sound (self, density, pressure) result(speed_of_sound_) Return speed of sound. Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. real(kind=R8P), intent(in) :: density Density value. real(kind=R8P), intent(in) :: pressure Pressure value. Return Value real(kind=R8P) Speed of sound value. procedure, public, pass(self) :: temperature Return temperature. private elemental function temperature (self, density, energy, pressure) result(temperature_) Return temperature. Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. real(kind=R8P), intent(in), optional :: density Density value. real(kind=R8P), intent(in), optional :: energy Specific internal energy value. real(kind=R8P), intent(in), optional :: pressure Pressure value. Return Value real(kind=R8P) Temperature value. procedure, public, pass(self) :: total_entalpy Return total specific entalpy. private elemental function total_entalpy (self, density, pressure, velocity_sq_norm) result(entalpy_) Return total specific entalpy. Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. real(kind=R8P), intent(in) :: density Density value. real(kind=R8P), intent(in) :: pressure Pressure value. real(kind=R8P), intent(in) :: velocity_sq_norm Velocity vector square norm ||velocity||&#94;2 . Return Value real(kind=R8P) Total specific entalpy (per unit of mass). Source Code type , extends ( eos_object ) :: eos_compressible !< Equation of state (EOS) of ideal compressible object class. private real ( R8P ) :: cp_ = 0._R8P !< Specific heat at constant pressure `cp`. real ( R8P ) :: cv_ = 0._R8P !< Specific heat at constant volume `cv`. real ( R8P ) :: g_ = 0._R8P !< Specific heats ratio `gamma = cp / cv`. real ( R8P ) :: R_ = 0._R8P !< Fluid constant `R = cp - cv`. real ( R8P ) :: gm1_ = 0._R8P !< `gamma - 1`. real ( R8P ) :: gp1_ = 0._R8P !< `gamma + 1`. real ( R8P ) :: delta_ = 0._R8P !< `(gamma - 1) / 2`. real ( R8P ) :: eta_ = 0._R8P !< `2 * gamma / (gamma - 1)`. contains ! public methods procedure , pass ( self ) :: compute_derivate !< Compute derivate quantities (from `cp` and `cv`). ! deferred methods procedure , pass ( self ) :: cp !< Return specific heat at constant pressure. procedure , pass ( self ) :: cv !< Return specific heat at constant volume. procedure , pass ( self ) :: delta !< Return `(gamma - 1) / 2`. procedure , pass ( self ) :: density !< Return density. procedure , pass ( self ) :: description !< Return pretty-printed object description. procedure , pass ( lhs ) :: eos_assign_eos !< Operator `=`. procedure , pass ( self ) :: eta !< Return `2 * gamma / (gamma - 1)`. procedure , pass ( self ) :: g !< Return specific heats ratio `gamma=cp/cv`. procedure , pass ( self ) :: gm1 !< Return `gamma - 1`. procedure , pass ( self ) :: gp1 !< Return `gamma + 1`. procedure , pass ( self ) :: internal_energy !< Return specific internal energy. procedure , pass ( self ) :: pressure !< Return pressure. procedure , pass ( self ) :: R !< Return fluid constant `R=cp-cv`. procedure , pass ( self ) :: speed_of_sound !< Return speed of sound. procedure , pass ( self ) :: temperature !< Return temperature. procedure , pass ( self ) :: total_entalpy !< Return total specific entalpy. endtype eos_compressible","tags":"","loc":"type/eos_compressible.html","title":"eos_compressible – FLOw "},{"text":"type, public, abstract :: eos_object Equation of State (EOS) object class. Inherited By type~~eos_object~~InheritedByGraph type~eos_object eos_object type~eos_compressible eos_compressible type~eos_object->type~eos_compressible Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Type-Bound Procedures R assignment(=) cp cv delta density description eos_assign_eos eta g gm1 gp1 internal_energy pressure speed_of_sound temperature total_entalpy Source Code eos_object Type-Bound Procedures procedure( scalar_interface ), public, deferred, pass(self) :: R Return fluid constant R=cp-cv . elemental function scalar_interface (self) result(scalar_) Prototype Return a scalar real value by only self data. Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. Return Value real(kind=R8P) Scalar value. generic, public :: assignment(=) => eos_assign_eos Overload = . private pure subroutine eos_assign_eos (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(inout) :: lhs Left hand side. class( eos_object ), intent(in) :: rhs Right hand side. procedure( scalar_interface ), public, deferred, pass(self) :: cp Return specific heat at constant pressure. elemental function scalar_interface (self) result(scalar_) Prototype Return a scalar real value by only self data. Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. Return Value real(kind=R8P) Scalar value. procedure( scalar_interface ), public, deferred, pass(self) :: cv Return specific heat at constant volume. elemental function scalar_interface (self) result(scalar_) Prototype Return a scalar real value by only self data. Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. Return Value real(kind=R8P) Scalar value. procedure( scalar_interface ), public, deferred, pass(self) :: delta Return (gamma - 1) / 2 . elemental function scalar_interface (self) result(scalar_) Prototype Return a scalar real value by only self data. Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. Return Value real(kind=R8P) Scalar value. procedure( density_interface ), public, deferred, pass(self) :: density Return density. elemental function density_interface (self, pressure, speed_of_sound) result(density_) Prototype Return density. Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. real(kind=R8P), intent(in) :: pressure Pressure value. real(kind=R8P), intent(in) :: speed_of_sound Speed of sound value. Return Value real(kind=R8P) Density value. procedure( description_interface ), public, deferred, pass(self) :: description Return pretty-printed object description. pure function description_interface (self, prefix) result(desc) Prototype Return a pretty-formatted object description. Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. procedure( assignment_interface ), public, deferred, pass(lhs) :: eos_assign_eos Operator = . pure subroutine assignment_interface (lhs, rhs) Prototype Operator = . Arguments Type Intent Optional Attributes Name class( eos_object ), intent(inout) :: lhs Left hand side. class( eos_object ), intent(in) :: rhs Right hand side. procedure( scalar_interface ), public, deferred, pass(self) :: eta Return 2 * gamma / (gamma - 1) . elemental function scalar_interface (self) result(scalar_) Prototype Return a scalar real value by only self data. Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. Return Value real(kind=R8P) Scalar value. procedure( scalar_interface ), public, deferred, pass(self) :: g Return specific heats ratio gamma=cp/cv . elemental function scalar_interface (self) result(scalar_) Prototype Return a scalar real value by only self data. Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. Return Value real(kind=R8P) Scalar value. procedure( scalar_interface ), public, deferred, pass(self) :: gm1 Return gamma - 1 . elemental function scalar_interface (self) result(scalar_) Prototype Return a scalar real value by only self data. Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. Return Value real(kind=R8P) Scalar value. procedure( scalar_interface ), public, deferred, pass(self) :: gp1 Return gamma + 1 . elemental function scalar_interface (self) result(scalar_) Prototype Return a scalar real value by only self data. Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. Return Value real(kind=R8P) Scalar value. procedure( internal_energy_interface ), public, deferred, pass(self) :: internal_energy Return specific internal energy. elemental function internal_energy_interface (self, density, pressure, temperature) result(energy_) Prototype Return specific internal energy. Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. real(kind=R8P), intent(in), optional :: density Density value. real(kind=R8P), intent(in), optional :: pressure Pressure value. real(kind=R8P), intent(in), optional :: temperature Temperature value. Return Value real(kind=R8P) Energy value. procedure( pressure_interface ), public, deferred, pass(self) :: pressure Return pressure. elemental function pressure_interface (self, density, energy, temperature) result(pressure_) Prototype Return pressure. Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. real(kind=R8P), intent(in), optional :: density Density value. real(kind=R8P), intent(in), optional :: energy Specific internal energy value. real(kind=R8P), intent(in), optional :: temperature Temperature value. Return Value real(kind=R8P) Pressure value. procedure( speed_of_sound_interface ), public, deferred, pass(self) :: speed_of_sound Return speed of sound. elemental function speed_of_sound_interface (self, density, pressure) result(speed_of_sound_) Prototype Return speed of sound. Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. real(kind=R8P), intent(in) :: density Density value. real(kind=R8P), intent(in) :: pressure Pressure value. Return Value real(kind=R8P) Speed of sound value. procedure( temperature_interface ), public, deferred, pass(self) :: temperature Return temperature. elemental function temperature_interface (self, density, energy, pressure) result(temperature_) Prototype Return temperature. Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. real(kind=R8P), intent(in), optional :: density Density value. real(kind=R8P), intent(in), optional :: energy Specific internal energy value. real(kind=R8P), intent(in), optional :: pressure Pressure value. Return Value real(kind=R8P) Temperature value. procedure( total_entalpy_interface ), public, deferred, pass(self) :: total_entalpy Return total specific entalpy. elemental function total_entalpy_interface (self, density, pressure, velocity_sq_norm) result(entalpy_) Prototype Return total specific entalpy. Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. real(kind=R8P), intent(in) :: density Density value. real(kind=R8P), intent(in) :: pressure Pressure value. real(kind=R8P), intent(in) :: velocity_sq_norm Velocity vector square norm ||velocity||&#94;2 . Return Value real(kind=R8P) Total specific entalpy (per unit of mass). Source Code type , abstract :: eos_object !< Equation of State (EOS) object class. contains ! deferred methods procedure ( scalar_interface ), pass ( self ), deferred :: cp !< Return specific heat at constant pressure. procedure ( scalar_interface ), pass ( self ), deferred :: cv !< Return specific heat at constant volume. procedure ( density_interface ), pass ( self ), deferred :: density !< Return density. procedure ( scalar_interface ), pass ( self ), deferred :: delta !< Return `(gamma - 1) / 2`. procedure ( description_interface ), pass ( self ), deferred :: description !< Return pretty-printed object description. procedure ( assignment_interface ), pass ( lhs ), deferred :: eos_assign_eos !< Operator `=`. procedure ( scalar_interface ), pass ( self ), deferred :: eta !< Return `2 * gamma / (gamma - 1)`. procedure ( scalar_interface ), pass ( self ), deferred :: g !< Return specific heats ratio `gamma=cp/cv`. procedure ( scalar_interface ), pass ( self ), deferred :: gm1 !< Return `gamma - 1`. procedure ( scalar_interface ), pass ( self ), deferred :: gp1 !< Return `gamma + 1`. procedure ( internal_energy_interface ), pass ( self ), deferred :: internal_energy !< Return specific internal energy. procedure ( pressure_interface ), pass ( self ), deferred :: pressure !< Return pressure. procedure ( scalar_interface ), pass ( self ), deferred :: R !< Return fluid constant `R=cp-cv`. procedure ( speed_of_sound_interface ), pass ( self ), deferred :: speed_of_sound !< Return speed of sound. procedure ( temperature_interface ), pass ( self ), deferred :: temperature !< Return temperature. procedure ( total_entalpy_interface ), pass ( self ), deferred :: total_entalpy !< Return total specific entalpy. ! operators generic :: assignment ( = ) => eos_assign_eos !< Overload `=`. endtype eos_object","tags":"","loc":"type/eos_object.html","title":"eos_object – FLOw "},{"text":"type, public, abstract :: field_object Field abstract object. Inherited By type~~field_object~~InheritedByGraph type~field_object field_object type~conservative_object conservative_object type~field_object->type~conservative_object type~primitive_object primitive_object type~field_object->type~primitive_object type~field_scalar field_scalar type~field_object->type~field_scalar type~field_vectorial field_vectorial type~field_object->type~field_vectorial type~conservative_compressible conservative_compressible type~conservative_object->type~conservative_compressible type~primitive_compressible primitive_compressible type~primitive_object->type~primitive_compressible type~primitive_compressible_multispecie primitive_compressible_multispecie type~primitive_object->type~primitive_compressible_multispecie Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Type-Bound Procedures add array assign_field assign_real assignment(=) description div div_integer div_real eq integer_mul mul mul_integer mul_real negative not_eq operator(*) operator(**) operator(+) operator(-) operator(/) operator(/=) operator(==) positive pow_integer pow_real real_mul sub Source Code field_object Type-Bound Procedures procedure( symmetric_op_interface ), public, deferred, pass(lhs) :: add Operator + . elemental function symmetric_op_interface (lhs, rhs) result(opr) Prototype Operator field.op.field . Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure( array_interface ), public, deferred, pass(self) :: array Return serialized array of field. pure function array_interface (self) result(array_) Prototype Return serialized array of field. Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: self Field. Return Value real(kind=R8P),\n  allocatable, (:) Serialized array of field. procedure( assign_interface ), public, deferred, pass(lhs) :: assign_field Operator = . elemental subroutine assign_interface (lhs, rhs) Prototype Operator = . Arguments Type Intent Optional Attributes Name class( field_object ), intent(inout) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. procedure( assign_real_interface ), public, deferred, pass(lhs) :: assign_real Operator field = real . elemental subroutine assign_real_interface (lhs, rhs) Prototype Operator field = real . Arguments Type Intent Optional Attributes Name class( field_object ), intent(inout) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. generic, public :: assignment(=) => assign_field , assign_real Assignment overloading. private elemental subroutine assign_field (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(inout) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. private elemental subroutine assign_real (lhs, rhs) Operator field = real . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(inout) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. procedure( description_interface ), public, deferred, pass(self) :: description Return pretty-printed object description. pure function description_interface (self, prefix) result(desc) Prototype Return a pretty-formatted object description. Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: self Field. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. procedure( symmetric_op_interface ), public, deferred, pass(lhs) :: div Operator / . elemental function symmetric_op_interface (lhs, rhs) result(opr) Prototype Operator field.op.field . Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure( field_op_integer_interface ), public, deferred, pass(lhs) :: div_integer Operator field / integer . elemental function field_op_integer_interface (lhs, rhs) result(opr) Prototype Operator field.op.integer . Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure( field_op_real_interface ), public, deferred, pass(lhs) :: div_real Operator field / real . elemental function field_op_real_interface (lhs, rhs) result(opr) Prototype Operator field.op.real . Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure( compare_interface ), public, deferred, pass(lhs) :: eq Operator `=='. elemental function compare_interface (lhs, rhs) result(opr) Prototype Operator `field.compare.field'. Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. procedure( integer_op_field_interface ), public, deferred, pass(rhs) :: integer_mul Operator integer * field . elemental function integer_op_field_interface (lhs, rhs) result(opr) Prototype Operator field.op.integer . Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure( symmetric_op_interface ), public, deferred, pass(lhs) :: mul Operator * . elemental function symmetric_op_interface (lhs, rhs) result(opr) Prototype Operator field.op.field . Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure( field_op_integer_interface ), public, deferred, pass(lhs) :: mul_integer Operator field * integer . elemental function field_op_integer_interface (lhs, rhs) result(opr) Prototype Operator field.op.integer . Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure( field_op_real_interface ), public, deferred, pass(lhs) :: mul_real Operator field * real . elemental function field_op_real_interface (lhs, rhs) result(opr) Prototype Operator field.op.real . Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure( unary_operator ), public, deferred, pass(self) :: negative Unary operator - field . function unary_operator (self) result(opr) Prototype Unary operator .op.field . Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: self Field. Return Value class( field_object ),\n  allocatable Operator result. procedure( compare_interface ), public, deferred, pass(lhs) :: not_eq Operator `/='. elemental function compare_interface (lhs, rhs) result(opr) Prototype Operator `field.compare.field'. Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. generic, public :: operator(*) => mul , mul_integer , integer_mul , real_mul , mul_real Operator * overloading. private elemental function mul (lhs, rhs) result(opr) Operator * . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function mul_integer (lhs, rhs) result(opr) Operator field * integer . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function integer_mul (lhs, rhs) result(opr) Operator integer * field . Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: lhs Left hand side. class( primitive_compressible_multispecie ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function real_mul (lhs, rhs) result(opr) Operator real * field . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs Left hand side. class( primitive_compressible_multispecie ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function mul_real (lhs, rhs) result(opr) Operator field * real . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. generic, public :: operator(**) => pow_integer , pow_real Operator ** overloading. private elemental function pow_integer (lhs, rhs) result(opr) Operator field ** integer . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function pow_real (lhs, rhs) result(opr) Operator field ** real . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. generic, public :: operator(+) => add , positive Operator + overloading. private elemental function add (lhs, rhs) result(opr) Operator + . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private function positive (self) result(opr) Unary operator + field . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: self Primitive. Return Value class( field_object ),\n  allocatable Operator result. generic, public :: operator(-) => sub , negative Operator - overloading. private elemental function sub (lhs, rhs) result(opr) Operator - . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private function negative (self) result(operator_result) Unary operator - field . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: self Primitive. Return Value class( field_object ),\n  allocatable Operator result. generic, public :: operator(/) => div , div_integer , div_real Operator / overloading. private elemental function div (lhs, rhs) result(opr) Operator / . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function div_integer (lhs, rhs) result(opr) Operator field / integer . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function div_real (lhs, rhs) result(opr) Operator field / real . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. generic, public :: operator(/=) => not_eq Operator /= overloading. private elemental function not_eq (lhs, rhs) result(opr) Operator `/='. Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. generic, public :: operator(==) => eq Operator /= overloading. private elemental function eq (lhs, rhs) result(opr) Operator `=='. Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. procedure( unary_operator ), public, deferred, pass(self) :: positive Unary operator + field . function unary_operator (self) result(opr) Prototype Unary operator .op.field . Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: self Field. Return Value class( field_object ),\n  allocatable Operator result. procedure( field_op_integer_interface ), public, deferred, pass(lhs) :: pow_integer Operator field ** integer . elemental function field_op_integer_interface (lhs, rhs) result(opr) Prototype Operator field.op.integer . Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure( field_op_real_interface ), public, deferred, pass(lhs) :: pow_real Operator field ** real . elemental function field_op_real_interface (lhs, rhs) result(opr) Prototype Operator field.op.real . Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure( real_op_field_interface ), public, deferred, pass(rhs) :: real_mul Operator real * field . elemental function real_op_field_interface (lhs, rhs) result(opr) Prototype Operator real.op.field . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure( symmetric_op_interface ), public, deferred, pass(lhs) :: sub Operator - . elemental function symmetric_op_interface (lhs, rhs) result(opr) Prototype Operator field.op.field . Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code type , abstract :: field_object !< **Field** abstract object. contains ! deferred methods procedure ( array_interface ), pass ( self ), deferred :: array !< Return serialized array of field. procedure ( description_interface ), pass ( self ), deferred :: description !< Return pretty-printed object description. ! deferred operators procedure ( assign_interface ), pass ( lhs ), deferred :: assign_field !< Operator `=`. procedure ( assign_real_interface ), pass ( lhs ), deferred :: assign_real !< Operator `field = real`. procedure ( unary_operator ), pass ( self ), deferred :: positive !< Unary operator `+ field`. procedure ( symmetric_op_interface ), pass ( lhs ), deferred :: add !< Operator `+`. procedure ( symmetric_op_interface ), pass ( lhs ), deferred :: div !< Operator `/`. procedure ( field_op_integer_interface ), pass ( lhs ), deferred :: div_integer !< Operator `field / integer`. procedure ( field_op_real_interface ), pass ( lhs ), deferred :: div_real !< Operator `field / real`. procedure ( symmetric_op_interface ), pass ( lhs ), deferred :: mul !< Operator `*`. procedure ( field_op_integer_interface ), pass ( lhs ), deferred :: mul_integer !< Operator `field * integer`. procedure ( integer_op_field_interface ), pass ( rhs ), deferred :: integer_mul !< Operator `integer * field`. procedure ( field_op_real_interface ), pass ( lhs ), deferred :: mul_real !< Operator `field * real`. procedure ( real_op_field_interface ), pass ( rhs ), deferred :: real_mul !< Operator `real * field`. procedure ( unary_operator ), pass ( self ), deferred :: negative !< Unary operator `- field`. procedure ( symmetric_op_interface ), pass ( lhs ), deferred :: sub !< Operator `-`. procedure ( field_op_integer_interface ), pass ( lhs ), deferred :: pow_integer !< Operator `field ** integer`. procedure ( field_op_real_interface ), pass ( lhs ), deferred :: pow_real !< Operator `field ** real`. procedure ( compare_interface ), pass ( lhs ), deferred :: eq !< Operator `=='. procedure ( compare_interface ), pass ( lhs ), deferred :: not_eq !< Operator `/='. ! public operators generic :: assignment ( = ) => assign_field , assign_real !< Assignment overloading. generic :: operator ( + ) => add , positive !< Operator `+` overloading. generic :: operator ( / ) => div , div_integer , div_real !< Operator `/` overloading. generic :: operator ( * ) => mul , mul_integer , integer_mul , real_mul , mul_real !< Operator `*` overloading. generic :: operator ( - ) => sub , negative !< Operator `-` overloading. generic :: operator ( ** ) => pow_integer , pow_real !< Operator `**` overloading. generic :: operator ( == ) => eq !< Operator `/=` overloading. generic :: operator ( /= ) => not_eq !< Operator `/=` overloading. endtype field_object","tags":"","loc":"type/field_object.html","title":"field_object – FLOw "},{"text":"type, public, extends( field_object ) :: field_scalar type~~field_scalar~~InheritsGraph type~field_scalar field_scalar type~field_object field_object type~field_object->type~field_scalar Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Scalar field object. Variables field Type-Bound Procedures add array assign_field assign_real assignment(=) description div div_integer div_real eq integer_mul mul mul_integer mul_real negative not_eq operator(*) operator(**) operator(+) operator(-) operator(/) operator(/=) operator(==) positive pow_integer pow_real real_mul sub Source Code field_scalar Components Type Visibility Attributes Name Initial real(kind=R8P), public :: field Scalar field. Type-Bound Procedures procedure, public, pass(lhs) :: add => scalar_add_scalar Operator + . private elemental function scalar_add_scalar (lhs, rhs) result(opr) Operator + . Arguments Type Intent Optional Attributes Name class( field_scalar ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(self) :: array => array_scalar Return serialized array of field. private pure function array_scalar (self) result(array_) Return serialized array of field. Arguments Type Intent Optional Attributes Name class( field_scalar ), intent(in) :: self Field. Return Value real(kind=R8P),\n  allocatable, (:) Serialized array of field. procedure, public, pass(lhs) :: assign_field => assign_field_scalar Operator = . private elemental subroutine assign_field_scalar (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( field_scalar ), intent(inout) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. procedure, public, pass(lhs) :: assign_real => assign_real_scalar Operator field = real . private elemental subroutine assign_real_scalar (lhs, rhs) Operator field = real . Arguments Type Intent Optional Attributes Name class( field_scalar ), intent(inout) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. generic, public :: assignment(=) => assign_field , assign_real Assignment overloading. private elemental subroutine assign_field (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(inout) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. private elemental subroutine assign_real (lhs, rhs) Operator field = real . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(inout) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. procedure, public, pass(self) :: description => description_scalar Return pretty-printed object description. private pure function description_scalar (self, prefix) result(desc) Return a pretty-formatted object description. Arguments Type Intent Optional Attributes Name class( field_scalar ), intent(in) :: self Primitive. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. procedure, public, pass(lhs) :: div => scalar_div_scalar Operator / . private elemental function scalar_div_scalar (lhs, rhs) result(opr) Operator / . Arguments Type Intent Optional Attributes Name class( field_scalar ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: div_integer => scalar_div_integer Operator field / integer . private elemental function scalar_div_integer (lhs, rhs) result(opr) Operator field / integer . Arguments Type Intent Optional Attributes Name class( field_scalar ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: div_real => scalar_div_real Operator field / real . private elemental function scalar_div_real (lhs, rhs) result(opr) Operator field / real . Arguments Type Intent Optional Attributes Name class( field_scalar ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: eq => eq_scalar Operator `=='. private elemental function eq_scalar (lhs, rhs) result(opr) Operator `=='. Arguments Type Intent Optional Attributes Name class( field_scalar ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. procedure, public, pass(rhs) :: integer_mul => integer_mul_scalar Operator integer * field . private elemental function integer_mul_scalar (lhs, rhs) result(opr) Operator integer * field . Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: lhs Left hand side. class( field_scalar ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: mul => scalar_mul_object Operator * . private elemental function scalar_mul_object (lhs, rhs) result(opr) Operator * . Arguments Type Intent Optional Attributes Name class( field_scalar ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: mul_integer => scalar_mul_integer Operator field * integer . private elemental function scalar_mul_integer (lhs, rhs) result(opr) Operator field * integer . Arguments Type Intent Optional Attributes Name class( field_scalar ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: mul_real => scalar_mul_real Operator field * real . private elemental function scalar_mul_real (lhs, rhs) result(opr) Operator field * real . Arguments Type Intent Optional Attributes Name class( field_scalar ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(self) :: negative => negative_scalar Unary operator - field . private function negative_scalar (self) result(opr) Unary operator - field . Arguments Type Intent Optional Attributes Name class( field_scalar ), intent(in) :: self Primitive. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: not_eq => not_eq_scalar Operator `/='. private elemental function not_eq_scalar (lhs, rhs) result(opr) Operator `/='. Arguments Type Intent Optional Attributes Name class( field_scalar ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. generic, public :: operator(*) => mul , mul_integer , integer_mul , real_mul , mul_real Operator * overloading. private elemental function mul (lhs, rhs) result(opr) Operator * . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function mul_integer (lhs, rhs) result(opr) Operator field * integer . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function integer_mul (lhs, rhs) result(opr) Operator integer * field . Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: lhs Left hand side. class( primitive_compressible_multispecie ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function real_mul (lhs, rhs) result(opr) Operator real * field . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs Left hand side. class( primitive_compressible_multispecie ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function mul_real (lhs, rhs) result(opr) Operator field * real . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. generic, public :: operator(**) => pow_integer , pow_real Operator ** overloading. private elemental function pow_integer (lhs, rhs) result(opr) Operator field ** integer . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function pow_real (lhs, rhs) result(opr) Operator field ** real . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. generic, public :: operator(+) => add , positive Operator + overloading. private elemental function add (lhs, rhs) result(opr) Operator + . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private function positive (self) result(opr) Unary operator + field . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: self Primitive. Return Value class( field_object ),\n  allocatable Operator result. generic, public :: operator(-) => sub , negative Operator - overloading. private elemental function sub (lhs, rhs) result(opr) Operator - . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private function negative (self) result(operator_result) Unary operator - field . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: self Primitive. Return Value class( field_object ),\n  allocatable Operator result. generic, public :: operator(/) => div , div_integer , div_real Operator / overloading. private elemental function div (lhs, rhs) result(opr) Operator / . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function div_integer (lhs, rhs) result(opr) Operator field / integer . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function div_real (lhs, rhs) result(opr) Operator field / real . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. generic, public :: operator(/=) => not_eq Operator /= overloading. private elemental function not_eq (lhs, rhs) result(opr) Operator `/='. Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. generic, public :: operator(==) => eq Operator /= overloading. private elemental function eq (lhs, rhs) result(opr) Operator `=='. Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. procedure, public, pass(self) :: positive => positive_scalar Unary operator + field . private function positive_scalar (self) result(opr) Unary operator + field . Arguments Type Intent Optional Attributes Name class( field_scalar ), intent(in) :: self Primitive. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: pow_integer => scalar_pow_integer Operator field ** integer . private elemental function scalar_pow_integer (lhs, rhs) result(opr) Operator field ** integer . Arguments Type Intent Optional Attributes Name class( field_scalar ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: pow_real => scalar_pow_real Operator field ** real . private elemental function scalar_pow_real (lhs, rhs) result(opr) Operator field ** real . Arguments Type Intent Optional Attributes Name class( field_scalar ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(rhs) :: real_mul => real_mul_scalar Operator real * field . private elemental function real_mul_scalar (lhs, rhs) result(opr) Operator real * field . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs Left hand side. class( field_scalar ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: sub => scalar_sub_scalar Operator - . private elemental function scalar_sub_scalar (lhs, rhs) result(opr) Operator - . Arguments Type Intent Optional Attributes Name class( field_scalar ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code type , extends ( field_object ) :: field_scalar !< **Scalar field** object. real ( R8P ) :: field !< Scalar field. contains ! deferred methods procedure , pass ( self ) :: array => array_scalar !< Return serialized array of field. procedure , pass ( self ) :: description => description_scalar !< Return pretty-printed object description. ! deferred operators procedure , pass ( lhs ) :: assign_field => assign_field_scalar !< Operator `=`. procedure , pass ( lhs ) :: assign_real => assign_real_scalar !< Operator `field = real`. procedure , pass ( self ) :: positive => positive_scalar !< Unary operator `+ field`. procedure , pass ( lhs ) :: add => scalar_add_scalar !< Operator `+`. procedure , pass ( lhs ) :: div => scalar_div_scalar !< Operator `/`. procedure , pass ( lhs ) :: div_integer => scalar_div_integer !< Operator `field / integer`. procedure , pass ( lhs ) :: div_real => scalar_div_real !< Operator `field / real`. procedure , pass ( lhs ) :: mul => scalar_mul_object !< Operator `*`. procedure , pass ( lhs ) :: mul_integer => scalar_mul_integer !< Operator `field * integer`. procedure , pass ( rhs ) :: integer_mul => integer_mul_scalar !< Operator `integer * field`. procedure , pass ( lhs ) :: mul_real => scalar_mul_real !< Operator `field * real`. procedure , pass ( rhs ) :: real_mul => real_mul_scalar !< Operator `real * field`. procedure , pass ( self ) :: negative => negative_scalar !< Unary operator `- field`. procedure , pass ( lhs ) :: sub => scalar_sub_scalar !< Operator `-`. procedure , pass ( lhs ) :: pow_integer => scalar_pow_integer !< Operator `field ** integer`. procedure , pass ( lhs ) :: pow_real => scalar_pow_real !< Operator `field ** real`. procedure , pass ( lhs ) :: eq => eq_scalar !< Operator `=='. procedure , pass ( lhs ) :: not_eq => not_eq_scalar !< Operator `/='. endtype field_scalar","tags":"","loc":"type/field_scalar.html","title":"field_scalar – FLOw "},{"text":"type, public, extends( field_object ) :: field_vectorial type~~field_vectorial~~InheritsGraph type~field_vectorial field_vectorial vector vector vector->type~field_vectorial field type~field_object field_object type~field_object->type~field_vectorial Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Vectorial field object. Variables field Type-Bound Procedures add array assign_field assign_real assignment(=) description div div_integer div_real eq integer_mul mul mul_integer mul_real negative not_eq operator(*) operator(**) operator(+) operator(-) operator(/) operator(/=) operator(==) positive pow_integer pow_real real_mul sub Source Code field_vectorial Components Type Visibility Attributes Name Initial type(vector), public :: field Vectorial field. Type-Bound Procedures procedure, public, pass(lhs) :: add => vectorial_add_vectorial Operator + . private elemental function vectorial_add_vectorial (lhs, rhs) result(opr) Operator + . Arguments Type Intent Optional Attributes Name class( field_vectorial ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(self) :: array => array_vectorial Return serialized array of field. private pure function array_vectorial (self) result(array_) Return serialized array of field. Arguments Type Intent Optional Attributes Name class( field_vectorial ), intent(in) :: self Field. Return Value real(kind=R8P),\n  allocatable, (:) Serialized array of field. procedure, public, pass(lhs) :: assign_field => assign_field_vectorial Operator = . private elemental subroutine assign_field_vectorial (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( field_vectorial ), intent(inout) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. procedure, public, pass(lhs) :: assign_real => assign_real_vectorial Operator field = real . private elemental subroutine assign_real_vectorial (lhs, rhs) Operator field = real . Arguments Type Intent Optional Attributes Name class( field_vectorial ), intent(inout) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. generic, public :: assignment(=) => assign_field , assign_real Assignment overloading. private elemental subroutine assign_field (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(inout) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. private elemental subroutine assign_real (lhs, rhs) Operator field = real . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(inout) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. procedure, public, pass(self) :: description => description_vectorial Return pretty-printed object description. private pure function description_vectorial (self, prefix) result(desc) Return a pretty-formatted object description. Arguments Type Intent Optional Attributes Name class( field_vectorial ), intent(in) :: self Primitive. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. procedure, public, pass(lhs) :: div => vectorial_div_object Operator / . private elemental function vectorial_div_object (lhs, rhs) result(opr) Operator / . Arguments Type Intent Optional Attributes Name class( field_vectorial ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: div_integer => vectorial_div_integer Operator field / integer . private elemental function vectorial_div_integer (lhs, rhs) result(opr) Operator field / integer . Arguments Type Intent Optional Attributes Name class( field_vectorial ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: div_real => vectorial_div_real Operator field / real . private elemental function vectorial_div_real (lhs, rhs) result(opr) Operator field / real . Arguments Type Intent Optional Attributes Name class( field_vectorial ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: eq => eq_vectorial Operator `=='. private elemental function eq_vectorial (lhs, rhs) result(opr) Operator `=='. Arguments Type Intent Optional Attributes Name class( field_vectorial ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. procedure, public, pass(rhs) :: integer_mul => integer_mul_vectorial Operator integer * field . private elemental function integer_mul_vectorial (lhs, rhs) result(opr) Operator integer * field . Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: lhs Left hand side. class( field_vectorial ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: mul => vectorial_mul_object Operator * . private elemental function vectorial_mul_object (lhs, rhs) result(opr) Operator * . Arguments Type Intent Optional Attributes Name class( field_vectorial ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: mul_integer => vectorial_mul_integer Operator field * integer . private elemental function vectorial_mul_integer (lhs, rhs) result(opr) Operator field * integer . Arguments Type Intent Optional Attributes Name class( field_vectorial ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: mul_real => vectorial_mul_real Operator field * real . private elemental function vectorial_mul_real (lhs, rhs) result(opr) Operator field * real . Arguments Type Intent Optional Attributes Name class( field_vectorial ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(self) :: negative => negative_vectorial Unary operator - field . private function negative_vectorial (self) result(opr) Unary operator + field . Arguments Type Intent Optional Attributes Name class( field_vectorial ), intent(in) :: self Primitive. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: not_eq => not_eq_vectorial Operator `/='. private elemental function not_eq_vectorial (lhs, rhs) result(opr) Operator `/='. Arguments Type Intent Optional Attributes Name class( field_vectorial ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. generic, public :: operator(*) => mul , mul_integer , integer_mul , real_mul , mul_real Operator * overloading. private elemental function mul (lhs, rhs) result(opr) Operator * . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function mul_integer (lhs, rhs) result(opr) Operator field * integer . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function integer_mul (lhs, rhs) result(opr) Operator integer * field . Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: lhs Left hand side. class( primitive_compressible_multispecie ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function real_mul (lhs, rhs) result(opr) Operator real * field . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs Left hand side. class( primitive_compressible_multispecie ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function mul_real (lhs, rhs) result(opr) Operator field * real . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. generic, public :: operator(**) => pow_integer , pow_real Operator ** overloading. private elemental function pow_integer (lhs, rhs) result(opr) Operator field ** integer . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function pow_real (lhs, rhs) result(opr) Operator field ** real . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. generic, public :: operator(+) => add , positive Operator + overloading. private elemental function add (lhs, rhs) result(opr) Operator + . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private function positive (self) result(opr) Unary operator + field . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: self Primitive. Return Value class( field_object ),\n  allocatable Operator result. generic, public :: operator(-) => sub , negative Operator - overloading. private elemental function sub (lhs, rhs) result(opr) Operator - . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private function negative (self) result(operator_result) Unary operator - field . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: self Primitive. Return Value class( field_object ),\n  allocatable Operator result. generic, public :: operator(/) => div , div_integer , div_real Operator / overloading. private elemental function div (lhs, rhs) result(opr) Operator / . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function div_integer (lhs, rhs) result(opr) Operator field / integer . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function div_real (lhs, rhs) result(opr) Operator field / real . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. generic, public :: operator(/=) => not_eq Operator /= overloading. private elemental function not_eq (lhs, rhs) result(opr) Operator `/='. Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. generic, public :: operator(==) => eq Operator /= overloading. private elemental function eq (lhs, rhs) result(opr) Operator `=='. Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. procedure, public, pass(self) :: positive => positive_vectorial Unary operator + field . private function positive_vectorial (self) result(opr) Unary operator + field . Arguments Type Intent Optional Attributes Name class( field_vectorial ), intent(in) :: self Primitive. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: pow_integer => vectorial_pow_integer Operator field ** integer . private elemental function vectorial_pow_integer (lhs, rhs) result(opr) Operator field ** integer . Arguments Type Intent Optional Attributes Name class( field_vectorial ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: pow_real => vectorial_pow_real Operator field ** real . private elemental function vectorial_pow_real (lhs, rhs) result(opr) Operator field ** real . Arguments Type Intent Optional Attributes Name class( field_vectorial ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(rhs) :: real_mul => real_mul_vectorial Operator real * field . private elemental function real_mul_vectorial (lhs, rhs) result(opr) Operator real * field . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs Left hand side. class( field_vectorial ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: sub => vectorial_sub_vectorial Operator - . private elemental function vectorial_sub_vectorial (lhs, rhs) result(opr) Operator - . Arguments Type Intent Optional Attributes Name class( field_vectorial ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code type , extends ( field_object ) :: field_vectorial !< **Vectorial field** object. type ( vector ) :: field !< Vectorial field. contains ! deferred methods procedure , pass ( self ) :: array => array_vectorial !< Return serialized array of field. procedure , pass ( self ) :: description => description_vectorial !< Return pretty-printed object description. ! deferred operators procedure , pass ( lhs ) :: assign_field => assign_field_vectorial !< Operator `=`. procedure , pass ( lhs ) :: assign_real => assign_real_vectorial !< Operator `field = real`. procedure , pass ( self ) :: positive => positive_vectorial !< Unary operator `+ field`. procedure , pass ( lhs ) :: add => vectorial_add_vectorial !< Operator `+`. procedure , pass ( lhs ) :: div => vectorial_div_object !< Operator `/`. procedure , pass ( lhs ) :: div_integer => vectorial_div_integer !< Operator `field / integer`. procedure , pass ( lhs ) :: div_real => vectorial_div_real !< Operator `field / real`. procedure , pass ( lhs ) :: mul => vectorial_mul_object !< Operator `*`. procedure , pass ( lhs ) :: mul_integer => vectorial_mul_integer !< Operator `field * integer`. procedure , pass ( rhs ) :: integer_mul => integer_mul_vectorial !< Operator `integer * field`. procedure , pass ( lhs ) :: mul_real => vectorial_mul_real !< Operator `field * real`. procedure , pass ( rhs ) :: real_mul => real_mul_vectorial !< Operator `real * field`. procedure , pass ( self ) :: negative => negative_vectorial !< Unary operator `- field`. procedure , pass ( lhs ) :: sub => vectorial_sub_vectorial !< Operator `-`. procedure , pass ( lhs ) :: pow_integer => vectorial_pow_integer !< Operator `field ** integer`. procedure , pass ( lhs ) :: pow_real => vectorial_pow_real !< Operator `field ** real`. procedure , pass ( lhs ) :: eq => eq_vectorial !< Operator `=='. procedure , pass ( lhs ) :: not_eq => not_eq_vectorial !< Operator `/='. endtype field_vectorial","tags":"","loc":"type/field_vectorial.html","title":"field_vectorial – FLOw "},{"text":"type, public, extends( primitive_object ) :: primitive_compressible type~~primitive_compressible~~InheritsGraph type~primitive_compressible primitive_compressible vector vector vector->type~primitive_compressible velocity type~primitive_object primitive_object type~primitive_object->type~primitive_compressible type~field_object field_object type~field_object->type~primitive_object Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Primitive compressible multispecie object. Variables density pressure velocity Constructor primitive_compressible Type-Bound Procedures add array assign_field assign_real assignment(=) description destroy div div_integer div_real energy eq initialize integer_mul left_eigenvectors momentum mul mul_integer mul_real negative not_eq operator(*) operator(**) operator(+) operator(-) operator(/) operator(/=) operator(==) positive pow_integer pow_real real_mul right_eigenvectors sub Source Code primitive_compressible Components Type Visibility Attributes Name Initial real(kind=R8P), public :: density = 0._R8P Density, rho . real(kind=R8P), public :: pressure = 0._R8P Pressure, p . type(vector), public :: velocity Velocity, v . Constructor public interface primitive_compressible Overload primitive_compressible name with its constructor. private pure function primitive_compressible_instance (density, velocity, pressure) result(instance) Return and instance of primitive_compressible . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in), optional :: density Density field. type(vector), intent(in), optional :: velocity Velocity field. real(kind=R8P), intent(in), optional :: pressure Pressure field. Return Value type( primitive_compressible ) Instance of primitive_compressible . Type-Bound Procedures procedure, public, pass(lhs) :: add Operator + . private elemental function add (lhs, rhs) result(opr) Operator + . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(self) :: array Return serialized array of field. private pure function array (self) result(array_) Return serialized array of field. Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. Return Value real(kind=R8P),\n  allocatable, (:) Serialized array of field. procedure, public, pass(lhs) :: assign_field Operator = . private elemental subroutine assign_field (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(inout) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. procedure, public, pass(lhs) :: assign_real Operator field = real . private elemental subroutine assign_real (lhs, rhs) Operator field = real . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(inout) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. generic, public :: assignment(=) => assign_field , assign_real Assignment overloading. private elemental subroutine assign_field (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(inout) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. private elemental subroutine assign_real (lhs, rhs) Operator field = real . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(inout) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. procedure, public, pass(self) :: description Return pretty-printed object description. private pure function description (self, prefix) result(desc) Return a pretty-formatted object description. Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. procedure, public, pass(self) :: destroy Destroy primitive. private elemental subroutine destroy (self) Destroy primitive. Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(inout) :: self Primitive. procedure, public, pass(lhs) :: div Operator / . private elemental function div (lhs, rhs) result(opr) Operator / . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: div_integer Operator field / integer . private elemental function div_integer (lhs, rhs) result(opr) Operator field / integer . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: div_real Operator field / real . private elemental function div_real (lhs, rhs) result(opr) Operator field / real . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(self) :: energy Return energy value. private elemental function energy (self, eos) result(energy_) Return energy value. Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. class( eos_object ), intent(in) :: eos Equation of state. Return Value real(kind=R8P) Energy value. procedure, public, pass(lhs) :: eq Operator `=='. private elemental function eq (lhs, rhs) result(opr) Operator `=='. Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. procedure, public, pass(self) :: initialize Initialize primitive. private subroutine initialize (self, initial_state) Initialize primitive. Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(inout) :: self Primitive. class( primitive_object ), intent(in), optional :: initial_state Initial state. procedure, public, pass(rhs) :: integer_mul Operator integer * field . private elemental function integer_mul (lhs, rhs) result(opr) Operator integer * field . Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: lhs Left hand side. class( primitive_compressible ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(self) :: left_eigenvectors Return the left eigenvectors matrix L as dF/dP = A = R &#94; L . private pure function left_eigenvectors (self, eos) result(eig) Return the left eigenvectors matrix L as dF/dP = A = R &#94; L . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. class( eos_object ), intent(in) :: eos Equation of state. Return Value real(kind=R8P)\n  (1:3,1:3) Eigenvectors. procedure, public, pass(self) :: momentum Return momentum vector. private elemental function momentum (self) result(momentum_) Return momentum vector. Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. Return Value type(vector) Momentum vector. procedure, public, pass(lhs) :: mul Operator * . private elemental function mul (lhs, rhs) result(opr) Operator * . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: mul_integer Operator field * integer . private elemental function mul_integer (lhs, rhs) result(opr) Operator field * integer . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: mul_real Operator field * real . private elemental function mul_real (lhs, rhs) result(opr) Operator field * real . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(self) :: negative Unary operator - field . private function negative (self) result(opr) Unary operator - field . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: not_eq Operator `/='. private elemental function not_eq (lhs, rhs) result(opr) Operator `/='. Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. generic, public :: operator(*) => mul , mul_integer , integer_mul , real_mul , mul_real Operator * overloading. private elemental function mul (lhs, rhs) result(opr) Operator * . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function mul_integer (lhs, rhs) result(opr) Operator field * integer . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function integer_mul (lhs, rhs) result(opr) Operator integer * field . Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: lhs Left hand side. class( primitive_compressible_multispecie ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function real_mul (lhs, rhs) result(opr) Operator real * field . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs Left hand side. class( primitive_compressible_multispecie ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function mul_real (lhs, rhs) result(opr) Operator field * real . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. generic, public :: operator(**) => pow_integer , pow_real Operator ** overloading. private elemental function pow_integer (lhs, rhs) result(opr) Operator field ** integer . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function pow_real (lhs, rhs) result(opr) Operator field ** real . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. generic, public :: operator(+) => add , positive Operator + overloading. private elemental function add (lhs, rhs) result(opr) Operator + . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private function positive (self) result(opr) Unary operator + field . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: self Primitive. Return Value class( field_object ),\n  allocatable Operator result. generic, public :: operator(-) => sub , negative Operator - overloading. private elemental function sub (lhs, rhs) result(opr) Operator - . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private function negative (self) result(operator_result) Unary operator - field . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: self Primitive. Return Value class( field_object ),\n  allocatable Operator result. generic, public :: operator(/) => div , div_integer , div_real Operator / overloading. private elemental function div (lhs, rhs) result(opr) Operator / . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function div_integer (lhs, rhs) result(opr) Operator field / integer . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function div_real (lhs, rhs) result(opr) Operator field / real . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. generic, public :: operator(/=) => not_eq Operator /= overloading. private elemental function not_eq (lhs, rhs) result(opr) Operator `/='. Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. generic, public :: operator(==) => eq Operator /= overloading. private elemental function eq (lhs, rhs) result(opr) Operator `=='. Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. procedure, public, pass(self) :: positive Unary operator + field . private function positive (self) result(opr) Unary operator + field . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: pow_integer Operator field ** integer . private elemental function pow_integer (lhs, rhs) result(opr) Operator field ** integer . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: pow_real Operator field ** real . private elemental function pow_real (lhs, rhs) result(opr) Operator field ** real . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(rhs) :: real_mul Operator real * field . private elemental function real_mul (lhs, rhs) result(opr) Operator real * field . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs Left hand side. class( primitive_compressible ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(self) :: right_eigenvectors Return the right eigenvectors matrix R as dF/dP = A = R &#94; L . private pure function right_eigenvectors (self, eos) result(eig) Return the right eigenvectors matrix R as dF/dP = A = R &#94; L . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. class( eos_object ), intent(in) :: eos Equation of state. Return Value real(kind=R8P)\n  (1:3,1:3) Eigenvectors. procedure, public, pass(lhs) :: sub Operator - . private elemental function sub (lhs, rhs) result(opr) Operator - . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code type , extends ( primitive_object ) :: primitive_compressible !< **Primitive** compressible multispecie object. real ( R8P ) :: density = 0._R8P !< Density, `rho`. type ( vector ) :: velocity !< Velocity, `v`. real ( R8P ) :: pressure = 0._R8P !< Pressure, `p`. contains ! public methods procedure , pass ( self ) :: left_eigenvectors !< Return the left eigenvectors matrix `L` as `dF/dP = A = R &#94; L`. procedure , pass ( self ) :: right_eigenvectors !< Return the right eigenvectors matrix `R` as `dF/dP = A = R &#94; L`. ! deferred methods procedure , pass ( self ) :: array !< Return serialized array of field. procedure , pass ( self ) :: description !< Return pretty-printed object description. procedure , pass ( self ) :: destroy !< Destroy primitive. procedure , pass ( self ) :: energy !< Return energy value. procedure , pass ( self ) :: initialize !< Initialize primitive. procedure , pass ( self ) :: momentum !< Return momentum vector. ! deferred operators procedure , pass ( lhs ) :: assign_field !< Operator `=`. procedure , pass ( lhs ) :: assign_real !< Operator `field = real`. procedure , pass ( self ) :: positive !< Unary operator `+ field`. procedure , pass ( lhs ) :: add !< Operator `+`. procedure , pass ( lhs ) :: div !< Operator `/`. procedure , pass ( lhs ) :: div_integer !< Operator `field / integer`. procedure , pass ( lhs ) :: div_real !< Operator `field / real`. procedure , pass ( lhs ) :: mul !< Operator `*`. procedure , pass ( lhs ) :: mul_integer !< Operator `field * integer`. procedure , pass ( rhs ) :: integer_mul !< Operator `integer * field`. procedure , pass ( lhs ) :: mul_real !< Operator `field * real`. procedure , pass ( rhs ) :: real_mul !< Operator `real * field`. procedure , pass ( self ) :: negative !< Unary operator `- field`. procedure , pass ( lhs ) :: sub !< Operator `-`. procedure , pass ( lhs ) :: pow_integer !< Operator `field ** integer`. procedure , pass ( lhs ) :: pow_real !< Operator `field ** real`. procedure , pass ( lhs ) :: eq !< Operator `=='. procedure , pass ( lhs ) :: not_eq !< Operator `/='. endtype primitive_compressible","tags":"","loc":"type/primitive_compressible.html","title":"primitive_compressible – FLOw "},{"text":"type, public, extends( primitive_object ) :: primitive_compressible_multispecie type~~primitive_compressible_multispecie~~InheritsGraph type~primitive_compressible_multispecie primitive_compressible_multispecie vector vector vector->type~primitive_compressible_multispecie velocity type~primitive_object primitive_object type~primitive_object->type~primitive_compressible_multispecie type~field_object field_object type~field_object->type~primitive_object Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Primitive compressible multispecie object. Variables density partial_densities pressure velocity Constructor primitive_compressible_multispecie Type-Bound Procedures add array assign_field assign_real assignment(=) compatible description destroy div div_integer div_real energy eq initialize integer_mul momentum mul mul_integer mul_real negative not_eq operator(*) operator(**) operator(+) operator(-) operator(.compatible.) operator(/) operator(/=) operator(==) positive pow_integer pow_real real_mul sub Source Code primitive_compressible_multispecie Components Type Visibility Attributes Name Initial real(kind=R8P), public :: density = 0._R8P Density, rho . real(kind=R8P), public, allocatable :: partial_densities (:) Partial densities rho(s), rho = sum(rho(s)) . real(kind=R8P), public :: pressure = 0._R8P Pressure, p . type(vector), public :: velocity Velocity, v . Constructor public interface primitive_compressible_multispecie Overload primitive_compressible_multispecie name with its constructor. private pure function primitive_compressible_multispecie_instance (density, velocity, pressure, partial_densities) result(instance) Return and instance of primitive_compressible_multispecie . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in), optional :: density Density field. type(vector), intent(in), optional :: velocity Velocity field. real(kind=R8P), intent(in), optional :: pressure Pressure field. real(kind=R8P), intent(in), optional :: partial_densities (:) Partial densities field. Return Value type( primitive_compressible_multispecie ) Instance of primitive_compressible_multispecie . Type-Bound Procedures procedure, public, pass(lhs) :: add Operator + . private elemental function add (lhs, rhs) result(opr) Operator + . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(self) :: array Return serialized array of field. private pure function array (self) result(array_) Return serialized array of field. Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: self Primitive. Return Value real(kind=R8P),\n  allocatable, (:) Serialized array of field. procedure, public, pass(lhs) :: assign_field Operator = . private elemental subroutine assign_field (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(inout) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. procedure, public, pass(lhs) :: assign_real Operator field = real . private elemental subroutine assign_real (lhs, rhs) Operator field = real . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(inout) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. generic, public :: assignment(=) => assign_field , assign_real Assignment overloading. private elemental subroutine assign_field (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(inout) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. private elemental subroutine assign_real (lhs, rhs) Operator field = real . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(inout) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. procedure, public, pass(lhs) :: compatible Operator .compatible. . private elemental function compatible (lhs, rhs) result(opr) Operator .compatible. . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. type( primitive_compressible_multispecie ), intent(in) :: rhs Right hand side. Return Value logical Operator result. procedure, public, pass(self) :: description Return pretty-printed object description. private pure function description (self, prefix) result(desc) Return a pretty-formatted object description. Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: self Primitive. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. procedure, public, pass(self) :: destroy Destroy primitive. private elemental subroutine destroy (self) Destroy primitive. Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(inout) :: self Primitive. procedure, public, pass(lhs) :: div Operator / . private elemental function div (lhs, rhs) result(opr) Operator / . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: div_integer Operator field / integer . private elemental function div_integer (lhs, rhs) result(opr) Operator field / integer . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: div_real Operator field / real . private elemental function div_real (lhs, rhs) result(opr) Operator field / real . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(self) :: energy Return energy value. private elemental function energy (self, eos) result(energy_) Return energy value. Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: self Primitive. class( eos_object ), intent(in) :: eos Equation of state. Return Value real(kind=R8P) Energy value. procedure, public, pass(lhs) :: eq Operator `=='. private elemental function eq (lhs, rhs) result(opr) Operator `=='. Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. procedure, public, pass(self) :: initialize Initialize primitive. private subroutine initialize (self, initial_state) Initialize primitive. Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(inout) :: self Primitive. class( primitive_object ), intent(in), optional :: initial_state Initial state. procedure, public, pass(rhs) :: integer_mul Operator integer * field . private elemental function integer_mul (lhs, rhs) result(opr) Operator integer * field . Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: lhs Left hand side. class( primitive_compressible_multispecie ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(self) :: momentum Return momentum vector. private elemental function momentum (self) result(momentum_) Return momentum vector. Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: self Primitive. Return Value type(vector) Momentum vector. procedure, public, pass(lhs) :: mul Operator * . private elemental function mul (lhs, rhs) result(opr) Operator * . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: mul_integer Operator field * integer . private elemental function mul_integer (lhs, rhs) result(opr) Operator field * integer . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: mul_real Operator field * real . private elemental function mul_real (lhs, rhs) result(opr) Operator field * real . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(self) :: negative Unary operator - field . private function negative (self) result(operator_result) Unary operator - field . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: self Primitive. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: not_eq Operator `/='. private elemental function not_eq (lhs, rhs) result(opr) Operator `/='. Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. generic, public :: operator(*) => mul , mul_integer , integer_mul , real_mul , mul_real Operator * overloading. private elemental function mul (lhs, rhs) result(opr) Operator * . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function mul_integer (lhs, rhs) result(opr) Operator field * integer . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function integer_mul (lhs, rhs) result(opr) Operator integer * field . Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: lhs Left hand side. class( primitive_compressible_multispecie ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function real_mul (lhs, rhs) result(opr) Operator real * field . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs Left hand side. class( primitive_compressible_multispecie ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function mul_real (lhs, rhs) result(opr) Operator field * real . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. generic, public :: operator(**) => pow_integer , pow_real Operator ** overloading. private elemental function pow_integer (lhs, rhs) result(opr) Operator field ** integer . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function pow_real (lhs, rhs) result(opr) Operator field ** real . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. generic, public :: operator(+) => add , positive Operator + overloading. private elemental function add (lhs, rhs) result(opr) Operator + . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private function positive (self) result(opr) Unary operator + field . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: self Primitive. Return Value class( field_object ),\n  allocatable Operator result. generic, public :: operator(-) => sub , negative Operator - overloading. private elemental function sub (lhs, rhs) result(opr) Operator - . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private function negative (self) result(operator_result) Unary operator - field . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: self Primitive. Return Value class( field_object ),\n  allocatable Operator result. generic, public :: operator(.compatible.) => compatible Operator .compatible. overloading. private elemental function compatible (lhs, rhs) result(opr) Operator .compatible. . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. type( primitive_compressible_multispecie ), intent(in) :: rhs Right hand side. Return Value logical Operator result. generic, public :: operator(/) => div , div_integer , div_real Operator / overloading. private elemental function div (lhs, rhs) result(opr) Operator / . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function div_integer (lhs, rhs) result(opr) Operator field / integer . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function div_real (lhs, rhs) result(opr) Operator field / real . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. generic, public :: operator(/=) => not_eq Operator /= overloading. private elemental function not_eq (lhs, rhs) result(opr) Operator `/='. Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. generic, public :: operator(==) => eq Operator /= overloading. private elemental function eq (lhs, rhs) result(opr) Operator `=='. Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. procedure, public, pass(self) :: positive Unary operator + field . private function positive (self) result(opr) Unary operator + field . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: self Primitive. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: pow_integer Operator field ** integer . private elemental function pow_integer (lhs, rhs) result(opr) Operator field ** integer . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: pow_real Operator field ** real . private elemental function pow_real (lhs, rhs) result(opr) Operator field ** real . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(rhs) :: real_mul Operator real * field . private elemental function real_mul (lhs, rhs) result(opr) Operator real * field . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs Left hand side. class( primitive_compressible_multispecie ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure, public, pass(lhs) :: sub Operator - . private elemental function sub (lhs, rhs) result(opr) Operator - . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code type , extends ( primitive_object ) :: primitive_compressible_multispecie !< **Primitive** compressible multispecie object. real ( R8P ) :: density = 0._R8P !< Density, `rho`. type ( vector ) :: velocity !< Velocity, `v`. real ( R8P ) :: pressure = 0._R8P !< Pressure, `p`. real ( R8P ), allocatable :: partial_densities (:) !< Partial densities `rho(s), rho = sum(rho(s))`. contains ! deferred methods procedure , pass ( self ) :: array !< Return serialized array of field. procedure , pass ( self ) :: description !< Return pretty-printed object description. procedure , pass ( self ) :: destroy !< Destroy primitive. procedure , pass ( self ) :: energy !< Return energy value. procedure , pass ( self ) :: initialize !< Initialize primitive. procedure , pass ( self ) :: momentum !< Return momentum vector. ! deferred operators procedure , pass ( lhs ) :: assign_field !< Operator `=`. procedure , pass ( lhs ) :: assign_real !< Operator `field = real`. procedure , pass ( self ) :: positive !< Unary operator `+ field`. procedure , pass ( lhs ) :: add !< Operator `+`. procedure , pass ( lhs ) :: div !< Operator `/`. procedure , pass ( lhs ) :: div_integer !< Operator `field / integer`. procedure , pass ( lhs ) :: div_real !< Operator `field / real`. procedure , pass ( lhs ) :: mul !< Operator `*`. procedure , pass ( lhs ) :: mul_integer !< Operator `field * integer`. procedure , pass ( rhs ) :: integer_mul !< Operator `integer * field`. procedure , pass ( lhs ) :: mul_real !< Operator `field * real`. procedure , pass ( rhs ) :: real_mul !< Operator `real * field`. procedure , pass ( self ) :: negative !< Unary operator `- field`. procedure , pass ( lhs ) :: sub !< Operator `-`. procedure , pass ( lhs ) :: pow_integer !< Operator `field ** integer`. procedure , pass ( lhs ) :: pow_real !< Operator `field ** real`. procedure , pass ( lhs ) :: eq !< Operator `=='. procedure , pass ( lhs ) :: not_eq !< Operator `/='. ! public operators generic :: operator (. compatible .) => compatible !< Operator `.compatible.` overloading. ! public methods procedure , pass ( lhs ) :: compatible !< Operator `.compatible.`. endtype primitive_compressible_multispecie","tags":"","loc":"type/primitive_compressible_multispecie.html","title":"primitive_compressible_multispecie – FLOw "},{"text":"type, public, abstract, extends( field_object ) :: primitive_object type~~primitive_object~~InheritsGraph type~primitive_object primitive_object type~field_object field_object type~field_object->type~primitive_object Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Primitive object. Inherited By type~~primitive_object~~InheritedByGraph type~primitive_object primitive_object type~primitive_compressible primitive_compressible type~primitive_object->type~primitive_compressible type~primitive_compressible_multispecie primitive_compressible_multispecie type~primitive_object->type~primitive_compressible_multispecie Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Type-Bound Procedures add array assign_field assign_real assignment(=) description destroy div div_integer div_real energy eq initialize integer_mul momentum mul mul_integer mul_real negative not_eq operator(*) operator(**) operator(+) operator(-) operator(/) operator(/=) operator(==) positive pow_integer pow_real real_mul sub Source Code primitive_object Type-Bound Procedures procedure( symmetric_op_interface ), public, deferred, pass(lhs) :: add Operator + . elemental function symmetric_op_interface (lhs, rhs) result(opr) Prototype Operator field.op.field . Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure( array_interface ), public, deferred, pass(self) :: array Return serialized array of field. pure function array_interface (self) result(array_) Prototype Return serialized array of field. Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: self Field. Return Value real(kind=R8P),\n  allocatable, (:) Serialized array of field. procedure( assign_interface ), public, deferred, pass(lhs) :: assign_field Operator = . elemental subroutine assign_interface (lhs, rhs) Prototype Operator = . Arguments Type Intent Optional Attributes Name class( field_object ), intent(inout) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. procedure( assign_real_interface ), public, deferred, pass(lhs) :: assign_real Operator field = real . elemental subroutine assign_real_interface (lhs, rhs) Prototype Operator field = real . Arguments Type Intent Optional Attributes Name class( field_object ), intent(inout) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. generic, public :: assignment(=) => assign_field , assign_real Assignment overloading. private elemental subroutine assign_field (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(inout) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. private elemental subroutine assign_real (lhs, rhs) Operator field = real . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(inout) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. procedure( description_interface ), public, deferred, pass(self) :: description Return pretty-printed object description. pure function description_interface (self, prefix) result(desc) Prototype Return a pretty-formatted object description. Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: self Field. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. procedure( destroy_interface ), public, deferred, pass(self) :: destroy Destroy primitive. elemental subroutine destroy_interface (self) Prototype Destroy primitive. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(inout) :: self Primitive. procedure( symmetric_op_interface ), public, deferred, pass(lhs) :: div Operator / . elemental function symmetric_op_interface (lhs, rhs) result(opr) Prototype Operator field.op.field . Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure( field_op_integer_interface ), public, deferred, pass(lhs) :: div_integer Operator field / integer . elemental function field_op_integer_interface (lhs, rhs) result(opr) Prototype Operator field.op.integer . Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure( field_op_real_interface ), public, deferred, pass(lhs) :: div_real Operator field / real . elemental function field_op_real_interface (lhs, rhs) result(opr) Prototype Operator field.op.real . Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure( energy_interface ), public, deferred, pass(self) :: energy Return energy value. elemental function energy_interface (self, eos) result(energy_) Prototype Return energy value. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: self Primitive. class( eos_object ), intent(in) :: eos Equation of state. Return Value real(kind=R8P) Energy value. procedure( compare_interface ), public, deferred, pass(lhs) :: eq Operator `=='. elemental function compare_interface (lhs, rhs) result(opr) Prototype Operator `field.compare.field'. Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. procedure( initialize_interface ), public, deferred, pass(self) :: initialize Initialize primitive. subroutine initialize_interface (self, initial_state) Prototype Initialize primitive. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(inout) :: self Primitive. class( primitive_object ), intent(in), optional :: initial_state Initial state. procedure( integer_op_field_interface ), public, deferred, pass(rhs) :: integer_mul Operator integer * field . elemental function integer_op_field_interface (lhs, rhs) result(opr) Prototype Operator field.op.integer . Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure( momentum_interface ), public, deferred, pass(self) :: momentum Return momentum vector. elemental function momentum_interface (self) result(momentum_) Prototype Return momentum vector. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: self Primitive. Return Value type(vector) Momentum vector. procedure( symmetric_op_interface ), public, deferred, pass(lhs) :: mul Operator * . elemental function symmetric_op_interface (lhs, rhs) result(opr) Prototype Operator field.op.field . Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure( field_op_integer_interface ), public, deferred, pass(lhs) :: mul_integer Operator field * integer . elemental function field_op_integer_interface (lhs, rhs) result(opr) Prototype Operator field.op.integer . Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure( field_op_real_interface ), public, deferred, pass(lhs) :: mul_real Operator field * real . elemental function field_op_real_interface (lhs, rhs) result(opr) Prototype Operator field.op.real . Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure( unary_operator ), public, deferred, pass(self) :: negative Unary operator - field . function unary_operator (self) result(opr) Prototype Unary operator .op.field . Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: self Field. Return Value class( field_object ),\n  allocatable Operator result. procedure( compare_interface ), public, deferred, pass(lhs) :: not_eq Operator `/='. elemental function compare_interface (lhs, rhs) result(opr) Prototype Operator `field.compare.field'. Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. generic, public :: operator(*) => mul , mul_integer , integer_mul , real_mul , mul_real Operator * overloading. private elemental function mul (lhs, rhs) result(opr) Operator * . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function mul_integer (lhs, rhs) result(opr) Operator field * integer . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function integer_mul (lhs, rhs) result(opr) Operator integer * field . Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: lhs Left hand side. class( primitive_compressible_multispecie ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function real_mul (lhs, rhs) result(opr) Operator real * field . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs Left hand side. class( primitive_compressible_multispecie ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function mul_real (lhs, rhs) result(opr) Operator field * real . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. generic, public :: operator(**) => pow_integer , pow_real Operator ** overloading. private elemental function pow_integer (lhs, rhs) result(opr) Operator field ** integer . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function pow_real (lhs, rhs) result(opr) Operator field ** real . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. generic, public :: operator(+) => add , positive Operator + overloading. private elemental function add (lhs, rhs) result(opr) Operator + . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private function positive (self) result(opr) Unary operator + field . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: self Primitive. Return Value class( field_object ),\n  allocatable Operator result. generic, public :: operator(-) => sub , negative Operator - overloading. private elemental function sub (lhs, rhs) result(opr) Operator - . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private function negative (self) result(operator_result) Unary operator - field . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: self Primitive. Return Value class( field_object ),\n  allocatable Operator result. generic, public :: operator(/) => div , div_integer , div_real Operator / overloading. private elemental function div (lhs, rhs) result(opr) Operator / . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function div_integer (lhs, rhs) result(opr) Operator field / integer . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function div_real (lhs, rhs) result(opr) Operator field / real . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. generic, public :: operator(/=) => not_eq Operator /= overloading. private elemental function not_eq (lhs, rhs) result(opr) Operator `/='. Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. generic, public :: operator(==) => eq Operator /= overloading. private elemental function eq (lhs, rhs) result(opr) Operator `=='. Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. procedure( unary_operator ), public, deferred, pass(self) :: positive Unary operator + field . function unary_operator (self) result(opr) Prototype Unary operator .op.field . Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: self Field. Return Value class( field_object ),\n  allocatable Operator result. procedure( field_op_integer_interface ), public, deferred, pass(lhs) :: pow_integer Operator field ** integer . elemental function field_op_integer_interface (lhs, rhs) result(opr) Prototype Operator field.op.integer . Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure( field_op_real_interface ), public, deferred, pass(lhs) :: pow_real Operator field ** real . elemental function field_op_real_interface (lhs, rhs) result(opr) Prototype Operator field.op.real . Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure( real_op_field_interface ), public, deferred, pass(rhs) :: real_mul Operator real * field . elemental function real_op_field_interface (lhs, rhs) result(opr) Prototype Operator real.op.field . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. procedure( symmetric_op_interface ), public, deferred, pass(lhs) :: sub Operator - . elemental function symmetric_op_interface (lhs, rhs) result(opr) Prototype Operator field.op.field . Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code type , extends ( field_object ), abstract :: primitive_object !< **Primitive** object. contains ! deferred methods procedure ( destroy_interface ), pass ( self ), deferred :: destroy !< Destroy primitive. procedure ( energy_interface ), pass ( self ), deferred :: energy !< Return energy value. procedure ( initialize_interface ), pass ( self ), deferred :: initialize !< Initialize primitive. procedure ( momentum_interface ), pass ( self ), deferred :: momentum !< Return momentum vector. endtype primitive_object","tags":"","loc":"type/primitive_object.html","title":"primitive_object – FLOw "},{"text":"type, public :: Vector Vector class. Inherited By type~~vector~~InheritedByGraph type~vector Vector type~vector_ptr Vector_Ptr type~vector->type~vector_ptr p Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Variables x y z Type-Bound Procedures I1P_eq_self I1P_great_eq_self I1P_great_self I1P_low_eq_self I1P_low_self I1P_not_eq_self I2P_eq_self I2P_great_eq_self I2P_great_self I2P_low_eq_self I2P_low_self I2P_not_eq_self I4P_eq_self I4P_great_eq_self I4P_great_self I4P_low_eq_self I4P_low_self I4P_not_eq_self I8P_eq_self I8P_great_eq_self I8P_great_self I8P_low_eq_self I8P_low_self I8P_not_eq_self R4P_eq_self R4P_great_eq_self R4P_great_self R4P_low_eq_self R4P_low_self R4P_not_eq_self R8P_eq_self R8P_great_eq_self R8P_great_self R8P_low_eq_self R8P_low_self R8P_not_eq_self ScalI1P_mul_self ScalI1P_sub_self ScalI1P_sum_self ScalI2P_mul_self ScalI2P_sub_self ScalI2P_sum_self ScalI4P_mul_self ScalI4P_sub_self ScalI4P_sum_self ScalI8P_mul_self ScalI8P_sub_self ScalI8P_sum_self ScalR4P_mul_self ScalR4P_sub_self ScalR4P_sum_self ScalR8P_mul_self ScalR8P_sub_self ScalR8P_sum_self assign_ScalI1P assign_ScalI2P assign_ScalI4P assign_ScalI8P assign_ScalR4P assign_ScalR8P assign_self assignment(=) crossproduct dotproduct face_normal3 face_normal4 init iolen load negative_self normL2 normalize normalized operator(*) operator(+) operator(-) operator(.cross.) operator(.dot.) operator(.ortho.) operator(.paral.) operator(/) operator(/=) operator(<) operator(<=) operator(==) operator(>) operator(>=) orthogonal parallel positive_self print save self_div_ScalI1P self_div_ScalI2P self_div_ScalI4P self_div_ScalI8P self_div_ScalR4P self_div_ScalR8P self_div_self self_eq_I1P self_eq_I2P self_eq_I4P self_eq_I8P self_eq_R4P self_eq_R8P self_eq_self self_great_I1P self_great_I2P self_great_I4P self_great_I8P self_great_R4P self_great_R8P self_great_eq_I1P self_great_eq_I2P self_great_eq_I4P self_great_eq_I8P self_great_eq_R4P self_great_eq_R8P self_great_eq_self self_great_self self_low_I1P self_low_I2P self_low_I4P self_low_I8P self_low_R4P self_low_R8P self_low_eq_I1P self_low_eq_I2P self_low_eq_I4P self_low_eq_I8P self_low_eq_R4P self_low_eq_R8P self_low_eq_self self_low_self self_mul_ScalI1P self_mul_ScalI2P self_mul_ScalI4P self_mul_ScalI8P self_mul_ScalR4P self_mul_ScalR8P self_mul_self self_not_eq_I1P self_not_eq_I2P self_not_eq_I4P self_not_eq_I8P self_not_eq_R4P self_not_eq_R8P self_not_eq_self self_sub_ScalI1P self_sub_ScalI2P self_sub_ScalI4P self_sub_ScalI8P self_sub_ScalR4P self_sub_ScalR8P self_sub_self self_sum_ScalI1P self_sum_ScalI2P self_sum_ScalI4P self_sum_ScalI8P self_sum_ScalR4P self_sum_ScalR8P self_sum_self set sq_norm Source Code Vector Components Type Visibility Attributes Name Initial real(kind=R8P), public :: x = 0._R8P Cartesian component in x direction. real(kind=R8P), public :: y = 0._R8P Cartesian component in y direction. real(kind=R8P), public :: z = 0._R8P Cartesian component in z direction. Type-Bound Procedures procedure, private, pass(self ) :: I1P_eq_self private elemental function I1P_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical procedure, private, pass(self ) :: I1P_great_eq_self private elemental function I1P_great_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical procedure, private, pass(self ) :: I1P_great_self private elemental function I1P_great_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical procedure, private, pass(self ) :: I1P_low_eq_self private elemental function I1P_low_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical procedure, private, pass(self ) :: I1P_low_self private elemental function I1P_low_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical procedure, private, pass(self ) :: I1P_not_eq_self private elemental function I1P_not_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical procedure, private, pass(self ) :: I2P_eq_self private elemental function I2P_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical procedure, private, pass(self ) :: I2P_great_eq_self private elemental function I2P_great_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical procedure, private, pass(self ) :: I2P_great_self private elemental function I2P_great_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical procedure, private, pass(self ) :: I2P_low_eq_self private elemental function I2P_low_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical procedure, private, pass(self ) :: I2P_low_self private elemental function I2P_low_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical procedure, private, pass(self ) :: I2P_not_eq_self private elemental function I2P_not_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical procedure, private, pass(self ) :: I4P_eq_self private elemental function I4P_eq_self (scal, self) result(compare) @brief Procedure returns .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical procedure, private, pass(self ) :: I4P_great_eq_self private elemental function I4P_great_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical procedure, private, pass(self ) :: I4P_great_self private elemental function I4P_great_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical procedure, private, pass(self ) :: I4P_low_eq_self private elemental function I4P_low_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical procedure, private, pass(self ) :: I4P_low_self private elemental function I4P_low_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical procedure, private, pass(self ) :: I4P_not_eq_self private elemental function I4P_not_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical procedure, private, pass(self ) :: I8P_eq_self private elemental function I8P_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical procedure, private, pass(self ) :: I8P_great_eq_self private elemental function I8P_great_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical procedure, private, pass(self ) :: I8P_great_self private elemental function I8P_great_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical procedure, private, pass(self ) :: I8P_low_eq_self private elemental function I8P_low_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical procedure, private, pass(self ) :: I8P_low_self private elemental function I8P_low_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical procedure, private, pass(self ) :: I8P_not_eq_self private elemental function I8P_not_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical procedure, private, pass(self ) :: R4P_eq_self private elemental function R4P_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical procedure, private, pass(self ) :: R4P_great_eq_self private elemental function R4P_great_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical procedure, private, pass(self ) :: R4P_great_self private elemental function R4P_great_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical procedure, private, pass(self ) :: R4P_low_eq_self private elemental function R4P_low_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical procedure, private, pass(self ) :: R4P_low_self private elemental function R4P_low_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical procedure, private, pass(self ) :: R4P_not_eq_self private elemental function R4P_not_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical procedure, private, pass(self ) :: R8P_eq_self private elemental function R8P_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical procedure, private, pass(self ) :: R8P_great_eq_self private elemental function R8P_great_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical procedure, private, pass(self ) :: R8P_great_self private elemental function R8P_great_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical procedure, private, pass(self ) :: R8P_low_eq_self private elemental function R8P_low_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical procedure, private, pass(self ) :: R8P_low_self private elemental function R8P_low_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical procedure, private, pass(self ) :: R8P_not_eq_self private elemental function R8P_not_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical procedure, private, pass(self ) :: ScalI1P_mul_self private elemental function ScalI1P_mul_self (scal, self) result(mul) Multiply scalar (integer I1P) for self. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) procedure, private, pass(self ) :: ScalI1P_sub_self private elemental function ScalI1P_sub_self (scal, self) result(sub) Subtract scalar (integer I1P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) procedure, private, pass(self ) :: ScalI1P_sum_self private elemental function ScalI1P_sum_self (scal, self) result(summ) Sum scalar (integer I1P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) procedure, private, pass(self ) :: ScalI2P_mul_self private elemental function ScalI2P_mul_self (scal, self) result(mul) Multiply scalar (integer I2P) for self. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) procedure, private, pass(self ) :: ScalI2P_sub_self private elemental function ScalI2P_sub_self (scal, self) result(sub) Subtract scalar (integer I2P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) procedure, private, pass(self ) :: ScalI2P_sum_self private elemental function ScalI2P_sum_self (scal, self) result(summ) Sum scalar (integer I2P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) procedure, private, pass(self ) :: ScalI4P_mul_self private elemental function ScalI4P_mul_self (scal, self) result(mul) Multiply scalar (integer I4P) for self. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) procedure, private, pass(self ) :: ScalI4P_sub_self private elemental function ScalI4P_sub_self (scal, self) result(sub) Subtract scalar (integer I4P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) procedure, private, pass(self ) :: ScalI4P_sum_self private elemental function ScalI4P_sum_self (scal, self) result(summ) Sum scalar (integer I4P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) procedure, private, pass(self ) :: ScalI8P_mul_self private elemental function ScalI8P_mul_self (scal, self) result(mul) Multiply scalar (integer I8P) for self. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) procedure, private, pass(self ) :: ScalI8P_sub_self private elemental function ScalI8P_sub_self (scal, self) result(sub) Subtract scalar (integer I8P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) procedure, private, pass(self ) :: ScalI8P_sum_self private elemental function ScalI8P_sum_self (scal, self) result(summ) Sum scalar (integer I8P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) procedure, private, pass(self ) :: ScalR4P_mul_self private elemental function ScalR4P_mul_self (scal, self) result(mul) Multiply scalar (real R4P) for self. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) procedure, private, pass(self ) :: ScalR4P_sub_self private elemental function ScalR4P_sub_self (scal, self) result(sub) Subtract scalar (real R4P) and self. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) procedure, private, pass(self ) :: ScalR4P_sum_self private elemental function ScalR4P_sum_self (scal, self) result(summ) Sum scalar (real R4P) and self. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) procedure, private, pass(self ) :: ScalR8P_mul_self private elemental function ScalR8P_mul_self (scal, self) result(mul) Multiply scalar (real R8P) for self. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) procedure, private, pass(self ) :: ScalR8P_sub_self private elemental function ScalR8P_sub_self (scal, self) result(sub) Subtract scalar (real R8P) and self. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) procedure, private, pass(self ) :: ScalR8P_sum_self private elemental function ScalR8P_sum_self (scal, self) result(summ) Sum scalar (real R8P) and self. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) procedure, private, pass(self ) :: assign_ScalI1P private elemental subroutine assign_ScalI1P (self, scal) Assignment between a scalar (integer I1P) and self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: self integer(kind=I1P), intent(in) :: scal procedure, private, pass(self ) :: assign_ScalI2P private elemental subroutine assign_ScalI2P (self, scal) Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: self Assignment between a scalar (integer I2P) and self. integer(kind=I2P), intent(in) :: scal procedure, private, pass(self ) :: assign_ScalI4P private elemental subroutine assign_ScalI4P (self, scal) Assignment between a scalar (integer I4P) and self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: self integer(kind=I4P), intent(in) :: scal procedure, private, pass(self ) :: assign_ScalI8P private elemental subroutine assign_ScalI8P (self, scal) Assignment between a scalar (integer I8P) and self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: self integer(kind=I8P), intent(in) :: scal procedure, private, pass(self ) :: assign_ScalR4P private elemental subroutine assign_ScalR4P (self, scal) Assignment between a scalar (real R4P) and self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: self real(kind=R4P), intent(in) :: scal procedure, private, pass(self ) :: assign_ScalR8P private elemental subroutine assign_ScalR8P (self, scal) Assignment between a scalar (real R8P) and self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: self real(kind=R8P), intent(in) :: scal procedure, private, pass(self1) :: assign_self private pure subroutine assign_self (self1, self2) Assignment between two selfs. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: self1 class( Vector ), intent(in) :: self2 generic, public :: assignment(=) => assign_self , assign_ScalR8P , assign_ScalR4P , assign_ScalI8P , assign_ScalI4P , assign_ScalI2P , assign_ScalI1P private pure subroutine assign_self (self1, self2) Assignment between two selfs. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: self1 class( Vector ), intent(in) :: self2 private elemental subroutine assign_ScalR8P (self, scal) Assignment between a scalar (real R8P) and self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: self real(kind=R8P), intent(in) :: scal private elemental subroutine assign_ScalR4P (self, scal) Assignment between a scalar (real R4P) and self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: self real(kind=R4P), intent(in) :: scal private elemental subroutine assign_ScalI8P (self, scal) Assignment between a scalar (integer I8P) and self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: self integer(kind=I8P), intent(in) :: scal private elemental subroutine assign_ScalI4P (self, scal) Assignment between a scalar (integer I4P) and self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: self integer(kind=I4P), intent(in) :: scal private elemental subroutine assign_ScalI2P (self, scal) Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: self Assignment between a scalar (integer I2P) and self. integer(kind=I2P), intent(in) :: scal private elemental subroutine assign_ScalI1P (self, scal) Assignment between a scalar (integer I1P) and self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: self integer(kind=I1P), intent(in) :: scal procedure, private, pass(vec1) :: crossproduct private elemental function crossproduct (vec1, vec2) result(cross) Compute the cross product of 2 vectors. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: vec1 First vector. type( Vector ), intent(in) :: vec2 Second vector. Return Value type( Vector ) Cross product vector. procedure, private, pass(vec1) :: dotproduct private elemental function dotproduct (vec1, vec2) result(dot) Compute the scalar (dot) product of 2 vectors. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: vec1 First vector. type( Vector ), intent(in) :: vec2 Second vector. Return Value real(kind=R8P) Dot product. procedure, public :: face_normal3 => face_normal3_self private elemental subroutine face_normal3_self (fnormal, pt1, pt2, pt3, norm) Calculate the normal of the face defined by the 3 points vector pt1, pt2 and pt3. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: fnormal Face normal. type( Vector ), intent(in) :: pt1 First face point. type( Vector ), intent(in) :: pt2 Second face point. type( Vector ), intent(in) :: pt3 Third face point. character(len=1), intent(in), optional :: norm If 'norm' is passed as argument the normal is normalized. procedure, public :: face_normal4 => face_normal4_self private elemental subroutine face_normal4_self (fnormal, pt1, pt2, pt3, pt4, norm) Calculate the normal of the face defined by 4 points vector pt1, pt2, pt3 and pt4. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: fnormal Face normal. type( Vector ), intent(in) :: pt1 First face point. type( Vector ), intent(in) :: pt2 Second face point. type( Vector ), intent(in) :: pt3 Third face point. type( Vector ), intent(in) :: pt4 Fourth face point. character(len=1), intent(in), optional :: norm If 'norm' is passed as argument the normal is normalized. procedure, public :: init => init_vector_self private elemental subroutine init_vector_self (vec) Initialize components of Vector variable. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: vec Vector. procedure, public :: iolen => iolen_vector_self private function iolen_vector_self (vec) result(iolen) Compute IO length. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: vec Vector. Return Value integer(kind=I4P) IO length. procedure, public :: load => load_vector_self private subroutine load_vector_self (vec, unit, pos, iostat, iomsg) Load Vector data. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: vec Vector data. integer(kind=I4P), intent(in) :: unit Logic unit. integer(kind=I8P), intent(in), optional :: pos Position specifier. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message. procedure, private, pass(self ) :: negative_self private elemental function negative_self (self) result(neg) Applay unary - to a self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self Return Value type( Vector ) procedure, public :: normL2 => normL2_self private elemental function normL2_self (vec) result(norm) Compute the norm L2 of a vector. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: vec Vector. Return Value real(kind=R8P) Norm L2. procedure, public :: normalize => normalize_self private elemental subroutine normalize_self (vec) Normalize a vector. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: vec Vector to be normalized. procedure, public :: normalized => normalized_self private elemental function normalized_self (vec) result(norm) Get a normalized copy of a vector. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: vec Vector to be normalized. Return Value type( Vector ) Normalized copy. generic, public :: operator(*) => self_mul_self , ScalR8P_mul_self , self_mul_ScalR8P , ScalR4P_mul_self , self_mul_ScalR4P , ScalI8P_mul_self , self_mul_ScalI8P , ScalI4P_mul_self , self_mul_ScalI4P , ScalI2P_mul_self , self_mul_ScalI2P , ScalI1P_mul_self , self_mul_ScalI1P private elemental function self_mul_self (self1, self2) result(mul) Multiply (by components) two selfs. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 type( Vector ), intent(in) :: self2 Return Value type( Vector ) private elemental function ScalR8P_mul_self (scal, self) result(mul) Multiply scalar (real R8P) for self. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function self_mul_ScalR8P (self, scal) result(mul) Multiply self for scalar (real R8P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value type( Vector ) private elemental function ScalR4P_mul_self (scal, self) result(mul) Multiply scalar (real R4P) for self. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function self_mul_ScalR4P (self, scal) result(mul) Multiply self for scalar (real R4P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value type( Vector ) private elemental function ScalI8P_mul_self (scal, self) result(mul) Multiply scalar (integer I8P) for self. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function self_mul_ScalI8P (self, scal) result(mul) Multiply self for scalar (integer I8P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value type( Vector ) private elemental function ScalI4P_mul_self (scal, self) result(mul) Multiply scalar (integer I4P) for self. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function self_mul_ScalI4P (self, scal) result(mul) Multiply self for scalar (integer I4P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value type( Vector ) private elemental function ScalI2P_mul_self (scal, self) result(mul) Multiply scalar (integer I2P) for self. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function self_mul_ScalI2P (self, scal) result(mul) Multiply self for scalar (integer I2P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value type( Vector ) private elemental function ScalI1P_mul_self (scal, self) result(mul) Multiply scalar (integer I1P) for self. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function self_mul_ScalI1P (self, scal) result(mul) Multiply self for scalar (integer I1P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value type( Vector ) generic, public :: operator(+) => positive_self , self_sum_self , ScalR8P_sum_self , self_sum_ScalR8P , ScalR4P_sum_self , self_sum_ScalR4P , ScalI8P_sum_self , self_sum_ScalI8P , ScalI4P_sum_self , self_sum_ScalI4P , ScalI2P_sum_self , self_sum_ScalI2P , ScalI1P_sum_self , self_sum_ScalI1P private elemental function positive_self (self) result(pos) Applay unary + to a self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function self_sum_self (self1, self2) result(summ) Sum self and self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 type( Vector ), intent(in) :: self2 Return Value type( Vector ) private elemental function ScalR8P_sum_self (scal, self) result(summ) Sum scalar (real R8P) and self. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function self_sum_ScalR8P (self, scal) result(summ) Sum self and scalar (real R8P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value type( Vector ) private elemental function ScalR4P_sum_self (scal, self) result(summ) Sum scalar (real R4P) and self. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function self_sum_ScalR4P (self, scal) result(summ) Sum self and scalar (real R4P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value type( Vector ) private elemental function ScalI8P_sum_self (scal, self) result(summ) Sum scalar (integer I8P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function self_sum_ScalI8P (self, scal) result(summ) Sum self and scalar (integer I8P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value type( Vector ) private elemental function ScalI4P_sum_self (scal, self) result(summ) Sum scalar (integer I4P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function self_sum_ScalI4P (self, scal) result(summ) Sum self and scalar (integer I4P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value type( Vector ) private elemental function ScalI2P_sum_self (scal, self) result(summ) Sum scalar (integer I2P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function self_sum_ScalI2P (self, scal) result(summ) Sum self and scalar (integer I2P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value type( Vector ) private elemental function ScalI1P_sum_self (scal, self) result(summ) Sum scalar (integer I1P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function self_sum_ScalI1P (self, scal) result(summ) Sum self and scalar (integer I1P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value type( Vector ) generic, public :: operator(-) => negative_self , self_sub_self , ScalR8P_sub_self , self_sub_ScalR8P , ScalR4P_sub_self , self_sub_ScalR4P , ScalI8P_sub_self , self_sub_ScalI8P , ScalI4P_sub_self , self_sub_ScalI4P , ScalI2P_sub_self , self_sub_ScalI2P , ScalI1P_sub_self , self_sub_ScalI1P private elemental function negative_self (self) result(neg) Applay unary - to a self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function self_sub_self (self1, self2) result(sub) Subtract self and self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 type( Vector ), intent(in) :: self2 Return Value type( Vector ) private elemental function ScalR8P_sub_self (scal, self) result(sub) Subtract scalar (real R8P) and self. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function self_sub_ScalR8P (self, scal) result(sub) Subtract self and scalar (real R8P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value type( Vector ) private elemental function ScalR4P_sub_self (scal, self) result(sub) Subtract scalar (real R4P) and self. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function self_sub_ScalR4P (self, scal) result(sub) Subtract self and scalar (real R4P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value type( Vector ) private elemental function ScalI8P_sub_self (scal, self) result(sub) Subtract scalar (integer I8P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function self_sub_ScalI8P (self, scal) result(sub) Subtract self and scalar (integer I8P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value type( Vector ) private elemental function ScalI4P_sub_self (scal, self) result(sub) Subtract scalar (integer I4P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function self_sub_ScalI4P (self, scal) result(sub) Subtract self and scalar (integer I4P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value type( Vector ) private elemental function ScalI2P_sub_self (scal, self) result(sub) Subtract scalar (integer I2P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function self_sub_ScalI2P (self, scal) result(sub) Subtract self and scalar (integer I2P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value type( Vector ) private elemental function ScalI1P_sub_self (scal, self) result(sub) Subtract scalar (integer I1P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function self_sub_ScalI1P (self, scal) result(sub) Subtract self and scalar (integer I1P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value type( Vector ) generic, public :: operator(.cross.) => crossproduct private elemental function crossproduct (vec1, vec2) result(cross) Compute the cross product of 2 vectors. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: vec1 First vector. type( Vector ), intent(in) :: vec2 Second vector. Return Value type( Vector ) Cross product vector. generic, public :: operator(.dot.) => dotproduct private elemental function dotproduct (vec1, vec2) result(dot) Compute the scalar (dot) product of 2 vectors. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: vec1 First vector. type( Vector ), intent(in) :: vec2 Second vector. Return Value real(kind=R8P) Dot product. generic, public :: operator(.ortho.) => orthogonal private elemental function orthogonal (vec1, vec2) result(ortho) Compute the component of vec1 orthogonal to vec2. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: vec1 First vector. type( Vector ), intent(in) :: vec2 Second vector. Return Value type( Vector ) Component of of vec1 orthogonal to vec2. generic, public :: operator(.paral.) => parallel private elemental function parallel (vec1, vec2) result(paral) Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: vec1 Compute the component of vec1 parallel to vec2.\n First vector. type( Vector ), intent(in) :: vec2 Second vector. Return Value type( Vector ) Component of of vec1 parallel to vec2. generic, public :: operator(/) => self_div_self , self_div_ScalR8P , self_div_ScalR4P , self_div_ScalI8P , self_div_ScalI4P , self_div_ScalI2P , self_div_ScalI1P private elemental function self_div_self (self1, self2) result(div) Divide self for self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 type( Vector ), intent(in) :: self2 Return Value type( Vector ) private elemental function self_div_ScalR8P (self, scal) result(div) Divide self for scalar (real R8P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value type( Vector ) private elemental function self_div_ScalR4P (self, scal) result(div) Divide self for scalar (real R4P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value type( Vector ) private elemental function self_div_ScalI8P (self, scal) result(div) Divide self for scalar (integer I8P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value type( Vector ) private elemental function self_div_ScalI4P (self, scal) result(div) Divide self for scalar (integer I4P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value type( Vector ) private elemental function self_div_ScalI2P (self, scal) result(div) Divide self for scalar (integer I2P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value type( Vector ) private elemental function self_div_ScalI1P (self, scal) result(div) Divide self for scalar (integer I1P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value type( Vector ) generic, public :: operator(/=) => self_not_eq_self , R8P_not_eq_self , self_not_eq_R8P , R4P_not_eq_self , self_not_eq_R4P , I8P_not_eq_self , self_not_eq_I8P , I4P_not_eq_self , self_not_eq_I4P , I2P_not_eq_self , self_not_eq_I2P , I1P_not_eq_self , self_not_eq_I1P private elemental function self_not_eq_self (self1, self2) result(compare) Return .true. if the normL2 of the self1 is /= with respect the normL2 of self2 or if the directions of self1\n and self2 are different, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 First selftor. type( Vector ), intent(in) :: self2 Second selftor. Return Value logical The result of the comparison. private elemental function R8P_not_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_not_eq_R8P (self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value logical private elemental function R4P_not_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_not_eq_R4P (self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value logical private elemental function I8P_not_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_not_eq_I8P (self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value logical private elemental function I4P_not_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_not_eq_I4P (self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value logical private elemental function I2P_not_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_not_eq_I2P (self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value logical private elemental function I1P_not_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_not_eq_I1P (self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value logical generic, public :: operator(<) => self_low_self , R8P_low_self , self_low_R8P , R4P_low_self , self_low_R4P , I8P_low_self , self_low_I8P , I4P_low_self , self_low_I4P , I2P_low_self , self_low_I2P , I1P_low_self , self_low_I1P private elemental function self_low_self (self1, self2) result(compare) Return .true. if the normL2 of the self1 is < with respect the normL2 of self2, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 type( Vector ), intent(in) :: self2 Return Value logical private elemental function R8P_low_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_low_R8P (self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value logical private elemental function R4P_low_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_low_R4P (self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value logical private elemental function I8P_low_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_low_I8P (self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value logical private elemental function I4P_low_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_low_I4P (self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value logical private elemental function I2P_low_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_low_I2P (self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value logical private elemental function I1P_low_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_low_I1P (self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value logical generic, public :: operator(<=) => self_low_eq_self , R8P_low_eq_self , self_low_eq_R8P , R4P_low_eq_self , self_low_eq_R4P , I8P_low_eq_self , self_low_eq_I8P , I4P_low_eq_self , self_low_eq_I4P , I2P_low_eq_self , self_low_eq_I2P , I1P_low_eq_self , self_low_eq_I1P private elemental function self_low_eq_self (self1, self2) result(compare) Return .true. if the normL2 of the self1 is <= with respect the normL2 of self2, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 type( Vector ), intent(in) :: self2 Return Value logical private elemental function R8P_low_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_low_eq_R8P (self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value logical private elemental function R4P_low_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_low_eq_R4P (self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value logical private elemental function I8P_low_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_low_eq_I8P (self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value logical private elemental function I4P_low_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_low_eq_I4P (self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value logical private elemental function I2P_low_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_low_eq_I2P (self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value logical private elemental function I1P_low_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_low_eq_I1P (self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value logical generic, public :: operator(==) => self_eq_self , R8P_eq_self , self_eq_R8P , R4P_eq_self , self_eq_R4P , I8P_eq_self , self_eq_I8P , I4P_eq_self , self_eq_I4P , I2P_eq_self , self_eq_I2P , I1P_eq_self , self_eq_I1P private elemental function self_eq_self (self1, self2) result(compare) Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 Return .true. if the normL2 of the self1 is = with respect the normL2 of self2 and the directions of\n self1 and self2 are the same, .false. otherwise. type( Vector ), intent(in) :: self2 Return Value logical private elemental function R8P_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_eq_R8P (self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value logical private elemental function R4P_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_eq_R4P (self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value logical private elemental function I8P_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_eq_I8P (self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value logical private elemental function I4P_eq_self (scal, self) result(compare) @brief Procedure returns .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_eq_I4P (self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value logical private elemental function I2P_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_eq_I2P (self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value logical private elemental function I1P_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_eq_I1P (self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value logical generic, public :: operator(>) => self_great_self , R8P_great_self , self_great_R8P , R4P_great_self , self_great_R4P , I8P_great_self , self_great_I8P , I4P_great_self , self_great_I4P , I2P_great_self , self_great_I2P , I1P_great_self , self_great_I1P private elemental function self_great_self (self1, self2) result(compare) Return .true. if the normL2 of the self1 is > with respect the normL2 of self2, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 type( Vector ), intent(in) :: self2 Return Value logical private elemental function R8P_great_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_great_R8P (self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value logical private elemental function R4P_great_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_great_R4P (self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value logical private elemental function I8P_great_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_great_I8P (self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value logical private elemental function I4P_great_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_great_I4P (self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value logical private elemental function I2P_great_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_great_I2P (self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value logical private elemental function I1P_great_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_great_I1P (self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value logical generic, public :: operator(>=) => self_great_eq_self , R8P_great_eq_self , self_great_eq_R8P , R4P_great_eq_self , self_great_eq_R4P , I8P_great_eq_self , self_great_eq_I8P , I4P_great_eq_self , self_great_eq_I4P , I2P_great_eq_self , self_great_eq_I2P , I1P_great_eq_self , self_great_eq_I1P private elemental function self_great_eq_self (self1, self2) result(compare) Return .true. if the normL2 of the self1 is >= with respect the normL2 of self2, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 type( Vector ), intent(in) :: self2 Return Value logical private elemental function R8P_great_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_great_eq_R8P (self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value logical private elemental function R4P_great_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_great_eq_R4P (self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value logical private elemental function I8P_great_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_great_eq_I8P (self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value logical private elemental function I4P_great_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_great_eq_I4P (self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value logical private elemental function I2P_great_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_great_eq_I2P (self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value logical private elemental function I1P_great_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function self_great_eq_I1P (self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value logical procedure, private, pass(vec1) :: orthogonal private elemental function orthogonal (vec1, vec2) result(ortho) Compute the component of vec1 orthogonal to vec2. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: vec1 First vector. type( Vector ), intent(in) :: vec2 Second vector. Return Value type( Vector ) Component of of vec1 orthogonal to vec2. procedure, private, pass(vec1) :: parallel private elemental function parallel (vec1, vec2) result(paral) Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: vec1 Compute the component of vec1 parallel to vec2.\n First vector. type( Vector ), intent(in) :: vec2 Second vector. Return Value type( Vector ) Component of of vec1 parallel to vec2. procedure, private, pass(self ) :: positive_self private elemental function positive_self (self) result(pos) Applay unary + to a self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self Return Value type( Vector ) procedure, public :: print => print_vector_self private subroutine print_vector_self (vec, unit, pref, iostat, iomsg) Print in a pretty ascii format the components of type Vector. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: vec Vector. integer(kind=I4P), intent(in), optional :: unit Logic unit. character(len=*), intent(in), optional :: pref Prefixing string for outputs. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message. procedure, public :: save => save_vector_self private subroutine save_vector_self (vec, unit, pos, iostat, iomsg) Save Vector data. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: vec Vector data. integer(kind=I4P), intent(in) :: unit Logic unit. integer(kind=I8P), intent(in), optional :: pos Position specifier. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message. procedure, private, pass(self ) :: self_div_ScalI1P private elemental function self_div_ScalI1P (self, scal) result(div) Divide self for scalar (integer I1P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value type( Vector ) procedure, private, pass(self ) :: self_div_ScalI2P private elemental function self_div_ScalI2P (self, scal) result(div) Divide self for scalar (integer I2P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value type( Vector ) procedure, private, pass(self ) :: self_div_ScalI4P private elemental function self_div_ScalI4P (self, scal) result(div) Divide self for scalar (integer I4P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value type( Vector ) procedure, private, pass(self ) :: self_div_ScalI8P private elemental function self_div_ScalI8P (self, scal) result(div) Divide self for scalar (integer I8P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value type( Vector ) procedure, private, pass(self ) :: self_div_ScalR4P private elemental function self_div_ScalR4P (self, scal) result(div) Divide self for scalar (real R4P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value type( Vector ) procedure, private, pass(self ) :: self_div_ScalR8P private elemental function self_div_ScalR8P (self, scal) result(div) Divide self for scalar (real R8P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value type( Vector ) procedure, private, pass(self1) :: self_div_self private elemental function self_div_self (self1, self2) result(div) Divide self for self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 type( Vector ), intent(in) :: self2 Return Value type( Vector ) procedure, private, pass(self ) :: self_eq_I1P private elemental function self_eq_I1P (self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value logical procedure, private, pass(self ) :: self_eq_I2P private elemental function self_eq_I2P (self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value logical procedure, private, pass(self ) :: self_eq_I4P private elemental function self_eq_I4P (self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value logical procedure, private, pass(self ) :: self_eq_I8P private elemental function self_eq_I8P (self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value logical procedure, private, pass(self ) :: self_eq_R4P private elemental function self_eq_R4P (self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value logical procedure, private, pass(self ) :: self_eq_R8P private elemental function self_eq_R8P (self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value logical procedure, private, pass(self1) :: self_eq_self private elemental function self_eq_self (self1, self2) result(compare) Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 Return .true. if the normL2 of the self1 is = with respect the normL2 of self2 and the directions of\n self1 and self2 are the same, .false. otherwise. type( Vector ), intent(in) :: self2 Return Value logical procedure, private, pass(self ) :: self_great_I1P private elemental function self_great_I1P (self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value logical procedure, private, pass(self ) :: self_great_I2P private elemental function self_great_I2P (self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value logical procedure, private, pass(self ) :: self_great_I4P private elemental function self_great_I4P (self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value logical procedure, private, pass(self ) :: self_great_I8P private elemental function self_great_I8P (self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value logical procedure, private, pass(self ) :: self_great_R4P private elemental function self_great_R4P (self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value logical procedure, private, pass(self ) :: self_great_R8P private elemental function self_great_R8P (self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value logical procedure, private, pass(self ) :: self_great_eq_I1P private elemental function self_great_eq_I1P (self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value logical procedure, private, pass(self ) :: self_great_eq_I2P private elemental function self_great_eq_I2P (self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value logical procedure, private, pass(self ) :: self_great_eq_I4P private elemental function self_great_eq_I4P (self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value logical procedure, private, pass(self ) :: self_great_eq_I8P private elemental function self_great_eq_I8P (self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value logical procedure, private, pass(self ) :: self_great_eq_R4P private elemental function self_great_eq_R4P (self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value logical procedure, private, pass(self ) :: self_great_eq_R8P private elemental function self_great_eq_R8P (self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value logical procedure, private, pass(self1) :: self_great_eq_self private elemental function self_great_eq_self (self1, self2) result(compare) Return .true. if the normL2 of the self1 is >= with respect the normL2 of self2, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 type( Vector ), intent(in) :: self2 Return Value logical procedure, private, pass(self1) :: self_great_self private elemental function self_great_self (self1, self2) result(compare) Return .true. if the normL2 of the self1 is > with respect the normL2 of self2, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 type( Vector ), intent(in) :: self2 Return Value logical procedure, private, pass(self ) :: self_low_I1P private elemental function self_low_I1P (self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value logical procedure, private, pass(self ) :: self_low_I2P private elemental function self_low_I2P (self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value logical procedure, private, pass(self ) :: self_low_I4P private elemental function self_low_I4P (self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value logical procedure, private, pass(self ) :: self_low_I8P private elemental function self_low_I8P (self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value logical procedure, private, pass(self ) :: self_low_R4P private elemental function self_low_R4P (self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value logical procedure, private, pass(self ) :: self_low_R8P private elemental function self_low_R8P (self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value logical procedure, private, pass(self ) :: self_low_eq_I1P private elemental function self_low_eq_I1P (self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value logical procedure, private, pass(self ) :: self_low_eq_I2P private elemental function self_low_eq_I2P (self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value logical procedure, private, pass(self ) :: self_low_eq_I4P private elemental function self_low_eq_I4P (self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value logical procedure, private, pass(self ) :: self_low_eq_I8P private elemental function self_low_eq_I8P (self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value logical procedure, private, pass(self ) :: self_low_eq_R4P private elemental function self_low_eq_R4P (self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value logical procedure, private, pass(self ) :: self_low_eq_R8P private elemental function self_low_eq_R8P (self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value logical procedure, private, pass(self1) :: self_low_eq_self private elemental function self_low_eq_self (self1, self2) result(compare) Return .true. if the normL2 of the self1 is <= with respect the normL2 of self2, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 type( Vector ), intent(in) :: self2 Return Value logical procedure, private, pass(self1) :: self_low_self private elemental function self_low_self (self1, self2) result(compare) Return .true. if the normL2 of the self1 is < with respect the normL2 of self2, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 type( Vector ), intent(in) :: self2 Return Value logical procedure, private, pass(self ) :: self_mul_ScalI1P private elemental function self_mul_ScalI1P (self, scal) result(mul) Multiply self for scalar (integer I1P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value type( Vector ) procedure, private, pass(self ) :: self_mul_ScalI2P private elemental function self_mul_ScalI2P (self, scal) result(mul) Multiply self for scalar (integer I2P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value type( Vector ) procedure, private, pass(self ) :: self_mul_ScalI4P private elemental function self_mul_ScalI4P (self, scal) result(mul) Multiply self for scalar (integer I4P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value type( Vector ) procedure, private, pass(self ) :: self_mul_ScalI8P private elemental function self_mul_ScalI8P (self, scal) result(mul) Multiply self for scalar (integer I8P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value type( Vector ) procedure, private, pass(self ) :: self_mul_ScalR4P private elemental function self_mul_ScalR4P (self, scal) result(mul) Multiply self for scalar (real R4P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value type( Vector ) procedure, private, pass(self ) :: self_mul_ScalR8P private elemental function self_mul_ScalR8P (self, scal) result(mul) Multiply self for scalar (real R8P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value type( Vector ) procedure, private, pass(self1) :: self_mul_self private elemental function self_mul_self (self1, self2) result(mul) Multiply (by components) two selfs. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 type( Vector ), intent(in) :: self2 Return Value type( Vector ) procedure, private, pass(self ) :: self_not_eq_I1P private elemental function self_not_eq_I1P (self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value logical procedure, private, pass(self ) :: self_not_eq_I2P private elemental function self_not_eq_I2P (self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value logical procedure, private, pass(self ) :: self_not_eq_I4P private elemental function self_not_eq_I4P (self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value logical procedure, private, pass(self ) :: self_not_eq_I8P private elemental function self_not_eq_I8P (self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value logical procedure, private, pass(self ) :: self_not_eq_R4P private elemental function self_not_eq_R4P (self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value logical procedure, private, pass(self ) :: self_not_eq_R8P private elemental function self_not_eq_R8P (self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value logical procedure, private, pass(self1) :: self_not_eq_self private elemental function self_not_eq_self (self1, self2) result(compare) Return .true. if the normL2 of the self1 is /= with respect the normL2 of self2 or if the directions of self1\n and self2 are different, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 First selftor. type( Vector ), intent(in) :: self2 Second selftor. Return Value logical The result of the comparison. procedure, private, pass(self ) :: self_sub_ScalI1P private elemental function self_sub_ScalI1P (self, scal) result(sub) Subtract self and scalar (integer I1P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value type( Vector ) procedure, private, pass(self ) :: self_sub_ScalI2P private elemental function self_sub_ScalI2P (self, scal) result(sub) Subtract self and scalar (integer I2P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value type( Vector ) procedure, private, pass(self ) :: self_sub_ScalI4P private elemental function self_sub_ScalI4P (self, scal) result(sub) Subtract self and scalar (integer I4P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value type( Vector ) procedure, private, pass(self ) :: self_sub_ScalI8P private elemental function self_sub_ScalI8P (self, scal) result(sub) Subtract self and scalar (integer I8P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value type( Vector ) procedure, private, pass(self ) :: self_sub_ScalR4P private elemental function self_sub_ScalR4P (self, scal) result(sub) Subtract self and scalar (real R4P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value type( Vector ) procedure, private, pass(self ) :: self_sub_ScalR8P private elemental function self_sub_ScalR8P (self, scal) result(sub) Subtract self and scalar (real R8P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value type( Vector ) procedure, private, pass(self1) :: self_sub_self private elemental function self_sub_self (self1, self2) result(sub) Subtract self and self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 type( Vector ), intent(in) :: self2 Return Value type( Vector ) procedure, private, pass(self ) :: self_sum_ScalI1P private elemental function self_sum_ScalI1P (self, scal) result(summ) Sum self and scalar (integer I1P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value type( Vector ) procedure, private, pass(self ) :: self_sum_ScalI2P private elemental function self_sum_ScalI2P (self, scal) result(summ) Sum self and scalar (integer I2P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value type( Vector ) procedure, private, pass(self ) :: self_sum_ScalI4P private elemental function self_sum_ScalI4P (self, scal) result(summ) Sum self and scalar (integer I4P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value type( Vector ) procedure, private, pass(self ) :: self_sum_ScalI8P private elemental function self_sum_ScalI8P (self, scal) result(summ) Sum self and scalar (integer I8P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value type( Vector ) procedure, private, pass(self ) :: self_sum_ScalR4P private elemental function self_sum_ScalR4P (self, scal) result(summ) Sum self and scalar (real R4P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value type( Vector ) procedure, private, pass(self ) :: self_sum_ScalR8P private elemental function self_sum_ScalR8P (self, scal) result(summ) Sum self and scalar (real R8P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value type( Vector ) procedure, private, pass(self1) :: self_sum_self private elemental function self_sum_self (self1, self2) result(summ) Sum self and self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 type( Vector ), intent(in) :: self2 Return Value type( Vector ) procedure, public :: set => set_vector_self private elemental subroutine set_vector_self (vec, x, y, z) Set components of Vector variable. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: vec Vector. real(kind=R8P), intent(in), optional :: x Cartesian component in x direction. real(kind=R8P), intent(in), optional :: y Cartesian component in y direction. real(kind=R8P), intent(in), optional :: z Cartesian component in z direction. procedure, public :: sq_norm => sq_norm_self private elemental function sq_norm_self (vec) result(sq) Compute the square of the norm of a vector. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: vec Vector. Return Value real(kind=R8P) Square of the Norm. Source Code type , public :: Vector !< Vector class. real ( R8P ) :: x = 0._R8P !< Cartesian component in x direction. real ( R8P ) :: y = 0._R8P !< Cartesian component in y direction. real ( R8P ) :: z = 0._R8P !< Cartesian component in z direction. contains procedure :: init => init_vector_self ! Procedure for initializing vector components. procedure :: set => set_vector_self ! Procedure for setting vector components. procedure :: iolen => iolen_vector_self ! Procedure for computing IO length. procedure :: load => load_vector_self ! Procedure for loading Vector data. procedure :: save => save_vector_self ! Procedure for saving Vector data. procedure :: print => print_vector_self ! Procedure for printing vector components with a \"pretty\" format. procedure :: sq_norm => sq_norm_self ! Procedure for computing the square of the norm of a vector. procedure :: normL2 => normL2_self ! Procedure for computing the norm L2 of a vector. procedure :: normalize => normalize_self ! Procedure for normalizing a vector. procedure :: normalized => normalized_self ! Procedure for obtaining a normalized copy of a vector. procedure :: face_normal4 => face_normal4_self ! Procedure for calculating the normal of the face defined by 4 points vector. procedure :: face_normal3 => face_normal3_self ! Procedure for calculating the normal of the face defined by 3 points vector. generic :: operator (. cross .) => crossproduct ! Procedure for computing the cross product of 2 vectors. generic :: operator (. dot .) => dotproduct ! Procedure for computing the scalar (dot) product of 2 vectors. generic :: operator (. paral .) => parallel ! Procedure for computing the component of vec1 parallel to vec2. generic :: operator (. ortho .) => orthogonal ! Procedure for computign the component of vec1 orthogonal to vec2. procedure , pass ( vec1 ), private :: crossproduct procedure , pass ( vec1 ), private :: dotproduct procedure , pass ( vec1 ), private :: parallel procedure , pass ( vec1 ), private :: orthogonal ! operators overloading generic :: assignment ( = ) => assign_self , & #ifdef r16p assign_ScalR16P ,& #endif assign_ScalR8P , assign_ScalR4P , assign_ScalI8P , assign_ScalI4P , assign_ScalI2P , assign_ScalI1P #ifdef r16p procedure , pass ( self ), private :: assign_ScalR16P #endif procedure , pass ( self1 ), private :: assign_self procedure , pass ( self ), private :: assign_ScalR8P procedure , pass ( self ), private :: assign_ScalR4P procedure , pass ( self ), private :: assign_ScalI8P procedure , pass ( self ), private :: assign_ScalI4P procedure , pass ( self ), private :: assign_ScalI2P procedure , pass ( self ), private :: assign_ScalI1P generic :: operator ( * ) => self_mul_self , & #ifdef r16p ScalR16P_mul_self , self_mul_ScalR16P , & #endif ScalR8P_mul_self , self_mul_ScalR8P , ScalR4P_mul_self , self_mul_ScalR4P , ScalI8P_mul_self , self_mul_ScalI8P ,& ScalI4P_mul_self , self_mul_ScalI4P , ScalI2P_mul_self , self_mul_ScalI2P , ScalI1P_mul_self , self_mul_ScalI1P #ifdef r16p procedure , pass ( self ), private :: ScalR16P_mul_self procedure , pass ( self ), private :: self_mul_ScalR16P #endif procedure , pass ( self1 ), private :: self_mul_self procedure , pass ( self ), private :: ScalR8P_mul_self procedure , pass ( self ), private :: ScalR4P_mul_self procedure , pass ( self ), private :: ScalI8P_mul_self procedure , pass ( self ), private :: ScalI4P_mul_self procedure , pass ( self ), private :: ScalI2P_mul_self procedure , pass ( self ), private :: ScalI1P_mul_self procedure , pass ( self ), private :: self_mul_ScalR8P procedure , pass ( self ), private :: self_mul_ScalR4P procedure , pass ( self ), private :: self_mul_ScalI8P procedure , pass ( self ), private :: self_mul_ScalI4P procedure , pass ( self ), private :: self_mul_ScalI2P procedure , pass ( self ), private :: self_mul_ScalI1P generic :: operator ( / ) => self_div_self , & #ifdef r16p self_div_ScalR16P ,& #endif self_div_ScalR8P , self_div_ScalR4P , self_div_ScalI8P , self_div_ScalI4P , self_div_ScalI2P , self_div_ScalI1P #ifdef r16p procedure , pass ( self ), private :: self_div_ScalR16P #endif procedure , pass ( self1 ), private :: self_div_self procedure , pass ( self ), private :: self_div_ScalR8P procedure , pass ( self ), private :: self_div_ScalR4P procedure , pass ( self ), private :: self_div_ScalI8P procedure , pass ( self ), private :: self_div_ScalI4P procedure , pass ( self ), private :: self_div_ScalI2P procedure , pass ( self ), private :: self_div_ScalI1P generic :: operator ( + ) => positive_self , self_sum_self , & #ifdef r16p ScalR16P_sum_self , self_sum_ScalR16P , & #endif ScalR8P_sum_self , self_sum_ScalR8P , ScalR4P_sum_self , self_sum_ScalR4P , ScalI8P_sum_self , self_sum_ScalI8P ,& ScalI4P_sum_self , self_sum_ScalI4P , ScalI2P_sum_self , self_sum_ScalI2P , ScalI1P_sum_self , self_sum_ScalI1P #ifdef r16p procedure , pass ( self ), private :: ScalR16P_sum_self procedure , pass ( self ), private :: self_sum_ScalR16P #endif procedure , pass ( self ), private :: positive_self procedure , pass ( self1 ), private :: self_sum_self procedure , pass ( self ), private :: ScalR8P_sum_self procedure , pass ( self ), private :: ScalR4P_sum_self procedure , pass ( self ), private :: ScalI8P_sum_self procedure , pass ( self ), private :: ScalI4P_sum_self procedure , pass ( self ), private :: ScalI2P_sum_self procedure , pass ( self ), private :: ScalI1P_sum_self procedure , pass ( self ), private :: self_sum_ScalR8P procedure , pass ( self ), private :: self_sum_ScalR4P procedure , pass ( self ), private :: self_sum_ScalI8P procedure , pass ( self ), private :: self_sum_ScalI4P procedure , pass ( self ), private :: self_sum_ScalI2P procedure , pass ( self ), private :: self_sum_ScalI1P generic :: operator ( - ) => negative_self , self_sub_self , & #ifdef r16p ScalR16P_sub_self , self_sub_ScalR16P , & #endif ScalR8P_sub_self , self_sub_ScalR8P , ScalR4P_sub_self , self_sub_ScalR4P , ScalI8P_sub_self , self_sub_ScalI8P ,& ScalI4P_sub_self , self_sub_ScalI4P , ScalI2P_sub_self , self_sub_ScalI2P , ScalI1P_sub_self , self_sub_ScalI1P #ifdef r16p procedure , pass ( self ), private :: ScalR16P_sub_self procedure , pass ( self ), private :: self_sub_ScalR16P #endif procedure , pass ( self ), private :: negative_self procedure , pass ( self1 ), private :: self_sub_self procedure , pass ( self ), private :: ScalR8P_sub_self procedure , pass ( self ), private :: ScalR4P_sub_self procedure , pass ( self ), private :: ScalI8P_sub_self procedure , pass ( self ), private :: ScalI4P_sub_self procedure , pass ( self ), private :: ScalI2P_sub_self procedure , pass ( self ), private :: ScalI1P_sub_self procedure , pass ( self ), private :: self_sub_ScalR8P procedure , pass ( self ), private :: self_sub_ScalR4P procedure , pass ( self ), private :: self_sub_ScalI8P procedure , pass ( self ), private :: self_sub_ScalI4P procedure , pass ( self ), private :: self_sub_ScalI2P procedure , pass ( self ), private :: self_sub_ScalI1P generic :: operator ( /= ) => self_not_eq_self , & #ifdef r16p R16P_not_eq_self , self_not_eq_R16P , & #endif R8P_not_eq_self , self_not_eq_R8P , R4P_not_eq_self , self_not_eq_R4P , I8P_not_eq_self , self_not_eq_I8P ,& I4P_not_eq_self , self_not_eq_I4P , I2P_not_eq_self , self_not_eq_I2P , I1P_not_eq_self , self_not_eq_I1P generic :: operator ( < ) => self_low_self , & #ifdef r16p R16P_low_self , self_low_R16P , & #endif R8P_low_self , self_low_R8P , R4P_low_self , self_low_R4P , I8P_low_self , self_low_I8P ,& I4P_low_self , self_low_I4P , I2P_low_self , self_low_I2P , I1P_low_self , self_low_I1P generic :: operator ( <= ) => self_low_eq_self , & #ifdef r16p R16P_low_eq_self , self_low_eq_R16P , & #endif R8P_low_eq_self , self_low_eq_R8P , R4P_low_eq_self , self_low_eq_R4P , I8P_low_eq_self , self_low_eq_I8P ,& I4P_low_eq_self , self_low_eq_I4P , I2P_low_eq_self , self_low_eq_I2P , I1P_low_eq_self , self_low_eq_I1P generic :: operator ( == ) => self_eq_self , & #ifdef r16p R16P_eq_self , self_eq_R16P , & #endif R8P_eq_self , self_eq_R8P , R4P_eq_self , self_eq_R4P , I8P_eq_self , self_eq_I8P ,& I4P_eq_self , self_eq_I4P , I2P_eq_self , self_eq_I2P , I1P_eq_self , self_eq_I1P generic :: operator ( >= ) => self_great_eq_self , & #ifdef r16p R16P_great_eq_self , self_great_eq_R16P , & #endif R8P_great_eq_self , self_great_eq_R8P , R4P_great_eq_self , self_great_eq_R4P , I8P_great_eq_self ,& self_great_eq_I8P , I4P_great_eq_self , self_great_eq_I4P , I2P_great_eq_self , self_great_eq_I2P ,& I1P_great_eq_self , self_great_eq_I1P generic :: operator ( > ) => self_great_self , & #ifdef r16p R16P_great_self , self_great_R16P , & #endif R8P_great_self , self_great_R8P , R4P_great_self , self_great_R4P , I8P_great_self , self_great_I8P ,& I4P_great_self , self_great_I4P , I2P_great_self , self_great_I2P , I1P_great_self , self_great_I1P #ifdef r16p procedure , pass ( self ), private :: R16P_not_eq_self procedure , pass ( self ), private :: self_not_eq_R16P procedure , pass ( self ), private :: R16P_low_self procedure , pass ( self ), private :: self_low_R16P procedure , pass ( self ), private :: R16P_low_eq_self procedure , pass ( self ), private :: self_low_eq_R16P procedure , pass ( self ), private :: R16P_eq_self procedure , pass ( self ), private :: self_eq_R16P procedure , pass ( self ), private :: R16P_great_eq_self procedure , pass ( self ), private :: self_great_eq_R16P procedure , pass ( self ), private :: R16P_great_self procedure , pass ( self ), private :: self_great_R16P #endif procedure , pass ( self1 ), private :: self_not_eq_self procedure , pass ( self ), private :: R8P_not_eq_self procedure , pass ( self ), private :: R4P_not_eq_self procedure , pass ( self ), private :: I8P_not_eq_self procedure , pass ( self ), private :: I4P_not_eq_self procedure , pass ( self ), private :: I2P_not_eq_self procedure , pass ( self ), private :: I1P_not_eq_self procedure , pass ( self ), private :: self_not_eq_R8P procedure , pass ( self ), private :: self_not_eq_R4P procedure , pass ( self ), private :: self_not_eq_I8P procedure , pass ( self ), private :: self_not_eq_I4P procedure , pass ( self ), private :: self_not_eq_I2P procedure , pass ( self ), private :: self_not_eq_I1P procedure , pass ( self1 ), private :: self_low_self procedure , pass ( self ), private :: R8P_low_self procedure , pass ( self ), private :: R4P_low_self procedure , pass ( self ), private :: I8P_low_self procedure , pass ( self ), private :: I4P_low_self procedure , pass ( self ), private :: I2P_low_self procedure , pass ( self ), private :: I1P_low_self procedure , pass ( self ), private :: self_low_R8P procedure , pass ( self ), private :: self_low_R4P procedure , pass ( self ), private :: self_low_I8P procedure , pass ( self ), private :: self_low_I4P procedure , pass ( self ), private :: self_low_I2P procedure , pass ( self ), private :: self_low_I1P procedure , pass ( self1 ), private :: self_low_eq_self procedure , pass ( self ), private :: R8P_low_eq_self procedure , pass ( self ), private :: R4P_low_eq_self procedure , pass ( self ), private :: I8P_low_eq_self procedure , pass ( self ), private :: I4P_low_eq_self procedure , pass ( self ), private :: I2P_low_eq_self procedure , pass ( self ), private :: I1P_low_eq_self procedure , pass ( self ), private :: self_low_eq_R8P procedure , pass ( self ), private :: self_low_eq_R4P procedure , pass ( self ), private :: self_low_eq_I8P procedure , pass ( self ), private :: self_low_eq_I4P procedure , pass ( self ), private :: self_low_eq_I2P procedure , pass ( self ), private :: self_low_eq_I1P procedure , pass ( self1 ), private :: self_eq_self procedure , pass ( self ), private :: R8P_eq_self procedure , pass ( self ), private :: R4P_eq_self procedure , pass ( self ), private :: I8P_eq_self procedure , pass ( self ), private :: I4P_eq_self procedure , pass ( self ), private :: I2P_eq_self procedure , pass ( self ), private :: I1P_eq_self procedure , pass ( self ), private :: self_eq_R8P procedure , pass ( self ), private :: self_eq_R4P procedure , pass ( self ), private :: self_eq_I8P procedure , pass ( self ), private :: self_eq_I4P procedure , pass ( self ), private :: self_eq_I2P procedure , pass ( self ), private :: self_eq_I1P procedure , pass ( self1 ), private :: self_great_eq_self procedure , pass ( self ), private :: R8P_great_eq_self procedure , pass ( self ), private :: R4P_great_eq_self procedure , pass ( self ), private :: I8P_great_eq_self procedure , pass ( self ), private :: I4P_great_eq_self procedure , pass ( self ), private :: I2P_great_eq_self procedure , pass ( self ), private :: I1P_great_eq_self procedure , pass ( self ), private :: self_great_eq_R8P procedure , pass ( self ), private :: self_great_eq_R4P procedure , pass ( self ), private :: self_great_eq_I8P procedure , pass ( self ), private :: self_great_eq_I4P procedure , pass ( self ), private :: self_great_eq_I2P procedure , pass ( self ), private :: self_great_eq_I1P procedure , pass ( self1 ), private :: self_great_self procedure , pass ( self ), private :: R8P_great_self procedure , pass ( self ), private :: R4P_great_self procedure , pass ( self ), private :: I8P_great_self procedure , pass ( self ), private :: I4P_great_self procedure , pass ( self ), private :: I2P_great_self procedure , pass ( self ), private :: I1P_great_self procedure , pass ( self ), private :: self_great_R8P procedure , pass ( self ), private :: self_great_R4P procedure , pass ( self ), private :: self_great_I8P procedure , pass ( self ), private :: self_great_I4P procedure , pass ( self ), private :: self_great_I2P procedure , pass ( self ), private :: self_great_I1P endtype Vector","tags":"","loc":"type/vector.html","title":"Vector – FLOw "},{"text":"type, public :: Vector_Ptr type~~vector_ptr~~InheritsGraph type~vector_ptr Vector_Ptr type~vector Vector type~vector->type~vector_ptr p Help × Graph Key Nodes of different colours represent the following: Graph Key Type Type This Page's Entity This Page's Entity Solid arrows point from one derived type to another which extends\n    (inherits from) it. Dashed arrows point from a derived type to another\n    type containing it as a components, with a label listing the name(s) of\n    said component(s). Pointer of Vector for creating array of pointers of Vector. Variables p Source Code Vector_Ptr Components Type Visibility Attributes Name Initial type( Vector ), public, pointer :: p => null() Source Code type , public :: Vector_Ptr !< Pointer of Vector for creating array of pointers of Vector. type ( Vector ), pointer :: p => null () endtype Vector_Ptr","tags":"","loc":"type/vector_ptr.html","title":"Vector_Ptr – FLOw "},{"text":"abstract interface Abstract interfaces of deferred methods of conservative_object . private subroutine compute_fluxes_interface(self, eos, normal, fluxes) Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(in) :: self Conservative. class( eos_object ), intent(in) :: eos Equation of state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(out) :: fluxes Conservative fluxes. Description Compute conservative fluxes.","tags":"","loc":"interface/compute_fluxes_interface.html","title":"compute_fluxes_interface – FLOw"},{"text":"abstract interface Abstract interfaces of deferred methods of conservative_object . private elemental subroutine destroy_interface(self) Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(inout) :: self conservative. Description Destroy conservative.","tags":"","loc":"interface/destroy_interface.html","title":"destroy_interface – FLOw"},{"text":"abstract interface Abstract interfaces of deferred methods of conservative_object . private subroutine initialize_interface(self, initial_state) Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(inout) :: self conservative. class( conservative_object ), intent(in), optional :: initial_state Initial state. Description Initialize conservative.","tags":"","loc":"interface/initialize_interface.html","title":"initialize_interface – FLOw"},{"text":"abstract interface Abstract interfaces of deferred methods of conservative_object . private elemental function pressure_interface(self, eos) result(pressure_) Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(in) :: self Conservative. class( eos_object ), intent(in) :: eos Equation of state. Return Value real(kind=R8P) Pressure value. Description Return pressure value.","tags":"","loc":"interface/pressure_interface.html","title":"pressure_interface – FLOw"},{"text":"abstract interface Abstract interfaces of deferred methods of conservative_object . private elemental function velocity_interface(self) result(velocity_) Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(in) :: self Conservative. Return Value type(vector) Velocity vector. Description Return velocity vector.","tags":"","loc":"interface/velocity_interface.html","title":"velocity_interface – FLOw"},{"text":"abstract interface Abstract interfaces of deferred methods of eos_object . private pure subroutine assignment_interface(lhs, rhs) Arguments Type Intent Optional Attributes Name class( eos_object ), intent(inout) :: lhs Left hand side. class( eos_object ), intent(in) :: rhs Right hand side. Description Operator = .","tags":"","loc":"interface/assignment_interface.html","title":"assignment_interface – FLOw"},{"text":"abstract interface Abstract interfaces of deferred methods of eos_object . private elemental function density_interface(self, pressure, speed_of_sound) result(density_) Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. real(kind=R8P), intent(in) :: pressure Pressure value. real(kind=R8P), intent(in) :: speed_of_sound Speed of sound value. Return Value real(kind=R8P) Density value. Description Return density.","tags":"","loc":"interface/density_interface.html","title":"density_interface – FLOw"},{"text":"abstract interface Abstract interfaces of deferred methods of eos_object . private pure function description_interface(self, prefix) result(desc) Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. Description Return a pretty-formatted object description.","tags":"","loc":"interface/description_interface~2.html","title":"description_interface – FLOw"},{"text":"abstract interface Abstract interfaces of deferred methods of eos_object . private elemental function internal_energy_interface(self, density, pressure, temperature) result(energy_) Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. real(kind=R8P), intent(in), optional :: density Density value. real(kind=R8P), intent(in), optional :: pressure Pressure value. real(kind=R8P), intent(in), optional :: temperature Temperature value. Return Value real(kind=R8P) Energy value. Description Return specific internal energy.","tags":"","loc":"interface/internal_energy_interface.html","title":"internal_energy_interface – FLOw"},{"text":"abstract interface Abstract interfaces of deferred methods of eos_object . private elemental function pressure_interface(self, density, energy, temperature) result(pressure_) Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. real(kind=R8P), intent(in), optional :: density Density value. real(kind=R8P), intent(in), optional :: energy Specific internal energy value. real(kind=R8P), intent(in), optional :: temperature Temperature value. Return Value real(kind=R8P) Pressure value. Description Return pressure.","tags":"","loc":"interface/pressure_interface~2.html","title":"pressure_interface – FLOw"},{"text":"abstract interface Abstract interfaces of deferred methods of eos_object . private elemental function scalar_interface(self) result(scalar_) Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. Return Value real(kind=R8P) Scalar value. Description Return a scalar real value by only self data.","tags":"","loc":"interface/scalar_interface.html","title":"scalar_interface – FLOw"},{"text":"abstract interface Abstract interfaces of deferred methods of eos_object . private elemental function speed_of_sound_interface(self, density, pressure) result(speed_of_sound_) Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. real(kind=R8P), intent(in) :: density Density value. real(kind=R8P), intent(in) :: pressure Pressure value. Return Value real(kind=R8P) Speed of sound value. Description Return speed of sound.","tags":"","loc":"interface/speed_of_sound_interface.html","title":"speed_of_sound_interface – FLOw"},{"text":"abstract interface Abstract interfaces of deferred methods of eos_object . private elemental function temperature_interface(self, density, energy, pressure) result(temperature_) Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. real(kind=R8P), intent(in), optional :: density Density value. real(kind=R8P), intent(in), optional :: energy Specific internal energy value. real(kind=R8P), intent(in), optional :: pressure Pressure value. Return Value real(kind=R8P) Temperature value. Description Return temperature.","tags":"","loc":"interface/temperature_interface.html","title":"temperature_interface – FLOw"},{"text":"abstract interface Abstract interfaces of deferred methods of eos_object . private elemental function total_entalpy_interface(self, density, pressure, velocity_sq_norm) result(entalpy_) Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. real(kind=R8P), intent(in) :: density Density value. real(kind=R8P), intent(in) :: pressure Pressure value. real(kind=R8P), intent(in) :: velocity_sq_norm Velocity vector square norm ||velocity||&#94;2 . Return Value real(kind=R8P) Total specific entalpy (per unit of mass). Description Return total specific entalpy.","tags":"","loc":"interface/total_entalpy_interface.html","title":"total_entalpy_interface – FLOw"},{"text":"abstract interface Abstract interfaces of deferred methods of field_object . private pure function array_interface(self) result(array_) Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: self Field. Return Value real(kind=R8P),\n  allocatable,(:) Serialized array of field. Description Return serialized array of field.","tags":"","loc":"interface/array_interface.html","title":"array_interface – FLOw"},{"text":"abstract interface Abstract interfaces of deferred methods of field_object . private elemental subroutine assign_interface(lhs, rhs) Arguments Type Intent Optional Attributes Name class( field_object ), intent(inout) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Description Operator = .","tags":"","loc":"interface/assign_interface.html","title":"assign_interface – FLOw"},{"text":"abstract interface Abstract interfaces of deferred methods of field_object . private elemental subroutine assign_real_interface(lhs, rhs) Arguments Type Intent Optional Attributes Name class( field_object ), intent(inout) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Description Operator field = real .","tags":"","loc":"interface/assign_real_interface.html","title":"assign_real_interface – FLOw"},{"text":"abstract interface Abstract interfaces of deferred methods of field_object . private elemental function compare_interface(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. Description Operator `field.compare.field'.","tags":"","loc":"interface/compare_interface.html","title":"compare_interface – FLOw"},{"text":"abstract interface Abstract interfaces of deferred methods of field_object . private pure function description_interface(self, prefix) result(desc) Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: self Field. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. Description Return a pretty-formatted object description.","tags":"","loc":"interface/description_interface.html","title":"description_interface – FLOw"},{"text":"abstract interface Abstract interfaces of deferred methods of field_object . private elemental function field_op_integer_interface(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Description Operator field.op.integer .","tags":"","loc":"interface/field_op_integer_interface.html","title":"field_op_integer_interface – FLOw"},{"text":"abstract interface Abstract interfaces of deferred methods of field_object . private elemental function field_op_real_interface(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Description Operator field.op.real .","tags":"","loc":"interface/field_op_real_interface.html","title":"field_op_real_interface – FLOw"},{"text":"abstract interface Abstract interfaces of deferred methods of field_object . private elemental function integer_op_field_interface(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Description Operator field.op.integer .","tags":"","loc":"interface/integer_op_field_interface.html","title":"integer_op_field_interface – FLOw"},{"text":"abstract interface Abstract interfaces of deferred methods of field_object . private elemental function real_op_field_interface(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Description Operator real.op.field .","tags":"","loc":"interface/real_op_field_interface.html","title":"real_op_field_interface – FLOw"},{"text":"abstract interface Abstract interfaces of deferred methods of field_object . private elemental function symmetric_op_interface(lhs, rhs) result(opr) Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Description Operator field.op.field .","tags":"","loc":"interface/symmetric_op_interface.html","title":"symmetric_op_interface – FLOw"},{"text":"abstract interface Abstract interfaces of deferred methods of field_object . private function unary_operator(self) result(opr) Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: self Field. Return Value class( field_object ),\n  allocatable Operator result. Description Unary operator .op.field .","tags":"","loc":"interface/unary_operator.html","title":"unary_operator – FLOw"},{"text":"abstract interface Abstract interfaces of deferred methods of primitive_object . private elemental subroutine destroy_interface(self) Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(inout) :: self Primitive. Description Destroy primitive.","tags":"","loc":"interface/destroy_interface~2.html","title":"destroy_interface – FLOw"},{"text":"abstract interface Abstract interfaces of deferred methods of primitive_object . private elemental function energy_interface(self, eos) result(energy_) Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: self Primitive. class( eos_object ), intent(in) :: eos Equation of state. Return Value real(kind=R8P) Energy value. Description Return energy value.","tags":"","loc":"interface/energy_interface.html","title":"energy_interface – FLOw"},{"text":"abstract interface Abstract interfaces of deferred methods of primitive_object . private subroutine initialize_interface(self, initial_state) Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(inout) :: self Primitive. class( primitive_object ), intent(in), optional :: initial_state Initial state. Description Initialize primitive.","tags":"","loc":"interface/initialize_interface~2.html","title":"initialize_interface – FLOw"},{"text":"abstract interface Abstract interfaces of deferred methods of primitive_object . private elemental function momentum_interface(self) result(momentum_) Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: self Primitive. Return Value type(vector) Momentum vector. Description Return momentum vector.","tags":"","loc":"interface/momentum_interface.html","title":"momentum_interface – FLOw"},{"text":"public elemental function conservative_to_primitive_compressible(conservative, eos) result(primitive_) Return a primitive_compressible state transforming a given conservative_compressible state. Arguments Type Intent Optional Attributes Name type( conservative_compressible ), intent(in) :: conservative Conservative state. class( eos_object ), intent(in) :: eos Equation of state. Return Value type( primitive_compressible ) Primitive state. Called By proc~~conservative_to_primitive_compressible~~CalledByGraph proc~conservative_to_primitive_compressible conservative_to_primitive_compressible program~flow_test_compressible_transformations flow_test_compressible_transformations program~flow_test_compressible_transformations->proc~conservative_to_primitive_compressible Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code conservative_to_primitive_compressible Source Code elemental function conservative_to_primitive_compressible ( conservative , eos ) result ( primitive_ ) !< Return a [[primitive_compressible]] state transforming a given [[conservative_compressible]] state. type ( conservative_compressible ), intent ( in ) :: conservative !< Conservative state. class ( eos_object ), intent ( in ) :: eos !< Equation of state. type ( primitive_compressible ) :: primitive_ !< Primitive state. primitive_ % density = conservative % density primitive_ % velocity = conservative % velocity () primitive_ % pressure = conservative % pressure ( eos = eos ) endfunction conservative_to_primitive_compressible","tags":"","loc":"proc/conservative_to_primitive_compressible.html","title":"conservative_to_primitive_compressible – FLOw"},{"text":"public elemental function primitive_to_conservative_compressible(primitive, eos) result(conservative_) Return a conservative_compressible state transforming a given primitive_compressible state. Arguments Type Intent Optional Attributes Name type( primitive_compressible ), intent(in) :: primitive Primitive state. class( eos_object ), intent(in) :: eos Equation of state. Return Value type( conservative_compressible ) Conservative state. Called By proc~~primitive_to_conservative_compressible~~CalledByGraph proc~primitive_to_conservative_compressible primitive_to_conservative_compressible program~flow_test_compressible_transformations flow_test_compressible_transformations program~flow_test_compressible_transformations->proc~primitive_to_conservative_compressible Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code primitive_to_conservative_compressible Source Code elemental function primitive_to_conservative_compressible ( primitive , eos ) result ( conservative_ ) !< Return a [[conservative_compressible]] state transforming a given [[primitive_compressible]] state. type ( primitive_compressible ), intent ( in ) :: primitive !< Primitive state. class ( eos_object ), intent ( in ) :: eos !< Equation of state. type ( conservative_compressible ) :: conservative_ !< Conservative state. conservative_ % density = primitive % density conservative_ % momentum = primitive % momentum () conservative_ % energy = primitive % energy ( eos = eos ) endfunction primitive_to_conservative_compressible","tags":"","loc":"proc/primitive_to_conservative_compressible.html","title":"primitive_to_conservative_compressible – FLOw"},{"text":"private elemental function add(lhs, rhs) result(opr) Operator + . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code add Source Code elemental function add ( lhs , rhs ) result ( opr ) !< Operator `+`. class ( conservative_compressible ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( conservative_compressible :: opr ) select type ( opr ) class is ( conservative_compressible ) select type ( rhs ) class is ( conservative_compressible ) opr % density = lhs % density + rhs % density opr % momentum = lhs % momentum + rhs % momentum opr % energy = lhs % energy + rhs % energy endselect endselect endfunction add","tags":"","loc":"proc/add.html","title":"add – FLOw"},{"text":"private pure function array(self) result(array_) Return serialized array of field. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: self Conservative. Return Value real(kind=R8P),\n  allocatable,(:) Serialized array of field. Source Code array Source Code pure function array ( self ) result ( array_ ) !< Return serialized array of field. class ( conservative_compressible ), intent ( in ) :: self !< Conservative. real ( R8P ), allocatable :: array_ (:) !< Serialized array of field. allocate ( array_ ( 1 : 5 )) array_ ( 1 ) = self % density array_ ( 2 ) = self % momentum % x array_ ( 3 ) = self % momentum % y array_ ( 4 ) = self % momentum % z array_ ( 5 ) = self % energy endfunction array","tags":"","loc":"proc/array.html","title":"array – FLOw"},{"text":"private pure function conservative_compressible_instance(density, velocity, pressure) result(instance) Return and instance of conservative_compressible . Note This procedure is used for overloading conservative_compressible name. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in), optional :: density Density field. type(vector), intent(in), optional :: velocity Velocity field. real(kind=R8P), intent(in), optional :: pressure Pressure field. Return Value type( conservative_compressible ) Instance of conservative_compressible . Called By proc~~conservative_compressible_instance~~CalledByGraph proc~conservative_compressible_instance conservative_compressible_instance interface~conservative_compressible conservative_compressible interface~conservative_compressible->proc~conservative_compressible_instance Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code conservative_compressible_instance Source Code pure function conservative_compressible_instance ( density , velocity , pressure ) result ( instance ) !< Return and instance of [[conservative_compressible]]. !< !< @note This procedure is used for overloading [[conservative_compressible]] name. real ( R8P ), intent ( in ), optional :: density !< Density field. type ( vector ), intent ( in ), optional :: velocity !< Velocity field. real ( R8P ), intent ( in ), optional :: pressure !< Pressure field. type ( conservative_compressible ) :: instance !< Instance of [[conservative_compressible]]. if ( present ( density )) instance % density = density if ( present ( velocity )) instance % momentum = velocity if ( present ( pressure )) instance % energy = pressure endfunction conservative_compressible_instance","tags":"","loc":"proc/conservative_compressible_instance.html","title":"conservative_compressible_instance – FLOw"},{"text":"public function conservative_compressible_pointer(to, error_message) result(pointer_) Return conservative_compressible pointer associated to conservative_object or its extensions until conservative_compressible included. Note A type-guard check is performed and error stop is raised if necessary. Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(in), target :: to Target of associate. character(len=*), intent(in), optional :: error_message Auxiliary error message. Return Value class( conservative_compressible ),\n  pointer Associated pointer. Source Code conservative_compressible_pointer Source Code function conservative_compressible_pointer ( to , error_message ) result ( pointer_ ) !< Return [[conservative_compressible]] pointer associated to [[conservative_object]] or its extensions until !< [[conservative_compressible]] included. !< !< @note A type-guard check is performed and error stop is raised if necessary. class ( conservative_object ), intent ( in ), target :: to !< Target of associate. character ( * ), intent ( in ), optional :: error_message !< Auxiliary error message. class ( conservative_compressible ), pointer :: pointer_ !< Associated pointer. select type ( to ) type is ( conservative_compressible ) pointer_ => to class default write ( stderr , '(A)' ) 'error: cast conservative_object to conservative_compressible failed!' if ( present ( error_message )) write ( stderr , '(A)' ) error_message stop endselect endfunction conservative_compressible_pointer","tags":"","loc":"proc/conservative_compressible_pointer.html","title":"conservative_compressible_pointer – FLOw"},{"text":"private pure function description(self, prefix) result(desc) Return a pretty-formatted object description. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: self Conservative. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. Calls proc~~description~~CallsGraph proc~description description interface~str str proc~description->interface~str proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_bol str_bol interface~str->proc~str_bol proc~str_a_i4p->proc~str_i4p proc~str_a_i8p->proc~str_i8p proc~compact_real_string compact_real_string proc~str_r8p->proc~compact_real_string proc~str_a_r4p->proc~str_r4p proc~str_a_i1p->proc~str_i1p proc~str_a_r8p->proc~str_r8p proc~str_a_i2p->proc~str_i2p proc~str_r4p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code description Source Code pure function description ( self , prefix ) result ( desc ) !< Return a pretty-formatted object description. class ( conservative_compressible ), intent ( in ) :: self !< Conservative. character ( * ), intent ( in ), optional :: prefix !< Prefixing string. character ( len = :), allocatable :: prefix_ !< Prefixing string, local variable. character ( len = :), allocatable :: desc !< Description. character ( len = 1 ), parameter :: NL = new_line ( 'a' ) !< New line character. prefix_ = '' ; if ( present ( prefix )) prefix_ = prefix desc = '' desc = desc // prefix_ // 'density  = ' // trim ( str ( n = self % density )) // NL desc = desc // prefix_ // 'momentum = ' // trim ( str ( n = [ self % momentum % x , self % momentum % y , self % momentum % z ])) // NL desc = desc // prefix_ // 'energy   = ' // trim ( str ( n = self % energy )) endfunction description","tags":"","loc":"proc/description.html","title":"description – FLOw"},{"text":"private elemental function div(lhs, rhs) result(opr) Operator / . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code div Source Code elemental function div ( lhs , rhs ) result ( opr ) !< Operator `/`. class ( conservative_compressible ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( conservative_compressible :: opr ) select type ( opr ) class is ( conservative_compressible ) select type ( rhs ) class is ( conservative_compressible ) opr % density = lhs % density / rhs % density opr % momentum = lhs % momentum / rhs % momentum opr % energy = lhs % energy / rhs % energy endselect endselect endfunction div","tags":"","loc":"proc/div.html","title":"div – FLOw"},{"text":"private elemental function div_integer(lhs, rhs) result(opr) Operator field / integer . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code div_integer Source Code elemental function div_integer ( lhs , rhs ) result ( opr ) !< Operator `field / integer`. class ( conservative_compressible ), intent ( in ) :: lhs !< Left hand side. integer ( I4P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( conservative_compressible :: opr ) select type ( opr ) class is ( conservative_compressible ) opr % density = lhs % density / rhs opr % momentum = lhs % momentum / rhs opr % energy = lhs % energy / rhs endselect endfunction div_integer","tags":"","loc":"proc/div_integer.html","title":"div_integer – FLOw"},{"text":"private elemental function div_real(lhs, rhs) result(opr) Operator field / real . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code div_real Source Code elemental function div_real ( lhs , rhs ) result ( opr ) !< Operator `field / real`. class ( conservative_compressible ), intent ( in ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( conservative_compressible :: opr ) select type ( opr ) class is ( conservative_compressible ) opr % density = lhs % density / rhs opr % momentum = lhs % momentum / rhs opr % energy = lhs % energy / rhs endselect endfunction div_real","tags":"","loc":"proc/div_real.html","title":"div_real – FLOw"},{"text":"private elemental function eq(lhs, rhs) result(opr) Operator `=='. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. Source Code eq Source Code elemental function eq ( lhs , rhs ) result ( opr ) !< Operator `=='. class ( conservative_compressible ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. logical :: opr !< Operator result. select type ( rhs ) class is ( conservative_compressible ) opr = lhs % density == rhs % density if ( opr ) opr = lhs % momentum == rhs % momentum if ( opr ) opr = lhs % energy == rhs % energy endselect endfunction eq","tags":"","loc":"proc/eq.html","title":"eq – FLOw"},{"text":"private elemental function integer_mul(lhs, rhs) result(opr) Operator integer * field . Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: lhs Left hand side. class( conservative_compressible ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code integer_mul Source Code elemental function integer_mul ( lhs , rhs ) result ( opr ) !< Operator `integer * field`. integer ( I4P ), intent ( in ) :: lhs !< Left hand side. class ( conservative_compressible ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( conservative_compressible :: opr ) select type ( opr ) class is ( conservative_compressible ) opr % density = lhs * rhs % density opr % momentum = lhs * rhs % momentum opr % energy = lhs * rhs % energy endselect endfunction integer_mul","tags":"","loc":"proc/integer_mul.html","title":"integer_mul – FLOw"},{"text":"private elemental function mul(lhs, rhs) result(opr) Operator * . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code mul Source Code elemental function mul ( lhs , rhs ) result ( opr ) !< Operator `*`. class ( conservative_compressible ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( conservative_compressible :: opr ) select type ( opr ) class is ( conservative_compressible ) select type ( rhs ) class is ( conservative_compressible ) opr % density = lhs % density * rhs % density opr % momentum = lhs % momentum * rhs % momentum opr % energy = lhs % energy * rhs % energy endselect endselect endfunction mul","tags":"","loc":"proc/mul.html","title":"mul – FLOw"},{"text":"private elemental function mul_integer(lhs, rhs) result(opr) Operator field * integer . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code mul_integer Source Code elemental function mul_integer ( lhs , rhs ) result ( opr ) !< Operator `field * integer`. class ( conservative_compressible ), intent ( in ) :: lhs !< Left hand side. integer ( I4P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( conservative_compressible :: opr ) select type ( opr ) class is ( conservative_compressible ) opr % density = lhs % density * rhs opr % momentum = lhs % momentum * rhs opr % energy = lhs % energy * rhs endselect endfunction mul_integer","tags":"","loc":"proc/mul_integer.html","title":"mul_integer – FLOw"},{"text":"private elemental function mul_real(lhs, rhs) result(opr) Operator field * real . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code mul_real Source Code elemental function mul_real ( lhs , rhs ) result ( opr ) !< Operator `field * real`. class ( conservative_compressible ), intent ( in ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( conservative_compressible :: opr ) select type ( opr ) class is ( conservative_compressible ) opr % density = lhs % density * rhs opr % momentum = lhs % momentum * rhs opr % energy = lhs % energy * rhs endselect endfunction mul_real","tags":"","loc":"proc/mul_real.html","title":"mul_real – FLOw"},{"text":"private function negative(self) result(opr) Unary operator - field . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: self conservative. Return Value class( field_object ),\n  allocatable Operator result. Source Code negative Source Code function negative ( self ) result ( opr ) !< Unary operator `- field`. class ( conservative_compressible ), intent ( in ) :: self !< conservative. class ( field_object ), allocatable :: opr !< Operator result. allocate ( conservative_compressible :: opr ) select type ( opr ) class is ( conservative_compressible ) opr % density = - self % density opr % momentum = - self % momentum opr % energy = - self % energy endselect endfunction negative","tags":"","loc":"proc/negative.html","title":"negative – FLOw"},{"text":"private elemental function not_eq(lhs, rhs) result(opr) Operator `/='. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. Source Code not_eq Source Code elemental function not_eq ( lhs , rhs ) result ( opr ) !< Operator `/='. class ( conservative_compressible ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. logical :: opr !< Operator result. opr = . not .( lhs % eq ( rhs = rhs )) endfunction not_eq","tags":"","loc":"proc/not_eq.html","title":"not_eq – FLOw"},{"text":"private function positive(self) result(opr) Unary operator + field . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: self conservative. Return Value class( field_object ),\n  allocatable Operator result. Source Code positive Source Code function positive ( self ) result ( opr ) !< Unary operator `+ field`. class ( conservative_compressible ), intent ( in ) :: self !< conservative. class ( field_object ), allocatable :: opr !< Operator result. allocate ( conservative_compressible :: opr ) select type ( opr ) class is ( conservative_compressible ) opr % density = + self % density opr % momentum = + self % momentum opr % energy = + self % energy endselect endfunction positive","tags":"","loc":"proc/positive.html","title":"positive – FLOw"},{"text":"private elemental function pow_integer(lhs, rhs) result(opr) Operator field ** integer . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code pow_integer Source Code elemental function pow_integer ( lhs , rhs ) result ( opr ) !< Operator `field ** integer`. class ( conservative_compressible ), intent ( in ) :: lhs !< Left hand side. integer ( I4P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( conservative_compressible :: opr ) select type ( opr ) class is ( conservative_compressible ) opr % density = lhs % density ** rhs opr % momentum % x = lhs % momentum % x ** rhs opr % momentum % y = lhs % momentum % y ** rhs opr % momentum % z = lhs % momentum % z ** rhs opr % energy = lhs % energy ** rhs endselect endfunction pow_integer","tags":"","loc":"proc/pow_integer.html","title":"pow_integer – FLOw"},{"text":"private elemental function pow_real(lhs, rhs) result(opr) Operator field ** real . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code pow_real Source Code elemental function pow_real ( lhs , rhs ) result ( opr ) !< Operator `field ** real`. class ( conservative_compressible ), intent ( in ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( conservative_compressible :: opr ) select type ( opr ) class is ( conservative_compressible ) opr % density = lhs % density ** rhs opr % momentum % x = lhs % momentum % x ** rhs opr % momentum % y = lhs % momentum % y ** rhs opr % momentum % z = lhs % momentum % z ** rhs opr % energy = lhs % energy ** rhs endselect endfunction pow_real","tags":"","loc":"proc/pow_real.html","title":"pow_real – FLOw"},{"text":"private elemental function pressure(self, eos) result(pressure_) Return pressure value. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: self Conservative. class( eos_object ), intent(in) :: eos Equation of state. Return Value real(kind=R8P) Pressure value. Source Code pressure Source Code elemental function pressure ( self , eos ) result ( pressure_ ) !< Return pressure value. class ( conservative_compressible ), intent ( in ) :: self !< Conservative. class ( eos_object ), intent ( in ) :: eos !< Equation of state. real ( R8P ) :: pressure_ !< Pressure value. type ( vector ) :: velocity_ !< Velocity vector. velocity_ = self % velocity () pressure_ = ( eos % g () - 1._R8P ) * ( self % energy - 0.5_R8P * self % density * velocity_ % sq_norm ()) endfunction pressure","tags":"","loc":"proc/pressure.html","title":"pressure – FLOw"},{"text":"private elemental function real_mul(lhs, rhs) result(opr) Operator real * field . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs Left hand side. class( conservative_compressible ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code real_mul Source Code elemental function real_mul ( lhs , rhs ) result ( opr ) !< Operator `real * field`. real ( R8P ), intent ( in ) :: lhs !< Left hand side. class ( conservative_compressible ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( conservative_compressible :: opr ) select type ( opr ) class is ( conservative_compressible ) opr % density = lhs * rhs % density opr % momentum = lhs * rhs % momentum opr % energy = lhs * rhs % energy endselect endfunction real_mul","tags":"","loc":"proc/real_mul.html","title":"real_mul – FLOw"},{"text":"private elemental function sub(lhs, rhs) result(opr) Operator - . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code sub Source Code elemental function sub ( lhs , rhs ) result ( opr ) !< Operator `-`. class ( conservative_compressible ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( conservative_compressible :: opr ) select type ( opr ) class is ( conservative_compressible ) select type ( rhs ) class is ( conservative_compressible ) opr % density = lhs % density - rhs % density opr % momentum = lhs % momentum - rhs % momentum opr % energy = lhs % energy - rhs % energy endselect endselect endfunction sub","tags":"","loc":"proc/sub.html","title":"sub – FLOw"},{"text":"private elemental function velocity(self) result(velocity_) Return velocity vector. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: self Conservative. Return Value type(vector) Velocity vector. Source Code velocity Source Code elemental function velocity ( self ) result ( velocity_ ) !< Return velocity vector. class ( conservative_compressible ), intent ( in ) :: self !< Conservative. type ( vector ) :: velocity_ !< Velocity vector. velocity_ = self % momentum / self % density endfunction velocity","tags":"","loc":"proc/velocity.html","title":"velocity – FLOw"},{"text":"private elemental subroutine assign_field(lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(inout) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Source Code assign_field Source Code elemental subroutine assign_field ( lhs , rhs ) !< Operator `=`. class ( conservative_compressible ), intent ( inout ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. select type ( rhs ) class is ( conservative_compressible ) lhs % density = rhs % density lhs % momentum = rhs % momentum lhs % energy = rhs % energy endselect endsubroutine assign_field","tags":"","loc":"proc/assign_field.html","title":"assign_field – FLOw"},{"text":"private elemental subroutine assign_real(lhs, rhs) Operator field = real . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(inout) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Source Code assign_real Source Code elemental subroutine assign_real ( lhs , rhs ) !< Operator `field = real`. class ( conservative_compressible ), intent ( inout ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. lhs % density = rhs lhs % momentum = rhs lhs % energy = rhs endsubroutine assign_real","tags":"","loc":"proc/assign_real.html","title":"assign_real – FLOw"},{"text":"private subroutine compute_fluxes(self, eos, normal, fluxes) Compute conservative fluxes. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: self Conservative. class( eos_object ), intent(in) :: eos Equation of state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(out) :: fluxes Conservative fluxes. Source Code compute_fluxes Source Code subroutine compute_fluxes ( self , eos , normal , fluxes ) !< Compute conservative fluxes. class ( conservative_compressible ), intent ( in ) :: self !< Conservative. class ( eos_object ), intent ( in ) :: eos !< Equation of state. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. class ( conservative_object ), intent ( out ) :: fluxes !< Conservative fluxes. real ( R8P ) :: pressure_ !< Pressure value. type ( vector ) :: velocity_ !< Velocity vector. real ( R8P ) :: velocity_normal_ !< Velocity component parallel to given normal. select type ( fluxes ) class is ( conservative_compressible ) pressure_ = self % pressure ( eos = eos ) velocity_ = self % velocity () velocity_normal_ = velocity_ . dot . normal fluxes % density = self % momentum . dot . normal fluxes % momentum = self % density * velocity_ * velocity_normal_ + pressure_ * normal fluxes % energy = ( self % energy + pressure_ ) * velocity_normal_ endselect endsubroutine compute_fluxes","tags":"","loc":"proc/compute_fluxes.html","title":"compute_fluxes – FLOw"},{"text":"private elemental subroutine compute_fluxes_from_primitive(self, eos, p, r, u, normal) Compute conservative fluxes from primitives at interface. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(inout) :: self Conservative. class( eos_object ), intent(in) :: eos Equation of state. real(kind=R8P), intent(in) :: p Pressure at interface. real(kind=R8P), intent(in) :: r Density at interface. real(kind=R8P), intent(in) :: u Velocity (normal component) at interface. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. Source Code compute_fluxes_from_primitive Source Code elemental subroutine compute_fluxes_from_primitive ( self , eos , p , r , u , normal ) !< Compute conservative fluxes from primitives at interface. class ( conservative_compressible ), intent ( inout ) :: self !< Conservative. class ( eos_object ), intent ( in ) :: eos !< Equation of state. real ( R8P ), intent ( in ) :: p !< Pressure at interface. real ( R8P ), intent ( in ) :: r !< Density at interface. real ( R8P ), intent ( in ) :: u !< Velocity (normal component) at interface. type ( vector ), intent ( in ) :: normal !< Normal (versor) of face where fluxes are given. self % density = r * u self % momentum = ( r * u * u + p ) * normal self % energy = ( r * eos % internal_energy ( density = r , pressure = p ) + r * u * u * 0.5_R8P + p ) * u endsubroutine compute_fluxes_from_primitive","tags":"","loc":"proc/compute_fluxes_from_primitive.html","title":"compute_fluxes_from_primitive – FLOw"},{"text":"private elemental subroutine destroy(self) Destroy conservative. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(inout) :: self Conservative. Source Code destroy Source Code elemental subroutine destroy ( self ) !< Destroy conservative. class ( conservative_compressible ), intent ( inout ) :: self !< Conservative. type ( conservative_compressible ) :: fresh !< Fresh instance of conservative object. self = fresh endsubroutine destroy","tags":"","loc":"proc/destroy.html","title":"destroy – FLOw"},{"text":"private subroutine initialize(self, initial_state) Initialize conservative. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(inout) :: self conservative. class( conservative_object ), intent(in), optional :: initial_state Initial state. Source Code initialize Source Code subroutine initialize ( self , initial_state ) !< Initialize conservative. class ( conservative_compressible ), intent ( inout ) :: self !< conservative. class ( conservative_object ), intent ( in ), optional :: initial_state !< Initial state. call self % destroy if ( present ( initial_state )) then select type ( initial_state ) class is ( conservative_compressible ) self = initial_state endselect endif endsubroutine initialize","tags":"","loc":"proc/initialize.html","title":"initialize – FLOw"},{"text":"public interface conservative_compressible Overload conservative_compressible name with its constructor. Calls interface~~conservative_compressible~~CallsGraph interface~conservative_compressible conservative_compressible proc~conservative_compressible_instance conservative_compressible_instance interface~conservative_compressible->proc~conservative_compressible_instance Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures conservative_compressible_instance Module Procedures private pure function conservative_compressible_instance (density, velocity, pressure) result(instance) Return and instance of conservative_compressible . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in), optional :: density Density field. type(vector), intent(in), optional :: velocity Velocity field. real(kind=R8P), intent(in), optional :: pressure Pressure field. Return Value type( conservative_compressible ) Instance of conservative_compressible .","tags":"","loc":"interface/conservative_compressible.html","title":"conservative_compressible – FLOw"},{"text":"private elemental function R(self) result(R_) Return fluid constant R=cp-cv . Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. Return Value real(kind=R8P) Fluid constant value. Source Code R Source Code elemental function R ( self ) result ( R_ ) !< Return fluid constant `R=cp-cv`. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ) :: R_ !< Fluid constant value. R_ = self % R_ endfunction R","tags":"","loc":"proc/r.html","title":"R – FLOw"},{"text":"private elemental function cp(self) result(cp_) Return specific heat at constant pressure. Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. Return Value real(kind=R8P) cp value. Source Code cp Source Code elemental function cp ( self ) result ( cp_ ) !< Return specific heat at constant pressure. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ) :: cp_ !< `cp` value. cp_ = self % cp_ endfunction cp","tags":"","loc":"proc/cp.html","title":"cp – FLOw"},{"text":"private elemental function cv(self) result(cv_) Return specific heat at constant volume. Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. Return Value real(kind=R8P) cv value. Source Code cv Source Code elemental function cv ( self ) result ( cv_ ) !< Return specific heat at constant volume. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ) :: cv_ !< `cv` value. cv_ = self % cv_ endfunction cv","tags":"","loc":"proc/cv.html","title":"cv – FLOw"},{"text":"private elemental function delta(self) result(delta_) Return (gamma - 1) / 2 . Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. Return Value real(kind=R8P) (gamma - 1) / 2 value. Source Code delta Source Code elemental function delta ( self ) result ( delta_ ) !< Return `(gamma - 1) / 2`. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ) :: delta_ !< `(gamma - 1) / 2` value. delta_ = self % delta_ endfunction delta","tags":"","loc":"proc/delta.html","title":"delta – FLOw"},{"text":"private elemental function density(self, pressure, speed_of_sound) result(density_) Return density. Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. real(kind=R8P), intent(in) :: pressure Pressure value. real(kind=R8P), intent(in) :: speed_of_sound Speed of sound value. Return Value real(kind=R8P) Density value. Source Code density Source Code elemental function density ( self , pressure , speed_of_sound ) result ( density_ ) !< Return density. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ), intent ( in ) :: pressure !< Pressure value. real ( R8P ), intent ( in ) :: speed_of_sound !< Speed of sound value. real ( R8P ) :: density_ !< Density value. density_ = self % g_ * pressure / ( speed_of_sound * speed_of_sound ) endfunction density","tags":"","loc":"proc/density.html","title":"density – FLOw"},{"text":"private pure function description(self, prefix) result(desc) Return a pretty-formatted object description. Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. Calls proc~~description~2~~CallsGraph proc~description~2 description interface~str str proc~description~2->interface~str proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_bol str_bol interface~str->proc~str_bol proc~str_a_i4p->proc~str_i4p proc~str_a_i8p->proc~str_i8p proc~compact_real_string compact_real_string proc~str_r8p->proc~compact_real_string proc~str_a_r4p->proc~str_r4p proc~str_a_i1p->proc~str_i1p proc~str_a_r8p->proc~str_r8p proc~str_a_i2p->proc~str_i2p proc~str_r4p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code description Source Code pure function description ( self , prefix ) result ( desc ) !< Return a pretty-formatted object description. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. character ( * ), intent ( in ), optional :: prefix !< Prefixing string. character ( len = :), allocatable :: desc !< Description. character ( len = :), allocatable :: prefix_ !< Prefixing string, local variable. character ( len = 1 ), parameter :: NL = new_line ( 'a' ) !< New line character. prefix_ = '' ; if ( present ( prefix )) prefix_ = prefix desc = '' desc = desc // prefix_ // 'cp  = ' // trim ( str ( n = self % cp_ )) // NL desc = desc // prefix_ // 'cv  = ' // trim ( str ( n = self % cv_ )) endfunction description","tags":"","loc":"proc/description~2.html","title":"description – FLOw"},{"text":"private elemental function eos_compressible_instance(cp, cv, gam, R) result(instance) Return and instance of eos_compressible . Note This procedure is used for overloading eos_compressible name. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in), optional :: cp Specific heat at constant pressure cp value. real(kind=R8P), intent(in), optional :: cv Specific heat at constant volume cv value. real(kind=R8P), intent(in), optional :: gam Specific heats ratio gamma=cp/cv value. real(kind=R8P), intent(in), optional :: R Fluid constant R=cp-cv value. Return Value type( eos_compressible ) Instance of eos_compressible . Called By proc~~eos_compressible_instance~~CalledByGraph proc~eos_compressible_instance eos_compressible_instance interface~eos_compressible eos_compressible interface~eos_compressible->proc~eos_compressible_instance Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code eos_compressible_instance Source Code elemental function eos_compressible_instance ( cp , cv , gam , R ) result ( instance ) !< Return and instance of [[eos_compressible]]. !< !< @note This procedure is used for overloading [[eos_compressible]] name. real ( R8P ), intent ( in ), optional :: cp !< Specific heat at constant pressure `cp` value. real ( R8P ), intent ( in ), optional :: cv !< Specific heat at constant volume `cv` value. real ( R8P ), intent ( in ), optional :: gam !< Specific heats ratio `gamma=cp/cv` value. real ( R8P ), intent ( in ), optional :: R !< Fluid constant `R=cp-cv` value. type ( eos_compressible ) :: instance !< Instance of [[eos_compressible]]. if ( present ( cp ). and . present ( cv )) then instance % cp_ = cp instance % cv_ = cv elseif ( present ( gam ). and . present ( R )) then instance % cv_ = R / ( gam - 1._R8P ) instance % cp_ = gam * instance % cv_ elseif ( present ( gam ). and . present ( cp )) then instance % cp_ = cp instance % cv_ = cp / gam elseif ( present ( gam ). and . present ( cv )) then instance % cp_ = gam * cv instance % cv_ = cv elseif ( present ( R ). and . present ( cp )) then instance % cp_ = cp instance % cv_ = cp - R elseif ( present ( R ). and . present ( cv )) then instance % cp_ = cv + R instance % cv_ = cv endif call instance % compute_derivate endfunction eos_compressible_instance","tags":"","loc":"proc/eos_compressible_instance.html","title":"eos_compressible_instance – FLOw"},{"text":"private elemental function eta(self) result(eta_) Return 2 * gamma / (gamma - 1) . Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. Return Value real(kind=R8P) 2 * gamma / (gamma - 1) value. Source Code eta Source Code elemental function eta ( self ) result ( eta_ ) !< Return `2 * gamma / (gamma - 1)`. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ) :: eta_ !< `2 * gamma / (gamma - 1)` value. eta_ = self % eta_ endfunction eta","tags":"","loc":"proc/eta.html","title":"eta – FLOw"},{"text":"private elemental function g(self) result(g_) Return specific heats ratio gamma=cp/cv . Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. Return Value real(kind=R8P) Specific heats ratio value. Source Code g Source Code elemental function g ( self ) result ( g_ ) !< Return specific heats ratio `gamma=cp/cv`. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ) :: g_ !< Specific heats ratio value. g_ = self % g_ endfunction g","tags":"","loc":"proc/g.html","title":"g – FLOw"},{"text":"private elemental function gm1(self) result(gm1_) Return gamma - 1 . Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. Return Value real(kind=R8P) gamma - 1 value. Source Code gm1 Source Code elemental function gm1 ( self ) result ( gm1_ ) !< Return `gamma - 1`. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ) :: gm1_ !< `gamma - 1` value. gm1_ = self % gm1_ endfunction gm1","tags":"","loc":"proc/gm1.html","title":"gm1 – FLOw"},{"text":"private elemental function gp1(self) result(gp1_) Return gamma + 1 . Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. Return Value real(kind=R8P) gamma + 1 value. Source Code gp1 Source Code elemental function gp1 ( self ) result ( gp1_ ) !< Return `gamma + 1`. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ) :: gp1_ !< `gamma + 1` value. gp1_ = self % gp1_ endfunction gp1","tags":"","loc":"proc/gp1.html","title":"gp1 – FLOw"},{"text":"private elemental function internal_energy(self, density, pressure, temperature) result(energy_) Return specific internal energy. Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. real(kind=R8P), intent(in), optional :: density Density value. real(kind=R8P), intent(in), optional :: pressure Pressure value. real(kind=R8P), intent(in), optional :: temperature Temperature value. Return Value real(kind=R8P) Energy value. Source Code internal_energy Source Code elemental function internal_energy ( self , density , pressure , temperature ) result ( energy_ ) !< Return specific internal energy. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ), intent ( in ), optional :: density !< Density value. real ( R8P ), intent ( in ), optional :: pressure !< Pressure value. real ( R8P ), intent ( in ), optional :: temperature !< Temperature value. real ( R8P ) :: energy_ !< Energy value. energy_ = 0._R8P if ( present ( density ). and . present ( pressure )) then energy_ = pressure / (( self % g_ - 1._R8P ) * density ) elseif ( present ( temperature )) then energy_ = self % cv () * temperature endif endfunction internal_energy","tags":"","loc":"proc/internal_energy.html","title":"internal_energy – FLOw"},{"text":"private elemental function pressure(self, density, energy, temperature) result(pressure_) Return pressure. Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. real(kind=R8P), intent(in), optional :: density Density value. real(kind=R8P), intent(in), optional :: energy Specific internal energy value. real(kind=R8P), intent(in), optional :: temperature Temperature value. Return Value real(kind=R8P) Pressure value. Source Code pressure Source Code elemental function density ( self , pressure , speed_of_sound ) result ( density_ ) !< Return density. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ), intent ( in ) :: pressure !< Pressure value. real ( R8P ), intent ( in ) :: speed_of_sound !< Speed of sound value. real ( R8P ) :: density_ !< Density value. density_ = self % g_ * pressure / ( speed_of_sound * speed_of_sound ) endfunction density pure function description ( self , prefix ) result ( desc ) !< Return a pretty-formatted object description. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. character ( * ), intent ( in ), optional :: prefix !< Prefixing string. character ( len = :), allocatable :: desc !< Description. character ( len = :), allocatable :: prefix_ !< Prefixing string, local variable. character ( len = 1 ), parameter :: NL = new_line ( 'a' ) !< New line character. prefix_ = '' ; if ( present ( prefix )) prefix_ = prefix desc = '' desc = desc // prefix_ // 'cp  = ' // trim ( str ( n = self % cp_ )) // NL desc = desc // prefix_ // 'cv  = ' // trim ( str ( n = self % cv_ )) endfunction description elemental function eta ( self ) result ( eta_ ) !< Return `2 * gamma / (gamma - 1)`. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ) :: eta_ !< `2 * gamma / (gamma - 1)` value. eta_ = self % eta_ endfunction eta elemental function g ( self ) result ( g_ ) !< Return specific heats ratio `gamma=cp/cv`. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ) :: g_ !< Specific heats ratio value. g_ = self % g_ endfunction g elemental function gm1 ( self ) result ( gm1_ ) !< Return `gamma - 1`. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ) :: gm1_ !< `gamma - 1` value. gm1_ = self % gm1_ endfunction gm1 elemental function gp1 ( self ) result ( gp1_ ) !< Return `gamma + 1`. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ) :: gp1_ !< `gamma + 1` value. gp1_ = self % gp1_ endfunction gp1 elemental function internal_energy ( self , density , pressure , temperature ) result ( energy_ ) !< Return specific internal energy. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ), intent ( in ), optional :: density !< Density value. real ( R8P ), intent ( in ), optional :: pressure !< Pressure value. real ( R8P ), intent ( in ), optional :: temperature !< Temperature value. real ( R8P ) :: energy_ !< Energy value. energy_ = 0._R8P if ( present ( density ). and . present ( pressure )) then energy_ = pressure / (( self % g_ - 1._R8P ) * density ) elseif ( present ( temperature )) then energy_ = self % cv () * temperature endif endfunction internal_energy elemental function pressure ( self , density , energy , temperature ) result ( pressure_ ) !< Return pressure. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ), intent ( in ), optional :: density !< Density value. real ( R8P ), intent ( in ), optional :: energy !< Specific internal energy value. real ( R8P ), intent ( in ), optional :: temperature !< Temperature value. real ( R8P ) :: pressure_ !< Pressure value. pressure_ = 0._R8P if ( present ( density ). and . present ( energy )) then pressure_ = density * ( self % g_ - 1._R8P ) * energy elseif ( present ( density ). and . present ( temperature )) then pressure_ = density * self % R_ * temperature endif endfunction pressure","tags":"","loc":"proc/pressure~2.html","title":"pressure – FLOw"},{"text":"private elemental function speed_of_sound(self, density, pressure) result(speed_of_sound_) Return speed of sound. Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. real(kind=R8P), intent(in) :: density Density value. real(kind=R8P), intent(in) :: pressure Pressure value. Return Value real(kind=R8P) Speed of sound value. Source Code speed_of_sound Source Code elemental function speed_of_sound ( self , density , pressure ) result ( speed_of_sound_ ) !< Return speed of sound. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ), intent ( in ) :: density !< Density value. real ( R8P ), intent ( in ) :: pressure !< Pressure value. real ( R8P ) :: speed_of_sound_ !< Speed of sound value. speed_of_sound_ = sqrt ( self % g_ * pressure / density ) endfunction speed_of_sound","tags":"","loc":"proc/speed_of_sound.html","title":"speed_of_sound – FLOw"},{"text":"private elemental function temperature(self, density, energy, pressure) result(temperature_) Return temperature. Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. real(kind=R8P), intent(in), optional :: density Density value. real(kind=R8P), intent(in), optional :: energy Specific internal energy value. real(kind=R8P), intent(in), optional :: pressure Pressure value. Return Value real(kind=R8P) Temperature value. Source Code temperature Source Code elemental function temperature ( self , density , energy , pressure ) result ( temperature_ ) !< Return temperature. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ), intent ( in ), optional :: density !< Density value. real ( R8P ), intent ( in ), optional :: energy !< Specific internal energy value. real ( R8P ), intent ( in ), optional :: pressure !< Pressure value. real ( R8P ) :: temperature_ !< Temperature value. temperature_ = 0._R8P if ( present ( density ). and . present ( pressure )) then temperature_ = pressure / ( self % R_ * density ) elseif ( present ( energy )) then temperature_ = energy / self % cv () endif endfunction temperature","tags":"","loc":"proc/temperature.html","title":"temperature – FLOw"},{"text":"private elemental function total_entalpy(self, density, pressure, velocity_sq_norm) result(entalpy_) Return total specific entalpy. Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. real(kind=R8P), intent(in) :: density Density value. real(kind=R8P), intent(in) :: pressure Pressure value. real(kind=R8P), intent(in) :: velocity_sq_norm Velocity vector square norm ||velocity||&#94;2 . Return Value real(kind=R8P) Total specific entalpy (per unit of mass). Source Code total_entalpy Source Code elemental function total_entalpy ( self , density , pressure , velocity_sq_norm ) result ( entalpy_ ) !< Return total specific entalpy. class ( eos_compressible ), intent ( in ) :: self !< Equation of state. real ( R8P ), intent ( in ) :: density !< Density value. real ( R8P ), intent ( in ) :: pressure !< Pressure value. real ( R8P ), intent ( in ) :: velocity_sq_norm !< Velocity vector square norm `||velocity||&#94;2`. real ( R8P ) :: entalpy_ !< Total specific entalpy (per unit of mass). entalpy_ = self % g_ * pressure / ( self % gm1_ * density ) + 0.5_R8P * velocity_sq_norm endfunction total_entalpy","tags":"","loc":"proc/total_entalpy.html","title":"total_entalpy – FLOw"},{"text":"private elemental subroutine compute_derivate(self) Compute derivate quantities (from cp and cv ). Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(inout) :: self Equation of state. Source Code compute_derivate Source Code elemental subroutine compute_derivate ( self ) !< Compute derivate quantities (from `cp` and `cv`). class ( eos_compressible ), intent ( inout ) :: self !< Equation of state. self % g_ = self % cp_ / self % cv_ self % R_ = self % cp_ - self % cv_ self % gm1_ = self % g_ - 1._R8P self % gp1_ = self % g_ + 1._R8P self % delta_ = ( self % g_ - 1._R8P ) * 0.5_R8P self % eta_ = 2._R8P * self % g_ / ( self % g_ - 1._R8P ) endsubroutine compute_derivate","tags":"","loc":"proc/compute_derivate.html","title":"compute_derivate – FLOw"},{"text":"private pure subroutine eos_assign_eos(lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(inout) :: lhs Left hand side. class( eos_object ), intent(in) :: rhs Right hand side. Source Code eos_assign_eos Source Code pure subroutine eos_assign_eos ( lhs , rhs ) !< Operator `=`. class ( eos_compressible ), intent ( inout ) :: lhs !< Left hand side. class ( eos_object ), intent ( in ) :: rhs !< Right hand side. select type ( rhs ) class is ( eos_compressible ) lhs % cp_ = rhs % cp_ lhs % cv_ = rhs % cv_ lhs % g_ = rhs % g_ lhs % R_ = rhs % R_ lhs % delta_ = rhs % delta_ lhs % eta_ = rhs % eta_ lhs % gm1_ = rhs % gm1_ lhs % gp1_ = rhs % gp1_ endselect endsubroutine eos_assign_eos","tags":"","loc":"proc/eos_assign_eos.html","title":"eos_assign_eos – FLOw"},{"text":"public interface eos_compressible Overload eos_compressible name with its constructor. Calls interface~~eos_compressible~~CallsGraph interface~eos_compressible eos_compressible proc~eos_compressible_instance eos_compressible_instance interface~eos_compressible->proc~eos_compressible_instance Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures eos_compressible_instance Module Procedures private elemental function eos_compressible_instance (cp, cv, gam, R) result(instance) Return and instance of eos_compressible . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in), optional :: cp Specific heat at constant pressure cp value. real(kind=R8P), intent(in), optional :: cv Specific heat at constant volume cv value. real(kind=R8P), intent(in), optional :: gam Specific heats ratio gamma=cp/cv value. real(kind=R8P), intent(in), optional :: R Fluid constant R=cp-cv value. Return Value type( eos_compressible ) Instance of eos_compressible .","tags":"","loc":"interface/eos_compressible.html","title":"eos_compressible – FLOw"},{"text":"private pure function array_scalar(self) result(array_) Return serialized array of field. Arguments Type Intent Optional Attributes Name class( field_scalar ), intent(in) :: self Field. Return Value real(kind=R8P),\n  allocatable,(:) Serialized array of field. Source Code array_scalar Source Code pure function array_scalar ( self ) result ( array_ ) !< Return serialized array of field. class ( field_scalar ), intent ( in ) :: self !< Field. real ( R8P ), allocatable :: array_ (:) !< Serialized array of field. allocate ( array_ ( 1 : 1 )) array_ ( 1 ) = self % field endfunction array_scalar","tags":"","loc":"proc/array_scalar.html","title":"array_scalar – FLOw"},{"text":"private pure function array_vectorial(self) result(array_) Return serialized array of field. Arguments Type Intent Optional Attributes Name class( field_vectorial ), intent(in) :: self Field. Return Value real(kind=R8P),\n  allocatable,(:) Serialized array of field. Source Code array_vectorial Source Code pure function array_vectorial ( self ) result ( array_ ) !< Return serialized array of field. class ( field_vectorial ), intent ( in ) :: self !< Field. real ( R8P ), allocatable :: array_ (:) !< Serialized array of field. allocate ( array_ ( 1 : 3 )) array_ ( 1 ) = self % field % x array_ ( 2 ) = self % field % y array_ ( 3 ) = self % field % z endfunction array_vectorial","tags":"","loc":"proc/array_vectorial.html","title":"array_vectorial – FLOw"},{"text":"private pure function description_scalar(self, prefix) result(desc) Return a pretty-formatted object description. Arguments Type Intent Optional Attributes Name class( field_scalar ), intent(in) :: self Primitive. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. Calls proc~~description_scalar~~CallsGraph proc~description_scalar description_scalar interface~str str proc~description_scalar->interface~str proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_bol str_bol interface~str->proc~str_bol proc~str_a_i4p->proc~str_i4p proc~str_a_i8p->proc~str_i8p proc~compact_real_string compact_real_string proc~str_r8p->proc~compact_real_string proc~str_a_r4p->proc~str_r4p proc~str_a_i1p->proc~str_i1p proc~str_a_r8p->proc~str_r8p proc~str_a_i2p->proc~str_i2p proc~str_r4p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code description_scalar Source Code pure function description_scalar ( self , prefix ) result ( desc ) !< Return a pretty-formatted object description. class ( field_scalar ), intent ( in ) :: self !< Primitive. character ( * ), intent ( in ), optional :: prefix !< Prefixing string. character ( len = :), allocatable :: prefix_ !< Prefixing string, local variable. character ( len = :), allocatable :: desc !< Description. prefix_ = '' ; if ( present ( prefix )) prefix_ = prefix desc = prefix_ // 'field  = ' // trim ( str ( n = self % field )) endfunction description_scalar","tags":"","loc":"proc/description_scalar.html","title":"description_scalar – FLOw"},{"text":"private pure function description_vectorial(self, prefix) result(desc) Return a pretty-formatted object description. Arguments Type Intent Optional Attributes Name class( field_vectorial ), intent(in) :: self Primitive. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. Calls proc~~description_vectorial~~CallsGraph proc~description_vectorial description_vectorial interface~str str proc~description_vectorial->interface~str proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_bol str_bol interface~str->proc~str_bol proc~str_a_i4p->proc~str_i4p proc~str_a_i8p->proc~str_i8p proc~compact_real_string compact_real_string proc~str_r8p->proc~compact_real_string proc~str_a_r4p->proc~str_r4p proc~str_a_i1p->proc~str_i1p proc~str_a_r8p->proc~str_r8p proc~str_a_i2p->proc~str_i2p proc~str_r4p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code description_vectorial Source Code pure function description_vectorial ( self , prefix ) result ( desc ) !< Return a pretty-formatted object description. class ( field_vectorial ), intent ( in ) :: self !< Primitive. character ( * ), intent ( in ), optional :: prefix !< Prefixing string. character ( len = :), allocatable :: prefix_ !< Prefixing string, local variable. character ( len = :), allocatable :: desc !< Description. prefix_ = '' ; if ( present ( prefix )) prefix_ = prefix desc = prefix_ // 'field  = ' // trim ( str ( n = [ self % field % x , self % field % y , self % field % z ])) endfunction description_vectorial","tags":"","loc":"proc/description_vectorial.html","title":"description_vectorial – FLOw"},{"text":"private elemental function eq_scalar(lhs, rhs) result(opr) Operator `=='. Arguments Type Intent Optional Attributes Name class( field_scalar ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. Source Code eq_scalar Source Code elemental function eq_scalar ( lhs , rhs ) result ( opr ) !< Operator `=='. class ( field_scalar ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. logical :: opr !< Operator result. opr = . false . select type ( rhs ) class is ( field_scalar ) opr = lhs % field == rhs % field endselect endfunction eq_scalar","tags":"","loc":"proc/eq_scalar.html","title":"eq_scalar – FLOw"},{"text":"private elemental function eq_vectorial(lhs, rhs) result(opr) Operator `=='. Arguments Type Intent Optional Attributes Name class( field_vectorial ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. Source Code eq_vectorial Source Code elemental function eq_vectorial ( lhs , rhs ) result ( opr ) !< Operator `=='. class ( field_vectorial ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. logical :: opr !< Operator result. opr = . false . select type ( rhs ) class is ( field_vectorial ) opr = lhs % field == rhs % field endselect endfunction eq_vectorial","tags":"","loc":"proc/eq_vectorial.html","title":"eq_vectorial – FLOw"},{"text":"private elemental function integer_mul_scalar(lhs, rhs) result(opr) Operator integer * field . Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: lhs Left hand side. class( field_scalar ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code integer_mul_scalar Source Code elemental function integer_mul_scalar ( lhs , rhs ) result ( opr ) !< Operator `integer * field`. integer ( I4P ), intent ( in ) :: lhs !< Left hand side. class ( field_scalar ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_scalar :: opr ) select type ( opr ) class is ( field_scalar ) opr % field = lhs * rhs % field endselect endfunction integer_mul_scalar","tags":"","loc":"proc/integer_mul_scalar.html","title":"integer_mul_scalar – FLOw"},{"text":"private elemental function integer_mul_vectorial(lhs, rhs) result(opr) Operator integer * field . Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: lhs Left hand side. class( field_vectorial ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code integer_mul_vectorial Source Code elemental function integer_mul_vectorial ( lhs , rhs ) result ( opr ) !< Operator `integer * field`. integer ( I4P ), intent ( in ) :: lhs !< Left hand side. class ( field_vectorial ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_vectorial :: opr ) select type ( opr ) class is ( field_vectorial ) opr % field = lhs * rhs % field endselect endfunction integer_mul_vectorial","tags":"","loc":"proc/integer_mul_vectorial.html","title":"integer_mul_vectorial – FLOw"},{"text":"private function negative_scalar(self) result(opr) Unary operator - field . Arguments Type Intent Optional Attributes Name class( field_scalar ), intent(in) :: self Primitive. Return Value class( field_object ),\n  allocatable Operator result. Source Code negative_scalar Source Code function negative_scalar ( self ) result ( opr ) !< Unary operator `- field`. class ( field_scalar ), intent ( in ) :: self !< Primitive. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_scalar :: opr ) select type ( opr ) class is ( field_scalar ) opr % field = - self % field endselect endfunction negative_scalar","tags":"","loc":"proc/negative_scalar.html","title":"negative_scalar – FLOw"},{"text":"private function negative_vectorial(self) result(opr) Unary operator + field . Arguments Type Intent Optional Attributes Name class( field_vectorial ), intent(in) :: self Primitive. Return Value class( field_object ),\n  allocatable Operator result. Source Code negative_vectorial Source Code function negative_vectorial ( self ) result ( opr ) !< Unary operator `+ field`. class ( field_vectorial ), intent ( in ) :: self !< Primitive. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_vectorial :: opr ) select type ( opr ) class is ( field_vectorial ) opr % field = - self % field endselect endfunction negative_vectorial","tags":"","loc":"proc/negative_vectorial.html","title":"negative_vectorial – FLOw"},{"text":"private elemental function not_eq_scalar(lhs, rhs) result(opr) Operator `/='. Arguments Type Intent Optional Attributes Name class( field_scalar ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. Source Code not_eq_scalar Source Code elemental function not_eq_scalar ( lhs , rhs ) result ( opr ) !< Operator `/='. class ( field_scalar ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. logical :: opr !< Operator result. opr = . false . select type ( rhs ) class is ( field_scalar ) opr = lhs % field /= rhs % field endselect endfunction not_eq_scalar","tags":"","loc":"proc/not_eq_scalar.html","title":"not_eq_scalar – FLOw"},{"text":"private elemental function not_eq_vectorial(lhs, rhs) result(opr) Operator `/='. Arguments Type Intent Optional Attributes Name class( field_vectorial ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. Source Code not_eq_vectorial Source Code elemental function not_eq_vectorial ( lhs , rhs ) result ( opr ) !< Operator `/='. class ( field_vectorial ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. logical :: opr !< Operator result. opr = . false . select type ( rhs ) class is ( field_vectorial ) opr = lhs % field /= rhs % field endselect endfunction not_eq_vectorial","tags":"","loc":"proc/not_eq_vectorial.html","title":"not_eq_vectorial – FLOw"},{"text":"private function positive_scalar(self) result(opr) Unary operator + field . Arguments Type Intent Optional Attributes Name class( field_scalar ), intent(in) :: self Primitive. Return Value class( field_object ),\n  allocatable Operator result. Source Code positive_scalar Source Code function positive_scalar ( self ) result ( opr ) !< Unary operator `+ field`. class ( field_scalar ), intent ( in ) :: self !< Primitive. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_scalar :: opr ) select type ( opr ) class is ( field_scalar ) opr % field = + self % field endselect endfunction positive_scalar","tags":"","loc":"proc/positive_scalar.html","title":"positive_scalar – FLOw"},{"text":"private function positive_vectorial(self) result(opr) Unary operator + field . Arguments Type Intent Optional Attributes Name class( field_vectorial ), intent(in) :: self Primitive. Return Value class( field_object ),\n  allocatable Operator result. Source Code positive_vectorial Source Code function positive_vectorial ( self ) result ( opr ) !< Unary operator `+ field`. class ( field_vectorial ), intent ( in ) :: self !< Primitive. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_vectorial :: opr ) select type ( opr ) class is ( field_vectorial ) opr % field = + self % field endselect endfunction positive_vectorial","tags":"","loc":"proc/positive_vectorial.html","title":"positive_vectorial – FLOw"},{"text":"private elemental function real_mul_scalar(lhs, rhs) result(opr) Operator real * field . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs Left hand side. class( field_scalar ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code real_mul_scalar Source Code elemental function real_mul_scalar ( lhs , rhs ) result ( opr ) !< Operator `real * field`. real ( R8P ), intent ( in ) :: lhs !< Left hand side. class ( field_scalar ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_scalar :: opr ) select type ( opr ) class is ( field_scalar ) opr % field = lhs * rhs % field endselect endfunction real_mul_scalar","tags":"","loc":"proc/real_mul_scalar.html","title":"real_mul_scalar – FLOw"},{"text":"private elemental function real_mul_vectorial(lhs, rhs) result(opr) Operator real * field . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs Left hand side. class( field_vectorial ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code real_mul_vectorial Source Code elemental function real_mul_vectorial ( lhs , rhs ) result ( opr ) !< Operator `real * field`. real ( R8P ), intent ( in ) :: lhs !< Left hand side. class ( field_vectorial ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_vectorial :: opr ) select type ( opr ) class is ( field_vectorial ) opr % field = lhs * rhs % field endselect endfunction real_mul_vectorial","tags":"","loc":"proc/real_mul_vectorial.html","title":"real_mul_vectorial – FLOw"},{"text":"private elemental function scalar_add_scalar(lhs, rhs) result(opr) Operator + . Arguments Type Intent Optional Attributes Name class( field_scalar ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code scalar_add_scalar Source Code elemental function scalar_add_scalar ( lhs , rhs ) result ( opr ) !< Operator `+`. class ( field_scalar ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_scalar :: opr ) select type ( opr ) class is ( field_scalar ) select type ( rhs ) class is ( field_scalar ) opr % field = lhs % field + rhs % field endselect endselect endfunction scalar_add_scalar","tags":"","loc":"proc/scalar_add_scalar.html","title":"scalar_add_scalar – FLOw"},{"text":"private elemental function scalar_div_integer(lhs, rhs) result(opr) Operator field / integer . Arguments Type Intent Optional Attributes Name class( field_scalar ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code scalar_div_integer Source Code elemental function scalar_div_integer ( lhs , rhs ) result ( opr ) !< Operator `field / integer`. class ( field_scalar ), intent ( in ) :: lhs !< Left hand side. integer ( I4P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_scalar :: opr ) select type ( opr ) class is ( field_scalar ) opr % field = lhs % field / rhs endselect endfunction scalar_div_integer","tags":"","loc":"proc/scalar_div_integer.html","title":"scalar_div_integer – FLOw"},{"text":"private elemental function scalar_div_real(lhs, rhs) result(opr) Operator field / real . Arguments Type Intent Optional Attributes Name class( field_scalar ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code scalar_div_real Source Code elemental function scalar_div_real ( lhs , rhs ) result ( opr ) !< Operator `field / real`. class ( field_scalar ), intent ( in ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_scalar :: opr ) select type ( opr ) class is ( field_scalar ) opr % field = lhs % field / rhs endselect endfunction scalar_div_real","tags":"","loc":"proc/scalar_div_real.html","title":"scalar_div_real – FLOw"},{"text":"private elemental function scalar_div_scalar(lhs, rhs) result(opr) Operator / . Arguments Type Intent Optional Attributes Name class( field_scalar ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code scalar_div_scalar Source Code elemental function scalar_div_scalar ( lhs , rhs ) result ( opr ) !< Operator `/`. class ( field_scalar ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_scalar :: opr ) select type ( opr ) class is ( field_scalar ) select type ( rhs ) class is ( field_scalar ) opr % field = lhs % field / rhs % field endselect endselect endfunction scalar_div_scalar","tags":"","loc":"proc/scalar_div_scalar.html","title":"scalar_div_scalar – FLOw"},{"text":"private elemental function scalar_mul_integer(lhs, rhs) result(opr) Operator field * integer . Arguments Type Intent Optional Attributes Name class( field_scalar ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code scalar_mul_integer Source Code elemental function scalar_mul_integer ( lhs , rhs ) result ( opr ) !< Operator `field * integer`. class ( field_scalar ), intent ( in ) :: lhs !< Left hand side. integer ( I4P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_scalar :: opr ) select type ( opr ) class is ( field_scalar ) opr % field = lhs % field * rhs endselect endfunction scalar_mul_integer","tags":"","loc":"proc/scalar_mul_integer.html","title":"scalar_mul_integer – FLOw"},{"text":"private elemental function scalar_mul_object(lhs, rhs) result(opr) Operator * . Note The combinations accepted are:\n+ field_scalar * field_vectorial => field_vectorial + field_scalar * field_scalar    => field_scalar Arguments Type Intent Optional Attributes Name class( field_scalar ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code scalar_mul_object Source Code elemental function scalar_mul_object ( lhs , rhs ) result ( opr ) !< Operator `*`. !< !< @note The combinations accepted are: !<+ `field_scalar * field_vectorial => field_vectorial` !<+ `field_scalar * field_scalar    => field_scalar` class ( field_scalar ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. select type ( rhs ) type is ( field_vectorial ) allocate ( field_vectorial :: opr ) select type ( opr ) class is ( field_vectorial ) opr % field = lhs % field * rhs % field endselect class is ( field_scalar ) allocate ( field_scalar :: opr ) select type ( opr ) class is ( field_scalar ) opr % field = lhs % field * rhs % field endselect endselect endfunction scalar_mul_object","tags":"","loc":"proc/scalar_mul_object.html","title":"scalar_mul_object – FLOw"},{"text":"private elemental function scalar_mul_real(lhs, rhs) result(opr) Operator field * real . Arguments Type Intent Optional Attributes Name class( field_scalar ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code scalar_mul_real Source Code elemental function scalar_mul_real ( lhs , rhs ) result ( opr ) !< Operator `field * real`. class ( field_scalar ), intent ( in ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_scalar :: opr ) select type ( opr ) class is ( field_scalar ) opr % field = lhs % field * rhs endselect endfunction scalar_mul_real","tags":"","loc":"proc/scalar_mul_real.html","title":"scalar_mul_real – FLOw"},{"text":"private elemental function scalar_pow_integer(lhs, rhs) result(opr) Operator field ** integer . Arguments Type Intent Optional Attributes Name class( field_scalar ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code scalar_pow_integer Source Code elemental function scalar_pow_integer ( lhs , rhs ) result ( opr ) !< Operator `field ** integer`. class ( field_scalar ), intent ( in ) :: lhs !< Left hand side. integer ( I4P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_scalar :: opr ) select type ( opr ) class is ( field_scalar ) opr % field = lhs % field ** rhs endselect endfunction scalar_pow_integer","tags":"","loc":"proc/scalar_pow_integer.html","title":"scalar_pow_integer – FLOw"},{"text":"private elemental function scalar_pow_real(lhs, rhs) result(opr) Operator field ** real . Arguments Type Intent Optional Attributes Name class( field_scalar ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code scalar_pow_real Source Code elemental function scalar_pow_real ( lhs , rhs ) result ( opr ) !< Operator `field ** real`. class ( field_scalar ), intent ( in ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_scalar :: opr ) select type ( opr ) class is ( field_scalar ) opr % field = lhs % field ** rhs endselect endfunction scalar_pow_real","tags":"","loc":"proc/scalar_pow_real.html","title":"scalar_pow_real – FLOw"},{"text":"private elemental function scalar_sub_scalar(lhs, rhs) result(opr) Operator - . Arguments Type Intent Optional Attributes Name class( field_scalar ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code scalar_sub_scalar Source Code elemental function scalar_sub_scalar ( lhs , rhs ) result ( opr ) !< Operator `-`. class ( field_scalar ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_scalar :: opr ) select type ( opr ) class is ( field_scalar ) select type ( rhs ) class is ( field_scalar ) opr % field = lhs % field - rhs % field endselect endselect endfunction scalar_sub_scalar","tags":"","loc":"proc/scalar_sub_scalar.html","title":"scalar_sub_scalar – FLOw"},{"text":"private elemental function vectorial_add_vectorial(lhs, rhs) result(opr) Operator + . Arguments Type Intent Optional Attributes Name class( field_vectorial ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code vectorial_add_vectorial Source Code elemental function vectorial_add_vectorial ( lhs , rhs ) result ( opr ) !< Operator `+`. class ( field_vectorial ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_vectorial :: opr ) select type ( opr ) class is ( field_vectorial ) select type ( rhs ) class is ( field_vectorial ) opr % field = lhs % field + rhs % field endselect endselect endfunction vectorial_add_vectorial","tags":"","loc":"proc/vectorial_add_vectorial.html","title":"vectorial_add_vectorial – FLOw"},{"text":"private elemental function vectorial_div_integer(lhs, rhs) result(opr) Operator field / integer . Arguments Type Intent Optional Attributes Name class( field_vectorial ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code vectorial_div_integer Source Code elemental function vectorial_div_integer ( lhs , rhs ) result ( opr ) !< Operator `field / integer`. class ( field_vectorial ), intent ( in ) :: lhs !< Left hand side. integer ( I4P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_vectorial :: opr ) select type ( opr ) class is ( field_vectorial ) opr % field = lhs % field / rhs endselect endfunction vectorial_div_integer","tags":"","loc":"proc/vectorial_div_integer.html","title":"vectorial_div_integer – FLOw"},{"text":"private elemental function vectorial_div_object(lhs, rhs) result(opr) Operator / . Note The combinations accepted are:\n+ field_vectorial / field_vectorial => field_vectorial + field_vectorial / field_scalar    => field_vectorial Arguments Type Intent Optional Attributes Name class( field_vectorial ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code vectorial_div_object Source Code elemental function vectorial_div_object ( lhs , rhs ) result ( opr ) !< Operator `/`. !< !< @note The combinations accepted are: !<+ `field_vectorial / field_vectorial => field_vectorial` !<+ `field_vectorial / field_scalar    => field_vectorial` class ( field_vectorial ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_vectorial :: opr ) select type ( opr ) class is ( field_vectorial ) select type ( rhs ) class is ( field_vectorial ) opr % field = lhs % field / rhs % field class is ( field_scalar ) opr % field = lhs % field / rhs % field endselect endselect endfunction vectorial_div_object","tags":"","loc":"proc/vectorial_div_object.html","title":"vectorial_div_object – FLOw"},{"text":"private elemental function vectorial_div_real(lhs, rhs) result(opr) Operator field / real . Arguments Type Intent Optional Attributes Name class( field_vectorial ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code vectorial_div_real Source Code elemental function vectorial_div_real ( lhs , rhs ) result ( opr ) !< Operator `field / real`. class ( field_vectorial ), intent ( in ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_vectorial :: opr ) select type ( opr ) class is ( field_vectorial ) opr % field = lhs % field / rhs endselect endfunction vectorial_div_real","tags":"","loc":"proc/vectorial_div_real.html","title":"vectorial_div_real – FLOw"},{"text":"private elemental function vectorial_mul_integer(lhs, rhs) result(opr) Operator field * integer . Arguments Type Intent Optional Attributes Name class( field_vectorial ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code vectorial_mul_integer Source Code elemental function vectorial_mul_integer ( lhs , rhs ) result ( opr ) !< Operator `field * integer`. class ( field_vectorial ), intent ( in ) :: lhs !< Left hand side. integer ( I4P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_vectorial :: opr ) select type ( opr ) class is ( field_vectorial ) opr % field = lhs % field * rhs endselect endfunction vectorial_mul_integer","tags":"","loc":"proc/vectorial_mul_integer.html","title":"vectorial_mul_integer – FLOw"},{"text":"private elemental function vectorial_mul_object(lhs, rhs) result(opr) Operator * . Note The combinations accepted are:\n+ field_vectorial * field_vectorial => field_vectorial + field_vectorial * field_scalar    => field_vectorial Arguments Type Intent Optional Attributes Name class( field_vectorial ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code vectorial_mul_object Source Code elemental function vectorial_mul_object ( lhs , rhs ) result ( opr ) !< Operator `*`. !< !< @note The combinations accepted are: !<+ `field_vectorial * field_vectorial => field_vectorial` !<+ `field_vectorial * field_scalar    => field_vectorial` class ( field_vectorial ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_vectorial :: opr ) select type ( opr ) class is ( field_vectorial ) select type ( rhs ) class is ( field_vectorial ) opr % field = lhs % field * rhs % field class is ( field_scalar ) opr % field = lhs % field * rhs % field endselect endselect endfunction vectorial_mul_object","tags":"","loc":"proc/vectorial_mul_object.html","title":"vectorial_mul_object – FLOw"},{"text":"private elemental function vectorial_mul_real(lhs, rhs) result(opr) Operator field * real . Arguments Type Intent Optional Attributes Name class( field_vectorial ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code vectorial_mul_real Source Code elemental function vectorial_mul_real ( lhs , rhs ) result ( opr ) !< Operator `field * real`. class ( field_vectorial ), intent ( in ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_vectorial :: opr ) select type ( opr ) class is ( field_vectorial ) opr % field = lhs % field * rhs endselect endfunction vectorial_mul_real","tags":"","loc":"proc/vectorial_mul_real.html","title":"vectorial_mul_real – FLOw"},{"text":"private elemental function vectorial_pow_integer(lhs, rhs) result(opr) Operator field ** integer . Arguments Type Intent Optional Attributes Name class( field_vectorial ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code vectorial_pow_integer Source Code elemental function vectorial_pow_integer ( lhs , rhs ) result ( opr ) !< Operator `field ** integer`. class ( field_vectorial ), intent ( in ) :: lhs !< Left hand side. integer ( I4P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_vectorial :: opr ) select type ( opr ) class is ( field_vectorial ) opr % field % x = lhs % field % x ** rhs opr % field % y = lhs % field % y ** rhs opr % field % z = lhs % field % z ** rhs endselect endfunction vectorial_pow_integer","tags":"","loc":"proc/vectorial_pow_integer.html","title":"vectorial_pow_integer – FLOw"},{"text":"private elemental function vectorial_pow_real(lhs, rhs) result(opr) Operator field ** real . Arguments Type Intent Optional Attributes Name class( field_vectorial ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code vectorial_pow_real Source Code elemental function vectorial_pow_real ( lhs , rhs ) result ( opr ) !< Operator `field ** real`. class ( field_vectorial ), intent ( in ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_vectorial :: opr ) select type ( opr ) class is ( field_vectorial ) opr % field % x = lhs % field % x ** rhs opr % field % y = lhs % field % y ** rhs opr % field % z = lhs % field % z ** rhs endselect endfunction vectorial_pow_real","tags":"","loc":"proc/vectorial_pow_real.html","title":"vectorial_pow_real – FLOw"},{"text":"private elemental function vectorial_sub_vectorial(lhs, rhs) result(opr) Operator - . Arguments Type Intent Optional Attributes Name class( field_vectorial ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code vectorial_sub_vectorial Source Code elemental function vectorial_sub_vectorial ( lhs , rhs ) result ( opr ) !< Operator `-`. class ( field_vectorial ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( field_vectorial :: opr ) select type ( opr ) class is ( field_vectorial ) select type ( rhs ) class is ( field_vectorial ) opr % field = lhs % field - rhs % field endselect endselect endfunction vectorial_sub_vectorial","tags":"","loc":"proc/vectorial_sub_vectorial.html","title":"vectorial_sub_vectorial – FLOw"},{"text":"private elemental subroutine assign_field_scalar(lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( field_scalar ), intent(inout) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Source Code assign_field_scalar Source Code elemental subroutine assign_field_scalar ( lhs , rhs ) !< Operator `=`. class ( field_scalar ), intent ( inout ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. select type ( rhs ) class is ( field_scalar ) lhs % field = rhs % field endselect endsubroutine assign_field_scalar","tags":"","loc":"proc/assign_field_scalar.html","title":"assign_field_scalar – FLOw"},{"text":"private elemental subroutine assign_field_vectorial(lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( field_vectorial ), intent(inout) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Source Code assign_field_vectorial Source Code elemental subroutine assign_field_vectorial ( lhs , rhs ) !< Operator `=`. class ( field_vectorial ), intent ( inout ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. select type ( rhs ) class is ( field_vectorial ) lhs % field = rhs % field endselect endsubroutine assign_field_vectorial","tags":"","loc":"proc/assign_field_vectorial.html","title":"assign_field_vectorial – FLOw"},{"text":"private elemental subroutine assign_real_scalar(lhs, rhs) Operator field = real . Arguments Type Intent Optional Attributes Name class( field_scalar ), intent(inout) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Source Code assign_real_scalar Source Code elemental subroutine assign_real_scalar ( lhs , rhs ) !< Operator `field = real`. class ( field_scalar ), intent ( inout ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. lhs % field = rhs endsubroutine assign_real_scalar","tags":"","loc":"proc/assign_real_scalar.html","title":"assign_real_scalar – FLOw"},{"text":"private elemental subroutine assign_real_vectorial(lhs, rhs) Operator field = real . Arguments Type Intent Optional Attributes Name class( field_vectorial ), intent(inout) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Source Code assign_real_vectorial Source Code elemental subroutine assign_real_vectorial ( lhs , rhs ) !< Operator `field = real`. class ( field_vectorial ), intent ( inout ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. lhs % field = rhs endsubroutine assign_real_vectorial","tags":"","loc":"proc/assign_real_vectorial.html","title":"assign_real_vectorial – FLOw"},{"text":"private elemental function add(lhs, rhs) result(opr) Operator + . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code add Source Code elemental function add ( lhs , rhs ) result ( opr ) !< Operator `+`. class ( primitive_compressible ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( primitive_compressible :: opr ) select type ( opr ) class is ( primitive_compressible ) select type ( rhs ) class is ( primitive_compressible ) opr % density = lhs % density + rhs % density opr % velocity = lhs % velocity + rhs % velocity opr % pressure = lhs % pressure + rhs % pressure endselect endselect endfunction add","tags":"","loc":"proc/add~2.html","title":"add – FLOw"},{"text":"private pure function array(self) result(array_) Return serialized array of field. Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. Return Value real(kind=R8P),\n  allocatable,(:) Serialized array of field. Source Code array Source Code pure function array ( self ) result ( array_ ) !< Return serialized array of field. class ( primitive_compressible ), intent ( in ) :: self !< Primitive. real ( R8P ), allocatable :: array_ (:) !< Serialized array of field. allocate ( array_ ( 1 : 5 )) array_ ( 1 ) = self % density array_ ( 2 ) = self % velocity % x array_ ( 3 ) = self % velocity % y array_ ( 4 ) = self % velocity % z array_ ( 5 ) = self % pressure endfunction array","tags":"","loc":"proc/array~2.html","title":"array – FLOw"},{"text":"private pure function description(self, prefix) result(desc) Return a pretty-formatted object description. Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. Calls proc~~description~3~~CallsGraph proc~description~3 description interface~str str proc~description~3->interface~str proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_bol str_bol interface~str->proc~str_bol proc~str_a_i4p->proc~str_i4p proc~str_a_i8p->proc~str_i8p proc~compact_real_string compact_real_string proc~str_r8p->proc~compact_real_string proc~str_a_r4p->proc~str_r4p proc~str_a_i1p->proc~str_i1p proc~str_a_r8p->proc~str_r8p proc~str_a_i2p->proc~str_i2p proc~str_r4p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code description Source Code pure function description ( self , prefix ) result ( desc ) !< Return a pretty-formatted object description. class ( primitive_compressible ), intent ( in ) :: self !< Primitive. character ( * ), intent ( in ), optional :: prefix !< Prefixing string. character ( len = :), allocatable :: prefix_ !< Prefixing string, local variable. character ( len = :), allocatable :: desc !< Description. character ( len = 1 ), parameter :: NL = new_line ( 'a' ) !< New line character. prefix_ = '' ; if ( present ( prefix )) prefix_ = prefix desc = '' desc = desc // prefix_ // 'density  = ' // trim ( str ( n = self % density )) // NL desc = desc // prefix_ // 'velocity = ' // trim ( str ( n = [ self % velocity % x , self % velocity % y , self % velocity % z ])) // NL desc = desc // prefix_ // 'pressure = ' // trim ( str ( n = self % pressure )) endfunction description","tags":"","loc":"proc/description~3.html","title":"description – FLOw"},{"text":"private elemental function div(lhs, rhs) result(opr) Operator / . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code div Source Code elemental function div ( lhs , rhs ) result ( opr ) !< Operator `/`. class ( primitive_compressible ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( primitive_compressible :: opr ) select type ( opr ) class is ( primitive_compressible ) select type ( rhs ) class is ( primitive_compressible ) opr % density = lhs % density / rhs % density opr % velocity = lhs % velocity / rhs % velocity opr % pressure = lhs % pressure / rhs % pressure endselect endselect endfunction div","tags":"","loc":"proc/div~2.html","title":"div – FLOw"},{"text":"private elemental function div_integer(lhs, rhs) result(opr) Operator field / integer . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code div_integer Source Code elemental function div_integer ( lhs , rhs ) result ( opr ) !< Operator `field / integer`. class ( primitive_compressible ), intent ( in ) :: lhs !< Left hand side. integer ( I4P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( primitive_compressible :: opr ) select type ( opr ) class is ( primitive_compressible ) opr % density = lhs % density / rhs opr % velocity = lhs % velocity / rhs opr % pressure = lhs % pressure / rhs endselect endfunction div_integer","tags":"","loc":"proc/div_integer~2.html","title":"div_integer – FLOw"},{"text":"private elemental function div_real(lhs, rhs) result(opr) Operator field / real . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code div_real Source Code elemental function div_real ( lhs , rhs ) result ( opr ) !< Operator `field / real`. class ( primitive_compressible ), intent ( in ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( primitive_compressible :: opr ) select type ( opr ) class is ( primitive_compressible ) opr % density = lhs % density / rhs opr % velocity = lhs % velocity / rhs opr % pressure = lhs % pressure / rhs endselect endfunction div_real","tags":"","loc":"proc/div_real~2.html","title":"div_real – FLOw"},{"text":"private elemental function energy(self, eos) result(energy_) Return energy value. Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. class( eos_object ), intent(in) :: eos Equation of state. Return Value real(kind=R8P) Energy value. Source Code energy Source Code elemental function energy ( self , eos ) result ( energy_ ) !< Return energy value. class ( primitive_compressible ), intent ( in ) :: self !< Primitive. class ( eos_object ), intent ( in ) :: eos !< Equation of state. real ( R8P ) :: energy_ !< Energy value. energy_ = self % pressure / ( eos % g () - 1._R8P ) + 0.5_R8P * self % density * self % velocity % sq_norm () endfunction energy","tags":"","loc":"proc/energy.html","title":"energy – FLOw"},{"text":"private elemental function eq(lhs, rhs) result(opr) Operator `=='. Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. Source Code eq Source Code elemental function eq ( lhs , rhs ) result ( opr ) !< Operator `=='. class ( primitive_compressible ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. logical :: opr !< Operator result. select type ( rhs ) class is ( primitive_compressible ) opr = lhs % density == rhs % density if ( opr ) opr = lhs % velocity == rhs % velocity if ( opr ) opr = lhs % pressure == rhs % pressure endselect endfunction eq","tags":"","loc":"proc/eq~2.html","title":"eq – FLOw"},{"text":"private elemental function integer_mul(lhs, rhs) result(opr) Operator integer * field . Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: lhs Left hand side. class( primitive_compressible ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code integer_mul Source Code elemental function integer_mul ( lhs , rhs ) result ( opr ) !< Operator `integer * field`. integer ( I4P ), intent ( in ) :: lhs !< Left hand side. class ( primitive_compressible ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( primitive_compressible :: opr ) select type ( opr ) class is ( primitive_compressible ) opr % density = lhs * rhs % density opr % velocity = lhs * rhs % velocity opr % pressure = lhs * rhs % pressure endselect endfunction integer_mul","tags":"","loc":"proc/integer_mul~2.html","title":"integer_mul – FLOw"},{"text":"private pure function left_eigenvectors(self, eos) result(eig) Return the left eigenvectors matrix L as dF/dP = A = R &#94; L . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. class( eos_object ), intent(in) :: eos Equation of state. Return Value real(kind=R8P)\n  (1:3,1:3) Eigenvectors. Source Code left_eigenvectors Source Code pure function left_eigenvectors ( self , eos ) result ( eig ) !< Return the left eigenvectors matrix `L` as `dF/dP = A = R &#94; L`. class ( primitive_compressible ), intent ( in ) :: self !< Primitive. class ( eos_object ), intent ( in ) :: eos !< Equation of state. real ( R8P ) :: eig ( 1 : 3 , 1 : 3 ) !< Eigenvectors. real ( R8P ) :: gp !< `g*p`. real ( R8P ) :: gp_a !< `g*p/a`. gp = eos % g () * self % pressure gp_a = gp / eos % speed_of_sound ( density = self % density , pressure = self % pressure ) eig ( 1 , 1 ) = 0._R8P ; eig ( 1 , 2 ) = - gp_a ; eig ( 1 , 3 ) = 1._R8P eig ( 2 , 1 ) = gp / self % density ; eig ( 2 , 2 ) = 0._R8P ; eig ( 2 , 3 ) = - 1._R8P eig ( 3 , 1 ) = 0._R8P ; eig ( 3 , 2 ) = gp_a ; eig ( 3 , 3 ) = 1._R8P endfunction left_eigenvectors","tags":"","loc":"proc/left_eigenvectors.html","title":"left_eigenvectors – FLOw"},{"text":"private elemental function momentum(self) result(momentum_) Return momentum vector. Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. Return Value type(vector) Momentum vector. Source Code momentum Source Code elemental function momentum ( self ) result ( momentum_ ) !< Return momentum vector. class ( primitive_compressible ), intent ( in ) :: self !< Primitive. type ( vector ) :: momentum_ !< Momentum vector. momentum_ = self % density * self % velocity endfunction momentum","tags":"","loc":"proc/momentum.html","title":"momentum – FLOw"},{"text":"private elemental function mul(lhs, rhs) result(opr) Operator * . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code mul Source Code elemental function mul ( lhs , rhs ) result ( opr ) !< Operator `*`. class ( primitive_compressible ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( primitive_compressible :: opr ) select type ( opr ) class is ( primitive_compressible ) select type ( rhs ) class is ( primitive_compressible ) opr % density = lhs % density * rhs % density opr % velocity = lhs % velocity * rhs % velocity opr % pressure = lhs % pressure * rhs % pressure endselect endselect endfunction mul","tags":"","loc":"proc/mul~2.html","title":"mul – FLOw"},{"text":"private elemental function mul_integer(lhs, rhs) result(opr) Operator field * integer . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code mul_integer Source Code elemental function mul_integer ( lhs , rhs ) result ( opr ) !< Operator `field * integer`. class ( primitive_compressible ), intent ( in ) :: lhs !< Left hand side. integer ( I4P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( primitive_compressible :: opr ) select type ( opr ) class is ( primitive_compressible ) opr % density = lhs % density * rhs opr % velocity = lhs % velocity * rhs opr % pressure = lhs % pressure * rhs endselect endfunction mul_integer","tags":"","loc":"proc/mul_integer~2.html","title":"mul_integer – FLOw"},{"text":"private elemental function mul_real(lhs, rhs) result(opr) Operator field * real . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code mul_real Source Code elemental function mul_real ( lhs , rhs ) result ( opr ) !< Operator `field * real`. class ( primitive_compressible ), intent ( in ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( primitive_compressible :: opr ) select type ( opr ) class is ( primitive_compressible ) opr % density = lhs % density * rhs opr % velocity = lhs % velocity * rhs opr % pressure = lhs % pressure * rhs endselect endfunction mul_real","tags":"","loc":"proc/mul_real~2.html","title":"mul_real – FLOw"},{"text":"private function negative(self) result(opr) Unary operator - field . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. Return Value class( field_object ),\n  allocatable Operator result. Source Code negative Source Code function negative ( self ) result ( opr ) !< Unary operator `- field`. class ( primitive_compressible ), intent ( in ) :: self !< Primitive. class ( field_object ), allocatable :: opr !< Operator result. allocate ( primitive_compressible :: opr ) select type ( opr ) class is ( primitive_compressible ) opr % density = - self % density opr % velocity = - self % velocity opr % pressure = - self % pressure endselect endfunction negative","tags":"","loc":"proc/negative~2.html","title":"negative – FLOw"},{"text":"private elemental function not_eq(lhs, rhs) result(opr) Operator `/='. Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. Source Code not_eq Source Code elemental function not_eq ( lhs , rhs ) result ( opr ) !< Operator `/='. class ( primitive_compressible ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. logical :: opr !< Operator result. opr = . not .( lhs % eq ( rhs = rhs )) endfunction not_eq","tags":"","loc":"proc/not_eq~2.html","title":"not_eq – FLOw"},{"text":"private function positive(self) result(opr) Unary operator + field . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. Return Value class( field_object ),\n  allocatable Operator result. Source Code positive Source Code function positive ( self ) result ( opr ) !< Unary operator `+ field`. class ( primitive_compressible ), intent ( in ) :: self !< Primitive. class ( field_object ), allocatable :: opr !< Operator result. allocate ( primitive_compressible :: opr ) select type ( opr ) class is ( primitive_compressible ) opr % density = + self % density opr % velocity = + self % velocity opr % pressure = + self % pressure endselect endfunction positive","tags":"","loc":"proc/positive~2.html","title":"positive – FLOw"},{"text":"private elemental function pow_integer(lhs, rhs) result(opr) Operator field ** integer . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code pow_integer Source Code elemental function pow_integer ( lhs , rhs ) result ( opr ) !< Operator `field ** integer`. class ( primitive_compressible ), intent ( in ) :: lhs !< Left hand side. integer ( I4P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( primitive_compressible :: opr ) select type ( opr ) class is ( primitive_compressible ) opr % density = lhs % density ** rhs opr % velocity % x = lhs % velocity % x ** rhs opr % velocity % y = lhs % velocity % y ** rhs opr % velocity % z = lhs % velocity % z ** rhs opr % pressure = lhs % pressure ** rhs endselect endfunction pow_integer","tags":"","loc":"proc/pow_integer~2.html","title":"pow_integer – FLOw"},{"text":"private elemental function pow_real(lhs, rhs) result(opr) Operator field ** real . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code pow_real Source Code elemental function pow_real ( lhs , rhs ) result ( opr ) !< Operator `field ** real`. class ( primitive_compressible ), intent ( in ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( primitive_compressible :: opr ) select type ( opr ) class is ( primitive_compressible ) opr % density = lhs % density ** rhs opr % velocity % x = lhs % velocity % x ** rhs opr % velocity % y = lhs % velocity % y ** rhs opr % velocity % z = lhs % velocity % z ** rhs opr % pressure = lhs % pressure ** rhs endselect endfunction pow_real","tags":"","loc":"proc/pow_real~2.html","title":"pow_real – FLOw"},{"text":"private pure function primitive_compressible_instance(density, velocity, pressure) result(instance) Return and instance of primitive_compressible . Note This procedure is used for overloading primitive_compressible name. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in), optional :: density Density field. type(vector), intent(in), optional :: velocity Velocity field. real(kind=R8P), intent(in), optional :: pressure Pressure field. Return Value type( primitive_compressible ) Instance of primitive_compressible . Called By proc~~primitive_compressible_instance~~CalledByGraph proc~primitive_compressible_instance primitive_compressible_instance interface~primitive_compressible primitive_compressible interface~primitive_compressible->proc~primitive_compressible_instance Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code primitive_compressible_instance Source Code pure function primitive_compressible_instance ( density , velocity , pressure ) result ( instance ) !< Return and instance of [[primitive_compressible]]. !< !< @note This procedure is used for overloading [[primitive_compressible]] name. real ( R8P ), intent ( in ), optional :: density !< Density field. type ( vector ), intent ( in ), optional :: velocity !< Velocity field. real ( R8P ), intent ( in ), optional :: pressure !< Pressure field. type ( primitive_compressible ) :: instance !< Instance of [[primitive_compressible]]. if ( present ( density )) instance % density = density if ( present ( velocity )) instance % velocity = velocity if ( present ( pressure )) instance % pressure = pressure endfunction primitive_compressible_instance","tags":"","loc":"proc/primitive_compressible_instance.html","title":"primitive_compressible_instance – FLOw"},{"text":"public function primitive_compressible_pointer(to, error_message) result(pointer_) Return primitive_compressible pointer associated to primitive_object or its extensions until primitive_compressible included. Note A type-guard check is performed and error stop is raised if necessary. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in), target :: to Target of associate. character(len=*), intent(in), optional :: error_message Auxiliary error message. Return Value class( primitive_compressible ),\n  pointer Associated pointer. Source Code primitive_compressible_pointer Source Code function primitive_compressible_pointer ( to , error_message ) result ( pointer_ ) !< Return [[primitive_compressible]] pointer associated to [[primitive_object]] or its extensions until !< [[primitive_compressible]] included. !< !< @note A type-guard check is performed and error stop is raised if necessary. class ( primitive_object ), intent ( in ), target :: to !< Target of associate. character ( * ), intent ( in ), optional :: error_message !< Auxiliary error message. class ( primitive_compressible ), pointer :: pointer_ !< Associated pointer. select type ( to ) type is ( primitive_compressible ) pointer_ => to class default write ( stderr , '(A)' ) 'error: cast primitive_object to primitive_compressible failed!' if ( present ( error_message )) write ( stderr , '(A)' ) error_message stop endselect endfunction primitive_compressible_pointer","tags":"","loc":"proc/primitive_compressible_pointer.html","title":"primitive_compressible_pointer – FLOw"},{"text":"private elemental function real_mul(lhs, rhs) result(opr) Operator real * field . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs Left hand side. class( primitive_compressible ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code real_mul Source Code elemental function real_mul ( lhs , rhs ) result ( opr ) !< Operator `real * field`. real ( R8P ), intent ( in ) :: lhs !< Left hand side. class ( primitive_compressible ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( primitive_compressible :: opr ) select type ( opr ) class is ( primitive_compressible ) opr % density = lhs * rhs % density opr % velocity = lhs * rhs % velocity opr % pressure = lhs * rhs % pressure endselect endfunction real_mul","tags":"","loc":"proc/real_mul~2.html","title":"real_mul – FLOw"},{"text":"private pure function right_eigenvectors(self, eos) result(eig) Return the right eigenvectors matrix R as dF/dP = A = R &#94; L . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. class( eos_object ), intent(in) :: eos Equation of state. Return Value real(kind=R8P)\n  (1:3,1:3) Eigenvectors. Source Code right_eigenvectors Source Code pure function right_eigenvectors ( self , eos ) result ( eig ) !< Return the right eigenvectors matrix `R` as `dF/dP = A = R &#94; L`. class ( primitive_compressible ), intent ( in ) :: self !< Primitive. class ( eos_object ), intent ( in ) :: eos !< Equation of state. real ( R8P ) :: eig ( 1 : 3 , 1 : 3 ) !< Eigenvectors. real ( R8P ) :: gp !< `g*p`. real ( R8P ) :: gp_inv !< `1/(g*p)`. real ( R8P ) :: a !< Speed of sound, `sqrt(g*p/r)`. gp = eos % g () * self % pressure gp_inv = 1._R8P / gp a = eos % speed_of_sound ( density = self % density , pressure = self % pressure ) eig ( 1 , 1 ) = 0.5_R8P * self % density * gp_inv ; eig ( 1 , 2 ) = self % density * gp_inv ; eig ( 1 , 3 ) = eig ( 1 , 1 ) eig ( 2 , 1 ) = - 0.5_R8P * a * gp_inv ; eig ( 2 , 2 ) = 0._R8P ; eig ( 2 , 3 ) = - eig ( 2 , 1 ) eig ( 3 , 1 ) = 0.5_R8P ; eig ( 3 , 2 ) = 0._R8P ; eig ( 3 , 3 ) = eig ( 3 , 1 ) endfunction right_eigenvectors","tags":"","loc":"proc/right_eigenvectors.html","title":"right_eigenvectors – FLOw"},{"text":"private elemental function sub(lhs, rhs) result(opr) Operator - . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code sub Source Code elemental function sub ( lhs , rhs ) result ( opr ) !< Operator `-`. class ( primitive_compressible ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( primitive_compressible :: opr ) select type ( opr ) class is ( primitive_compressible ) select type ( rhs ) class is ( primitive_compressible ) opr % density = lhs % density - rhs % density opr % velocity = lhs % velocity - rhs % velocity opr % pressure = lhs % pressure - rhs % pressure endselect endselect endfunction sub","tags":"","loc":"proc/sub~2.html","title":"sub – FLOw"},{"text":"private elemental subroutine assign_field(lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(inout) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Source Code assign_field Source Code elemental subroutine assign_field ( lhs , rhs ) !< Operator `=`. class ( primitive_compressible ), intent ( inout ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. select type ( rhs ) class is ( primitive_compressible ) lhs % density = rhs % density lhs % velocity = rhs % velocity lhs % pressure = rhs % pressure endselect endsubroutine assign_field","tags":"","loc":"proc/assign_field~2.html","title":"assign_field – FLOw"},{"text":"private elemental subroutine assign_real(lhs, rhs) Operator field = real . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(inout) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Source Code assign_real Source Code elemental subroutine assign_real ( lhs , rhs ) !< Operator `field = real`. class ( primitive_compressible ), intent ( inout ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. lhs % density = rhs lhs % velocity = rhs lhs % pressure = rhs endsubroutine assign_real","tags":"","loc":"proc/assign_real~2.html","title":"assign_real – FLOw"},{"text":"private elemental subroutine destroy(self) Destroy primitive. Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(inout) :: self Primitive. Source Code destroy Source Code elemental subroutine destroy ( self ) !< Destroy primitive. class ( primitive_compressible ), intent ( inout ) :: self !< Primitive. type ( primitive_compressible ) :: fresh !< Fresh instance of primitive object. self = fresh endsubroutine destroy","tags":"","loc":"proc/destroy~2.html","title":"destroy – FLOw"},{"text":"private subroutine initialize(self, initial_state) Initialize primitive. Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(inout) :: self Primitive. class( primitive_object ), intent(in), optional :: initial_state Initial state. Source Code initialize Source Code subroutine initialize ( self , initial_state ) !< Initialize primitive. class ( primitive_compressible ), intent ( inout ) :: self !< Primitive. class ( primitive_object ), intent ( in ), optional :: initial_state !< Initial state. call self % destroy if ( present ( initial_state )) then select type ( initial_state ) class is ( primitive_compressible ) self = initial_state endselect endif endsubroutine initialize","tags":"","loc":"proc/initialize~2.html","title":"initialize – FLOw"},{"text":"public interface primitive_compressible Overload primitive_compressible name with its constructor. Calls interface~~primitive_compressible~~CallsGraph interface~primitive_compressible primitive_compressible proc~primitive_compressible_instance primitive_compressible_instance interface~primitive_compressible->proc~primitive_compressible_instance Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures primitive_compressible_instance Module Procedures private pure function primitive_compressible_instance (density, velocity, pressure) result(instance) Return and instance of primitive_compressible . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in), optional :: density Density field. type(vector), intent(in), optional :: velocity Velocity field. real(kind=R8P), intent(in), optional :: pressure Pressure field. Return Value type( primitive_compressible ) Instance of primitive_compressible .","tags":"","loc":"interface/primitive_compressible.html","title":"primitive_compressible – FLOw"},{"text":"private elemental function add(lhs, rhs) result(opr) Operator + . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code add Source Code elemental function add ( lhs , rhs ) result ( opr ) !< Operator `+`. class ( primitive_compressible_multispecie ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( primitive_compressible_multispecie :: opr ) select type ( opr ) class is ( primitive_compressible_multispecie ) select type ( rhs ) class is ( primitive_compressible_multispecie ) opr % density = lhs % density + rhs % density opr % velocity = lhs % velocity + rhs % velocity opr % pressure = lhs % pressure + rhs % pressure if ( lhs . compatible . rhs ) opr % partial_densities = lhs % partial_densities + rhs % partial_densities endselect endselect endfunction add","tags":"","loc":"proc/add~3.html","title":"add – FLOw"},{"text":"private pure function array(self) result(array_) Return serialized array of field. Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: self Primitive. Return Value real(kind=R8P),\n  allocatable,(:) Serialized array of field. Source Code array Source Code pure function array ( self ) result ( array_ ) !< Return serialized array of field. class ( primitive_compressible_multispecie ), intent ( in ) :: self !< Primitive. real ( R8P ), allocatable :: array_ (:) !< Serialized array of field. if ( allocated ( self % partial_densities )) then allocate ( array_ ( 1 : 5 + size ( self % partial_densities , dim = 1 ))) array_ ( 1 ) = self % density array_ ( 2 ) = self % velocity % x array_ ( 3 ) = self % velocity % y array_ ( 4 ) = self % velocity % z array_ ( 5 ) = self % pressure array_ ( 6 :) = self % partial_densities (:) else allocate ( array_ ( 1 : 5 )) array_ ( 1 ) = self % density array_ ( 2 ) = self % velocity % x array_ ( 3 ) = self % velocity % y array_ ( 4 ) = self % velocity % z array_ ( 5 ) = self % pressure endif endfunction array","tags":"","loc":"proc/array~3.html","title":"array – FLOw"},{"text":"private elemental function compatible(lhs, rhs) result(opr) Operator .compatible. . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. type( primitive_compressible_multispecie ), intent(in) :: rhs Right hand side. Return Value logical Operator result. Source Code compatible Source Code elemental function compatible ( lhs , rhs ) result ( opr ) !< Operator `.compatible.`. class ( primitive_compressible_multispecie ), intent ( in ) :: lhs !< Left hand side. type ( primitive_compressible_multispecie ), intent ( in ) :: rhs !< Right hand side. logical :: opr !< Operator result. opr = allocated ( lhs % partial_densities ). and . allocated ( rhs % partial_densities ) if ( opr ) opr = size ( lhs % partial_densities , dim = 1 ) == size ( rhs % partial_densities , dim = 1 ) endfunction compatible","tags":"","loc":"proc/compatible.html","title":"compatible – FLOw"},{"text":"private pure function description(self, prefix) result(desc) Return a pretty-formatted object description. Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: self Primitive. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. Calls proc~~description~4~~CallsGraph proc~description~4 description interface~str str proc~description~4->interface~str proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_bol str_bol interface~str->proc~str_bol proc~str_a_i4p->proc~str_i4p proc~str_a_i8p->proc~str_i8p proc~compact_real_string compact_real_string proc~str_r8p->proc~compact_real_string proc~str_a_r4p->proc~str_r4p proc~str_a_i1p->proc~str_i1p proc~str_a_r8p->proc~str_r8p proc~str_a_i2p->proc~str_i2p proc~str_r4p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code description Source Code pure function description ( self , prefix ) result ( desc ) !< Return a pretty-formatted object description. class ( primitive_compressible_multispecie ), intent ( in ) :: self !< Primitive. character ( * ), intent ( in ), optional :: prefix !< Prefixing string. character ( len = :), allocatable :: prefix_ !< Prefixing string, local variable. character ( len = :), allocatable :: desc !< Description. character ( len = 1 ), parameter :: NL = new_line ( 'a' ) !< New line character. if ( allocated ( self % partial_densities )) then prefix_ = '' ; if ( present ( prefix )) prefix_ = prefix desc = '' desc = desc // prefix_ // 'density           = ' // trim ( str ( n = self % density )) // NL desc = desc // prefix_ // 'velocity          = ' // trim ( str ( n = [ self % velocity % x , self % velocity % y , self % velocity % z ])) // NL desc = desc // prefix_ // 'pressure          = ' // trim ( str ( n = self % pressure )) // NL desc = desc // prefix_ // 'partial densities = ' // trim ( str ( n = self % partial_densities )) else prefix_ = '' ; if ( present ( prefix )) prefix_ = prefix desc = '' desc = desc // prefix_ // 'density  = ' // trim ( str ( n = self % density )) // NL desc = desc // prefix_ // 'velocity = ' // trim ( str ( n = [ self % velocity % x , self % velocity % y , self % velocity % z ])) // NL desc = desc // prefix_ // 'pressure = ' // trim ( str ( n = self % pressure )) endif endfunction description","tags":"","loc":"proc/description~4.html","title":"description – FLOw"},{"text":"private elemental function div(lhs, rhs) result(opr) Operator / . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code div Source Code elemental function div ( lhs , rhs ) result ( opr ) !< Operator `/`. class ( primitive_compressible_multispecie ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( primitive_compressible_multispecie :: opr ) select type ( opr ) class is ( primitive_compressible_multispecie ) select type ( rhs ) class is ( primitive_compressible_multispecie ) opr % density = lhs % density / rhs % density opr % velocity = lhs % velocity / rhs % velocity opr % pressure = lhs % pressure / rhs % pressure if ( lhs . compatible . rhs ) opr % partial_densities = lhs % partial_densities / rhs % partial_densities endselect endselect endfunction div","tags":"","loc":"proc/div~3.html","title":"div – FLOw"},{"text":"private elemental function div_integer(lhs, rhs) result(opr) Operator field / integer . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code div_integer Source Code elemental function div_integer ( lhs , rhs ) result ( opr ) !< Operator `field / integer`. class ( primitive_compressible_multispecie ), intent ( in ) :: lhs !< Left hand side. integer ( I4P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( primitive_compressible_multispecie :: opr ) select type ( opr ) class is ( primitive_compressible_multispecie ) opr % density = lhs % density / rhs opr % velocity = lhs % velocity / rhs opr % pressure = lhs % pressure / rhs if ( allocated ( lhs % partial_densities )) opr % partial_densities = lhs % partial_densities / rhs endselect endfunction div_integer","tags":"","loc":"proc/div_integer~3.html","title":"div_integer – FLOw"},{"text":"private elemental function div_real(lhs, rhs) result(opr) Operator field / real . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code div_real Source Code elemental function div_real ( lhs , rhs ) result ( opr ) !< Operator `field / real`. class ( primitive_compressible_multispecie ), intent ( in ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( primitive_compressible_multispecie :: opr ) select type ( opr ) class is ( primitive_compressible_multispecie ) opr % density = lhs % density / rhs opr % velocity = lhs % velocity / rhs opr % pressure = lhs % pressure / rhs if ( allocated ( lhs % partial_densities )) opr % partial_densities = lhs % partial_densities / rhs endselect endfunction div_real","tags":"","loc":"proc/div_real~3.html","title":"div_real – FLOw"},{"text":"private elemental function energy(self, eos) result(energy_) Return energy value. Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: self Primitive. class( eos_object ), intent(in) :: eos Equation of state. Return Value real(kind=R8P) Energy value. Source Code energy Source Code elemental function energy ( self , eos ) result ( energy_ ) !< Return energy value. class ( primitive_compressible_multispecie ), intent ( in ) :: self !< Primitive. class ( eos_object ), intent ( in ) :: eos !< Equation of state. real ( R8P ) :: energy_ !< Energy value. energy_ = self % pressure / ( eos % g () - 1._R8P ) + 0.5_R8P * self % density * self % velocity % sq_norm () endfunction energy","tags":"","loc":"proc/energy~2.html","title":"energy – FLOw"},{"text":"private elemental function eq(lhs, rhs) result(opr) Operator `=='. Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. Source Code eq Source Code elemental function eq ( lhs , rhs ) result ( opr ) !< Operator `=='. class ( primitive_compressible_multispecie ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. logical :: opr !< Operator result. integer ( I4P ) :: d !< Counter. select type ( rhs ) class is ( primitive_compressible_multispecie ) opr = lhs % density == rhs % density if ( opr ) opr = lhs % velocity == rhs % velocity if ( opr ) opr = lhs % pressure == rhs % pressure if ( opr . and . allocated ( lhs % partial_densities ). and . allocated ( rhs % partial_densities )) then if ( opr ) opr = lhs . compatible . rhs if ( opr ) then do d = 1 , size ( lhs % partial_densities , dim = 1 ) opr = lhs % partial_densities ( d ) == rhs % partial_densities ( d ) if (. not . opr ) exit enddo endif elseif ( opr . and . allocated ( lhs % partial_densities ). and .(. not . allocated ( rhs % partial_densities ))) then opr = . false . elseif ( opr . and .(. not . allocated ( lhs % partial_densities )). and . allocated ( rhs % partial_densities )) then opr = . false . endif endselect endfunction eq","tags":"","loc":"proc/eq~3.html","title":"eq – FLOw"},{"text":"private elemental function integer_mul(lhs, rhs) result(opr) Operator integer * field . Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: lhs Left hand side. class( primitive_compressible_multispecie ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code integer_mul Source Code elemental function integer_mul ( lhs , rhs ) result ( opr ) !< Operator `integer * field`. integer ( I4P ), intent ( in ) :: lhs !< Left hand side. class ( primitive_compressible_multispecie ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( primitive_compressible_multispecie :: opr ) select type ( opr ) class is ( primitive_compressible_multispecie ) opr % density = lhs * rhs % density opr % velocity = lhs * rhs % velocity opr % pressure = lhs * rhs % pressure if ( allocated ( rhs % partial_densities )) opr % partial_densities = lhs * rhs % partial_densities endselect endfunction integer_mul","tags":"","loc":"proc/integer_mul~3.html","title":"integer_mul – FLOw"},{"text":"private elemental function momentum(self) result(momentum_) Return momentum vector. Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: self Primitive. Return Value type(vector) Momentum vector. Source Code momentum Source Code elemental function momentum ( self ) result ( momentum_ ) !< Return momentum vector. class ( primitive_compressible_multispecie ), intent ( in ) :: self !< Primitive. type ( vector ) :: momentum_ !< Momentum vector. momentum_ = self % density * self % velocity endfunction momentum","tags":"","loc":"proc/momentum~2.html","title":"momentum – FLOw"},{"text":"private elemental function mul(lhs, rhs) result(opr) Operator * . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code mul Source Code elemental function mul ( lhs , rhs ) result ( opr ) !< Operator `*`. class ( primitive_compressible_multispecie ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( primitive_compressible_multispecie :: opr ) select type ( opr ) class is ( primitive_compressible_multispecie ) select type ( rhs ) class is ( primitive_compressible_multispecie ) opr % density = lhs % density * rhs % density opr % velocity = lhs % velocity * rhs % velocity opr % pressure = lhs % pressure * rhs % pressure if ( lhs . compatible . rhs ) opr % partial_densities = lhs % partial_densities * rhs % partial_densities endselect endselect endfunction mul","tags":"","loc":"proc/mul~3.html","title":"mul – FLOw"},{"text":"private elemental function mul_integer(lhs, rhs) result(opr) Operator field * integer . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code mul_integer Source Code elemental function mul_integer ( lhs , rhs ) result ( opr ) !< Operator `field * integer`. class ( primitive_compressible_multispecie ), intent ( in ) :: lhs !< Left hand side. integer ( I4P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( primitive_compressible_multispecie :: opr ) select type ( opr ) class is ( primitive_compressible_multispecie ) opr % density = lhs % density * rhs opr % velocity = lhs % velocity * rhs opr % pressure = lhs % pressure * rhs if ( allocated ( lhs % partial_densities )) opr % partial_densities = lhs % partial_densities * rhs endselect endfunction mul_integer","tags":"","loc":"proc/mul_integer~3.html","title":"mul_integer – FLOw"},{"text":"private elemental function mul_real(lhs, rhs) result(opr) Operator field * real . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code mul_real Source Code elemental function mul_real ( lhs , rhs ) result ( opr ) !< Operator `field * real`. class ( primitive_compressible_multispecie ), intent ( in ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( primitive_compressible_multispecie :: opr ) select type ( opr ) class is ( primitive_compressible_multispecie ) opr % density = lhs % density * rhs opr % velocity = lhs % velocity * rhs opr % pressure = lhs % pressure * rhs if ( allocated ( lhs % partial_densities )) opr % partial_densities = lhs % partial_densities * rhs endselect endfunction mul_real","tags":"","loc":"proc/mul_real~3.html","title":"mul_real – FLOw"},{"text":"private function negative(self) result(operator_result) Unary operator - field . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: self Primitive. Return Value class( field_object ),\n  allocatable Operator result. Source Code negative Source Code function negative ( self ) result ( operator_result ) !< Unary operator `- field`. class ( primitive_compressible_multispecie ), intent ( in ) :: self !< Primitive. class ( field_object ), allocatable :: operator_result !< Operator result. allocate ( primitive_compressible_multispecie :: operator_result ) select type ( operator_result ) class is ( primitive_compressible_multispecie ) operator_result % density = - self % density operator_result % velocity = - self % velocity operator_result % pressure = - self % pressure if ( allocated ( self % partial_densities )) operator_result % partial_densities = - self % partial_densities endselect endfunction negative","tags":"","loc":"proc/negative~3.html","title":"negative – FLOw"},{"text":"private elemental function not_eq(lhs, rhs) result(opr) Operator `/='. Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. Source Code not_eq Source Code elemental function not_eq ( lhs , rhs ) result ( opr ) !< Operator `/='. class ( primitive_compressible_multispecie ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. logical :: opr !< Operator result. opr = . not .( lhs % eq ( rhs = rhs )) endfunction not_eq","tags":"","loc":"proc/not_eq~3.html","title":"not_eq – FLOw"},{"text":"private function positive(self) result(opr) Unary operator + field . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: self Primitive. Return Value class( field_object ),\n  allocatable Operator result. Source Code positive Source Code function positive ( self ) result ( opr ) !< Unary operator `+ field`. class ( primitive_compressible_multispecie ), intent ( in ) :: self !< Primitive. class ( field_object ), allocatable :: opr !< Operator result. allocate ( primitive_compressible_multispecie :: opr ) select type ( opr ) class is ( primitive_compressible_multispecie ) opr % density = + self % density opr % velocity = + self % velocity opr % pressure = + self % pressure if ( allocated ( self % partial_densities )) opr % partial_densities = + self % partial_densities endselect endfunction positive","tags":"","loc":"proc/positive~3.html","title":"positive – FLOw"},{"text":"private elemental function pow_integer(lhs, rhs) result(opr) Operator field ** integer . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code pow_integer Source Code elemental function pow_integer ( lhs , rhs ) result ( opr ) !< Operator `field ** integer`. class ( primitive_compressible_multispecie ), intent ( in ) :: lhs !< Left hand side. integer ( I4P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( primitive_compressible_multispecie :: opr ) select type ( opr ) class is ( primitive_compressible_multispecie ) opr % density = lhs % density ** rhs opr % velocity % x = lhs % velocity % x ** rhs opr % velocity % y = lhs % velocity % y ** rhs opr % velocity % z = lhs % velocity % z ** rhs opr % pressure = lhs % pressure ** rhs if ( allocated ( lhs % partial_densities )) opr % partial_densities = lhs % partial_densities ** rhs endselect endfunction pow_integer","tags":"","loc":"proc/pow_integer~3.html","title":"pow_integer – FLOw"},{"text":"private elemental function pow_real(lhs, rhs) result(opr) Operator field ** real . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code pow_real Source Code elemental function pow_real ( lhs , rhs ) result ( opr ) !< Operator `field ** real`. class ( primitive_compressible_multispecie ), intent ( in ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( primitive_compressible_multispecie :: opr ) select type ( opr ) class is ( primitive_compressible_multispecie ) opr % density = lhs % density ** rhs opr % velocity % x = lhs % velocity % x ** rhs opr % velocity % y = lhs % velocity % y ** rhs opr % velocity % z = lhs % velocity % z ** rhs opr % pressure = lhs % pressure ** rhs if ( allocated ( lhs % partial_densities )) opr % partial_densities = lhs % partial_densities ** rhs endselect endfunction pow_real","tags":"","loc":"proc/pow_real~3.html","title":"pow_real – FLOw"},{"text":"private pure function primitive_compressible_multispecie_instance(density, velocity, pressure, partial_densities) result(instance) Return and instance of primitive_compressible_multispecie . Note This procedure is used for overloading primitive_compressible_multispecie name. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in), optional :: density Density field. type(vector), intent(in), optional :: velocity Velocity field. real(kind=R8P), intent(in), optional :: pressure Pressure field. real(kind=R8P), intent(in), optional :: partial_densities (:) Partial densities field. Return Value type( primitive_compressible_multispecie ) Instance of primitive_compressible_multispecie . Called By proc~~primitive_compressible_multispecie_instance~~CalledByGraph proc~primitive_compressible_multispecie_instance primitive_compressible_multispecie_instance interface~primitive_compressible_multispecie primitive_compressible_multispecie interface~primitive_compressible_multispecie->proc~primitive_compressible_multispecie_instance Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code primitive_compressible_multispecie_instance Source Code pure function primitive_compressible_multispecie_instance ( density , velocity , pressure , partial_densities ) result ( instance ) !< Return and instance of [[primitive_compressible_multispecie]]. !< !< @note This procedure is used for overloading [[primitive_compressible_multispecie]] name. real ( R8P ), intent ( in ), optional :: density !< Density field. type ( vector ), intent ( in ), optional :: velocity !< Velocity field. real ( R8P ), intent ( in ), optional :: pressure !< Pressure field. real ( R8P ), intent ( in ), optional :: partial_densities (:) !< Partial densities field. type ( primitive_compressible_multispecie ) :: instance !< Instance of [[primitive_compressible_multispecie]]. if ( present ( density )) instance % density = density if ( present ( velocity )) instance % velocity = velocity if ( present ( pressure )) instance % pressure = pressure if ( present ( partial_densities )) instance % partial_densities = partial_densities endfunction primitive_compressible_multispecie_instance","tags":"","loc":"proc/primitive_compressible_multispecie_instance.html","title":"primitive_compressible_multispecie_instance – FLOw"},{"text":"private elemental function real_mul(lhs, rhs) result(opr) Operator real * field . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs Left hand side. class( primitive_compressible_multispecie ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code real_mul Source Code elemental function real_mul ( lhs , rhs ) result ( opr ) !< Operator `real * field`. real ( R8P ), intent ( in ) :: lhs !< Left hand side. class ( primitive_compressible_multispecie ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( primitive_compressible_multispecie :: opr ) select type ( opr ) class is ( primitive_compressible_multispecie ) opr % density = lhs * rhs % density opr % velocity = lhs * rhs % velocity opr % pressure = lhs * rhs % pressure if ( allocated ( rhs % partial_densities )) opr % partial_densities = lhs * rhs % partial_densities endselect endfunction real_mul","tags":"","loc":"proc/real_mul~3.html","title":"real_mul – FLOw"},{"text":"private elemental function sub(lhs, rhs) result(opr) Operator - . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Source Code sub Source Code elemental function sub ( lhs , rhs ) result ( opr ) !< Operator `-`. class ( primitive_compressible_multispecie ), intent ( in ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. class ( field_object ), allocatable :: opr !< Operator result. allocate ( primitive_compressible_multispecie :: opr ) select type ( opr ) class is ( primitive_compressible_multispecie ) select type ( rhs ) class is ( primitive_compressible_multispecie ) opr % density = lhs % density - rhs % density opr % velocity = lhs % velocity - rhs % velocity opr % pressure = lhs % pressure - rhs % pressure if ( lhs . compatible . rhs ) opr % partial_densities = lhs % partial_densities - rhs % partial_densities endselect endselect endfunction sub","tags":"","loc":"proc/sub~3.html","title":"sub – FLOw"},{"text":"private elemental subroutine assign_field(lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(inout) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Source Code assign_field Source Code elemental subroutine assign_field ( lhs , rhs ) !< Operator `=`. class ( primitive_compressible_multispecie ), intent ( inout ) :: lhs !< Left hand side. class ( field_object ), intent ( in ) :: rhs !< Right hand side. select type ( rhs ) class is ( primitive_compressible_multispecie ) lhs % density = rhs % density lhs % velocity = rhs % velocity lhs % pressure = rhs % pressure if ( allocated ( rhs % partial_densities )) lhs % partial_densities = rhs % partial_densities endselect endsubroutine assign_field","tags":"","loc":"proc/assign_field~3.html","title":"assign_field – FLOw"},{"text":"private elemental subroutine assign_real(lhs, rhs) Operator field = real . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(inout) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Source Code assign_real Source Code elemental subroutine assign_real ( lhs , rhs ) !< Operator `field = real`. class ( primitive_compressible_multispecie ), intent ( inout ) :: lhs !< Left hand side. real ( R8P ), intent ( in ) :: rhs !< Right hand side. lhs % density = rhs lhs % velocity = rhs lhs % pressure = rhs if ( allocated ( lhs % partial_densities )) lhs % partial_densities = rhs endsubroutine assign_real","tags":"","loc":"proc/assign_real~3.html","title":"assign_real – FLOw"},{"text":"private elemental subroutine destroy(self) Destroy primitive. Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(inout) :: self Primitive. Source Code destroy Source Code elemental subroutine destroy ( self ) !< Destroy primitive. class ( primitive_compressible_multispecie ), intent ( inout ) :: self !< Primitive. type ( primitive_compressible_multispecie ) :: fresh !< Fresh instance of primitive object. self = fresh endsubroutine destroy","tags":"","loc":"proc/destroy~3.html","title":"destroy – FLOw"},{"text":"private subroutine initialize(self, initial_state) Initialize primitive. Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(inout) :: self Primitive. class( primitive_object ), intent(in), optional :: initial_state Initial state. Source Code initialize Source Code subroutine initialize ( self , initial_state ) !< Initialize primitive. class ( primitive_compressible_multispecie ), intent ( inout ) :: self !< Primitive. class ( primitive_object ), intent ( in ), optional :: initial_state !< Initial state. call self % destroy if ( present ( initial_state )) then select type ( initial_state ) class is ( primitive_compressible_multispecie ) self = initial_state endselect endif endsubroutine initialize","tags":"","loc":"proc/initialize~3.html","title":"initialize – FLOw"},{"text":"public interface primitive_compressible_multispecie Overload primitive_compressible_multispecie name with its constructor. Calls interface~~primitive_compressible_multispecie~~CallsGraph interface~primitive_compressible_multispecie primitive_compressible_multispecie proc~primitive_compressible_multispecie_instance primitive_compressible_multispecie_instance interface~primitive_compressible_multispecie->proc~primitive_compressible_multispecie_instance Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures primitive_compressible_multispecie_instance Module Procedures private pure function primitive_compressible_multispecie_instance (density, velocity, pressure, partial_densities) result(instance) Return and instance of primitive_compressible_multispecie . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in), optional :: density Density field. type(vector), intent(in), optional :: velocity Velocity field. real(kind=R8P), intent(in), optional :: pressure Pressure field. real(kind=R8P), intent(in), optional :: partial_densities (:) Partial densities field. Return Value type( primitive_compressible_multispecie ) Instance of primitive_compressible_multispecie .","tags":"","loc":"interface/primitive_compressible_multispecie.html","title":"primitive_compressible_multispecie – FLOw"},{"text":"subroutine print_error(test, is_test_passed) Print error message if test is failed. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: test Test description. logical, intent(in) :: is_test_passed Test result. Called By proc~~print_error~~CalledByGraph proc~print_error print_error program~flow_test_conservative_compressible_div flow_test_conservative_compressible_div program~flow_test_conservative_compressible_div->proc~print_error Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code print_error Source Code subroutine print_error ( test , is_test_passed ) !< Print error message if test is failed. character ( * ), intent ( in ) :: test !< Test description. logical , intent ( in ) :: is_test_passed !< Test result. if (. not . is_test_passed ) then print * , '\"' // test // '\" failed!' print * , 'conservative1:' print \"(A,F6.3)\" , '  density   = ' , conservative1 % density print \"(A,3(F6.3,1X))\" , '  momentum  = ' , conservative1 % momentum print \"(A,F6.3)\" , '  energy    = ' , conservative1 % energy print * , 'conservative2:' print \"(A,F6.3)\" , '  density   = ' , conservative2 % density print \"(A,3(F6.3,1X))\" , '  momentum  = ' , conservative2 % momentum print \"(A,F6.3)\" , '  energy    = ' , conservative2 % energy print * , 'conservative3:' print \"(A,F6.3)\" , '  density   = ' , conservative3 % density print \"(A,3(F6.3,1X))\" , '  momentum  = ' , conservative3 % momentum print \"(A,F6.3)\" , '  energy    = ' , conservative3 % energy endif endsubroutine print_error","tags":"","loc":"proc/print_error.html","title":"print_error – FLOw"},{"text":"subroutine print_error(test, is_test_passed) Print error message if test is failed. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: test Test description. logical, intent(in) :: is_test_passed Test result. Called By proc~~print_error~2~~CalledByGraph proc~print_error~2 print_error program~flow_test_conservative_compressible_mul flow_test_conservative_compressible_mul program~flow_test_conservative_compressible_mul->proc~print_error~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code print_error Source Code subroutine print_error ( test , is_test_passed ) !< Print error message if test is failed. character ( * ), intent ( in ) :: test !< Test description. logical , intent ( in ) :: is_test_passed !< Test result. if (. not . is_test_passed ) then print * , '\"' // test // '\" failed!' print * , 'conservative1:' print \"(A,F6.3)\" , '  density  = ' , conservative1 % density print \"(A,3(F6.3,1X))\" , '  momentum = ' , conservative1 % momentum print \"(A,F6.3)\" , '  energy   = ' , conservative1 % energy print * , 'conservative2:' print \"(A,F6.3)\" , '  density  = ' , conservative2 % density print \"(A,3(F6.3,1X))\" , '  momentum = ' , conservative2 % momentum print \"(A,F6.3)\" , '  energy   = ' , conservative2 % energy print * , 'conservative3:' print \"(A,F6.3)\" , '  density  = ' , conservative3 % density print \"(A,3(F6.3,1X))\" , '  momentum = ' , conservative3 % momentum print \"(A,F6.3)\" , '  energy   = ' , conservative3 % energy endif endsubroutine print_error","tags":"","loc":"proc/print_error~2.html","title":"print_error – FLOw"},{"text":"subroutine print_error(test, is_test_passed) Print error message if test is failed. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: test Test description. logical, intent(in) :: is_test_passed Test result. Called By proc~~print_error~3~~CalledByGraph proc~print_error~3 print_error program~flow_test_primitive_compressible_div flow_test_primitive_compressible_div program~flow_test_primitive_compressible_div->proc~print_error~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code print_error Source Code subroutine print_error ( test , is_test_passed ) !< Print error message if test is failed. character ( * ), intent ( in ) :: test !< Test description. logical , intent ( in ) :: is_test_passed !< Test result. if (. not . is_test_passed ) then print * , '\"' // test // '\" failed!' print * , 'primitive1:' print \"(A,F6.3)\" , '  density   = ' , primitive1 % density print \"(A,3(F6.3,1X))\" , '  velocity  = ' , primitive1 % velocity print \"(A,F6.3)\" , '  pressure  = ' , primitive1 % pressure print * , 'primitive2:' print \"(A,F6.3)\" , '  density   = ' , primitive2 % density print \"(A,3(F6.3,1X))\" , '  velocity  = ' , primitive2 % velocity print \"(A,F6.3)\" , '  pressure  = ' , primitive2 % pressure print * , 'primitive3:' print \"(A,F6.3)\" , '  density   = ' , primitive3 % density print \"(A,3(F6.3,1X))\" , '  velocity  = ' , primitive3 % velocity print \"(A,F6.3)\" , '  pressure  = ' , primitive3 % pressure endif endsubroutine print_error","tags":"","loc":"proc/print_error~3.html","title":"print_error – FLOw"},{"text":"subroutine print_error(test, is_test_passed) Print error message if test is failed. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: test Test description. logical, intent(in) :: is_test_passed Test result. Called By proc~~print_error~4~~CalledByGraph proc~print_error~4 print_error program~flow_test_primitive_compressible_mul flow_test_primitive_compressible_mul program~flow_test_primitive_compressible_mul->proc~print_error~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code print_error Source Code subroutine print_error ( test , is_test_passed ) !< Print error message if test is failed. character ( * ), intent ( in ) :: test !< Test description. logical , intent ( in ) :: is_test_passed !< Test result. if (. not . is_test_passed ) then print * , '\"' // test // '\" failed!' print * , 'primitive1:' print \"(A,F6.3)\" , '  density   = ' , primitive1 % density print \"(A,3(F6.3,1X))\" , '  velocity  = ' , primitive1 % velocity print \"(A,F6.3)\" , '  pressure  = ' , primitive1 % pressure print * , 'primitive2:' print \"(A,F6.3)\" , '  density   = ' , primitive2 % density print \"(A,3(F6.3,1X))\" , '  velocity  = ' , primitive2 % velocity print \"(A,F6.3)\" , '  pressure  = ' , primitive2 % pressure print * , 'primitive3:' print \"(A,F6.3)\" , '  density   = ' , primitive3 % density print \"(A,3(F6.3,1X))\" , '  velocity  = ' , primitive3 % velocity print \"(A,F6.3)\" , '  pressure  = ' , primitive3 % pressure endif endsubroutine print_error","tags":"","loc":"proc/print_error~4.html","title":"print_error – FLOw"},{"text":"subroutine print_error(test, is_test_passed) Print error message if test is failed. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: test Test description. logical, intent(in) :: is_test_passed Test result. Called By proc~~print_error~5~~CalledByGraph proc~print_error~5 print_error program~flow_test_primitive_compressible_multispecie_div flow_test_primitive_compressible_multispecie_div program~flow_test_primitive_compressible_multispecie_div->proc~print_error~5 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code print_error Source Code subroutine print_error ( test , is_test_passed ) !< Print error message if test is failed. character ( * ), intent ( in ) :: test !< Test description. logical , intent ( in ) :: is_test_passed !< Test result. if (. not . is_test_passed ) then print * , '\"' // test // '\" failed!' print * , 'primitive1:' print \"(A,F6.3)\" , '  density   = ' , primitive1 % density print \"(A,3(F6.3,1X))\" , '  velocity  = ' , primitive1 % velocity print \"(A,F6.3)\" , '  pressure  = ' , primitive1 % pressure print \"(A,2(F7.4,1X))\" , '  densities = ' , primitive1 % partial_densities ( 1 ), primitive1 % partial_densities ( 2 ) print * , 'primitive2:' print \"(A,F6.3)\" , '  density   = ' , primitive2 % density print \"(A,3(F6.3,1X))\" , '  velocity  = ' , primitive2 % velocity print \"(A,F6.3)\" , '  pressure  = ' , primitive2 % pressure print \"(A,2(F7.4,1X))\" , '  densities = ' , primitive2 % partial_densities ( 1 ), primitive2 % partial_densities ( 2 ) print * , 'primitive3:' print \"(A,F6.3)\" , '  density   = ' , primitive3 % density print \"(A,3(F6.3,1X))\" , '  velocity  = ' , primitive3 % velocity print \"(A,F6.3)\" , '  pressure  = ' , primitive3 % pressure print \"(A,2(F7.4,1X))\" , '  densities = ' , primitive3 % partial_densities ( 1 ), primitive3 % partial_densities ( 2 ) endif endsubroutine print_error","tags":"","loc":"proc/print_error~5.html","title":"print_error – FLOw"},{"text":"subroutine print_error(test, is_test_passed) Print error message if test is failed. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: test Test description. logical, intent(in) :: is_test_passed Test result. Called By proc~~print_error~6~~CalledByGraph proc~print_error~6 print_error program~flow_test_primitive_compressible_multispecie_mul flow_test_primitive_compressible_multispecie_mul program~flow_test_primitive_compressible_multispecie_mul->proc~print_error~6 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code print_error Source Code subroutine print_error ( test , is_test_passed ) !< Print error message if test is failed. character ( * ), intent ( in ) :: test !< Test description. logical , intent ( in ) :: is_test_passed !< Test result. if (. not . is_test_passed ) then print * , '\"' // test // '\" failed!' print * , 'primitive1:' print \"(A,F6.3)\" , '  density   = ' , primitive1 % density print \"(A,3(F6.3,1X))\" , '  velocity  = ' , primitive1 % velocity print \"(A,F6.3)\" , '  pressure  = ' , primitive1 % pressure print \"(A,2(F7.4,1X))\" , '  densities = ' , primitive1 % partial_densities ( 1 ), primitive1 % partial_densities ( 2 ) print * , 'primitive2:' print \"(A,F6.3)\" , '  density   = ' , primitive2 % density print \"(A,3(F6.3,1X))\" , '  velocity  = ' , primitive2 % velocity print \"(A,F6.3)\" , '  pressure  = ' , primitive2 % pressure print \"(A,2(F7.4,1X))\" , '  densities = ' , primitive2 % partial_densities ( 1 ), primitive2 % partial_densities ( 2 ) print * , 'primitive3:' print \"(A,F6.3)\" , '  density   = ' , primitive3 % density print \"(A,3(F6.3,1X))\" , '  velocity  = ' , primitive3 % velocity print \"(A,F6.3)\" , '  pressure  = ' , primitive3 % pressure print \"(A,2(F7.4,1X))\" , '  densities = ' , primitive3 % partial_densities ( 1 ), primitive3 % partial_densities ( 2 ) endif endsubroutine print_error","tags":"","loc":"proc/print_error~6.html","title":"print_error – FLOw"},{"text":"private elemental function digit_I1(n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Called By proc~~digit_i1~~CalledByGraph proc~digit_i1 digit_I1 interface~digit digit interface~digit->proc~digit_i1 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code digit_I1 Source Code elemental function digit_I1 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Input integer. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I1","tags":"","loc":"proc/digit_i1.html","title":"digit_I1 – FLOw"},{"text":"private elemental function digit_I2(n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Called By proc~~digit_i2~~CalledByGraph proc~digit_i2 digit_I2 interface~digit digit interface~digit->proc~digit_i2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code digit_I2 Source Code elemental function digit_I2 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Input integer. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I2","tags":"","loc":"proc/digit_i2.html","title":"digit_I2 – FLOw"},{"text":"private elemental function digit_I4(n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Called By proc~~digit_i4~~CalledByGraph proc~digit_i4 digit_I4 interface~digit digit interface~digit->proc~digit_i4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code digit_I4 Source Code elemental function digit_I4 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Input integer. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I4","tags":"","loc":"proc/digit_i4.html","title":"digit_I4 – FLOw"},{"text":"private elemental function digit_I8(n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Called By proc~~digit_i8~~CalledByGraph proc~digit_i8 digit_I8 interface~digit digit interface~digit->proc~digit_i8 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code digit_I8 Source Code elemental function digit_I8 ( n ) result ( digit ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of digits in decimal base of the input integer. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Input integer. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. integer ( I4P ) :: digit !< Number of digits. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8P ) abs ( n ) ! Casting of n to string. digit = len_trim ( adjustl ( str )) ! Calculating the digits number of n. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction digit_I8","tags":"","loc":"proc/digit_i8.html","title":"digit_I8 – FLOw"},{"text":"public subroutine check_endian() Check the type of bit ordering (big or little endian) of the running architecture. Note The result is stored into the endian global variable. Arguments None Called By proc~~check_endian~~CalledByGraph proc~check_endian check_endian proc~penf_init penf_init proc~penf_init->proc~check_endian Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code check_endian Source Code subroutine check_endian () !--------------------------------------------------------------------------------------------------------------------------------- !< Check the type of bit ordering (big or little endian) of the running architecture. !< !> @note The result is stored into the *endian* global variable. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( is_little_endian ()) then endian = endianL else endian = endianB endif return !--------------------------------------------------------------------------------------------------------------------------------- contains pure function is_little_endian () result ( is_little ) !------------------------------------------------------------------------------------------------------------------------------- !< Check if the type of the bit ordering of the running architecture is little endian. !------------------------------------------------------------------------------------------------------------------------------- logical :: is_little !< Logical output: true is the running architecture uses little endian ordering, false otherwise. integer ( I1P ) :: int1 ( 1 : 4 ) !< One byte integer array for casting 4 bytes integer. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- int1 = transfer ( 1_I4P , int1 ) is_little = ( int1 ( 1 ) == 1_I1P ) return !------------------------------------------------------------------------------------------------------------------------------- endfunction is_little_endian endsubroutine check_endian","tags":"","loc":"proc/check_endian.html","title":"check_endian – FLOw"},{"text":"public subroutine penf_init() Initialize PENF's variables that are not initialized into the definition specification. Arguments None Calls proc~~penf_init~~CallsGraph proc~penf_init penf_init proc~check_endian check_endian proc~penf_init->proc~check_endian Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code penf_init Source Code subroutine penf_init () !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize PENF's variables that are not initialized into the definition specification. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- call check_endian BIR8P = bit_size ( MaxR8P ) ; BYR8P = BIR8P / 8_I1P BIR4P = bit_size ( MaxR4P ) ; BYR4P = BIR4P / 8_I1P BIR_P = bit_size ( MaxR_P ) ; BYR_P = BIR_P / 8_I1P #ifdef r16p BIR16P = bit_size ( MaxR16P ) ; BYR16P = BIR16P / 8_I2P #else BIR16P = int ( BIR8P , kind = I2P ) ; BYR16P = BIR16P / 8_I2P #endif is_initialized = . true . return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine penf_init","tags":"","loc":"proc/penf_init.html","title":"penf_init – FLOw"},{"text":"public subroutine penf_print(unit, pref, iostat, iomsg) Print to the specified unit the PENF's environment data. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: unit Logic unit. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message. Source Code penf_print Source Code subroutine penf_print ( unit , pref , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Print to the specified unit the PENF's environment data. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: unit !< Logic unit. character ( * ), intent ( in ), optional :: pref !< Prefixing string. integer ( I4P ), intent ( out ), optional :: iostat !< IO error. character ( * ), intent ( out ), optional :: iomsg !< IO error message. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< Temporary variable for IO error message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if (. not . is_initialized ) call penf_init prefd = '' ; if ( present ( pref )) prefd = pref if ( endian == endianL ) then write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' This architecture has LITTLE Endian bit ordering' else write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' This architecture has BIG Endian bit ordering' endif write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals kind, format and characters number:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = R16P ) // ',' // FR16P // ',' // str ( n = DR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = R8P ) // ',' // FR8P // ',' // str ( n = DR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = R4P ) // ',' // FR4P // ',' // str ( n = DR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integers kind, format and characters number:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = I8P ) // ',' // FI8P // ',' // str ( n = DI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = I4P ) // ',' // FI4P // ',' // str ( n = DI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = I2P ) // ',' // FI2P // ',' // str ( n = DI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = I1P ) // ',' // FI1P // ',' // str ( n = DI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals minimum and maximum values:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = MinR16P ) // ',' // str ( n = MaxR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = MinR8P ) // ',' // str ( n = MaxR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = MinR4P ) // ',' // str ( n = MaxR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integergs minimum and maximum values:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = MinI8P ) // ',' // str ( n = MaxI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = MinI4P ) // ',' // str ( n = MaxI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = MinI2P ) // ',' // str ( n = MaxI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = MinI1P ) // ',' // str ( n = MaxI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Reals bits/bytes sizes:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R16P: ' // str ( n = BIR16P ) // '/' // str ( n = BYR16P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R8P:  ' // str ( n = BIR8P ) // '/' // str ( n = BYR8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   R4P:  ' // str ( n = BIR4P ) // '/' // str ( n = BYR4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Integers bits/bytes sizes:' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I8P:  ' // str ( n = BII8P ) // '/' // str ( n = BYI8P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I4P:  ' // str ( n = BII4P ) // '/' // str ( n = BYI4P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I2P:  ' // str ( n = BII2P ) // '/' // str ( n = BYI2P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   I1P:  ' // str ( n = BII1P ) // '/' // str ( n = BYI1P ) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // ' Machine precisions' write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR16: ' // str ( ZeroR16 ,. true .) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR8:  ' // str ( ZeroR8 ,. true .) write ( unit = unit , fmt = '(A)' , iostat = iostatd , iomsg = iomsgd ) prefd // '   ZeroR4:  ' // str ( ZeroR4 ,. true .) if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = iomsgd return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine penf_print","tags":"","loc":"proc/penf_print.html","title":"penf_print – FLOw"},{"text":"public interface bit_size Overloading of the intrinsic bit_size function for computing the number of bits of (also) real and character variables.","tags":"","loc":"interface/bit_size.html","title":"bit_size – FLOw"},{"text":"public interface digit Compute the number of digits in decimal base of the input integer. Calls interface~~digit~~CallsGraph interface~digit digit proc~digit_i2 digit_I2 interface~digit->proc~digit_i2 proc~digit_i1 digit_I1 interface~digit->proc~digit_i1 proc~digit_i8 digit_I8 interface~digit->proc~digit_i8 proc~digit_i4 digit_I4 interface~digit->proc~digit_i4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures digit_I8 digit_I4 digit_I2 digit_I1 Module Procedures private elemental function digit_I8 (n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. private elemental function digit_I4 (n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. private elemental function digit_I2 (n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. private elemental function digit_I1 (n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits.","tags":"","loc":"interface/digit.html","title":"digit – FLOw"},{"text":"private elemental function bit_size_R16P(i) result(bits) Compute the number of bits of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I2P) Number of bits of r. Source Code bit_size_R16P Source Code elemental function bit_size_R16P ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I2P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I2P ) * 8_I2P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R16P","tags":"","loc":"proc/bit_size_r16p.html","title":"bit_size_R16P – FLOw"},{"text":"private elemental function bit_size_R4P(i) result(bits) Compute the number of bits of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Called By proc~~bit_size_r4p~~CalledByGraph proc~bit_size_r4p bit_size_R4P interface~bit_size~2 bit_size interface~bit_size~2->proc~bit_size_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bit_size_R4P Source Code elemental function bit_size_R4P ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I1P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I1P ) * 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R4P","tags":"","loc":"proc/bit_size_r4p.html","title":"bit_size_R4P – FLOw"},{"text":"private elemental function bit_size_R8P(i) result(bits) Compute the number of bits of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. Called By proc~~bit_size_r8p~~CalledByGraph proc~bit_size_r8p bit_size_R8P interface~bit_size~2 bit_size interface~bit_size~2->proc~bit_size_r8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bit_size_R8P Source Code elemental function bit_size_R8P ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: i !< Real variable whose number of bits must be computed. integer ( I1P ) :: bits !< Number of bits of r. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I1P ) * 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_R8P","tags":"","loc":"proc/bit_size_r8p.html","title":"bit_size_R8P – FLOw"},{"text":"private elemental function bit_size_chr(i) result(bits) Compute the number of bits of a character variable. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bits must be computed. Return Value integer(kind=I4P) Number of bits of c. Called By proc~~bit_size_chr~~CalledByGraph proc~bit_size_chr bit_size_chr interface~bit_size~2 bit_size interface~bit_size~2->proc~bit_size_chr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bit_size_chr Source Code elemental function bit_size_chr ( i ) result ( bits ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bits of a character variable. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( IN ) :: i !< Character variable whose number of bits must be computed. integer ( I4P ) :: bits !< Number of bits of c. integer ( I1P ) :: mold ( 1 ) !< \"Molding\" dummy variable for bits counting. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bits = size ( transfer ( i , mold ), dim = 1 , kind = I4P ) * 8_I4P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bit_size_chr","tags":"","loc":"proc/bit_size_chr.html","title":"bit_size_chr – FLOw"},{"text":"private elemental function byte_size_I1P(i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Called By proc~~byte_size_i1p~~CalledByGraph proc~byte_size_i1p byte_size_I1P interface~byte_size byte_size interface~byte_size->proc~byte_size_i1p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code byte_size_I1P Source Code elemental function byte_size_I1P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I1P","tags":"","loc":"proc/byte_size_i1p.html","title":"byte_size_I1P – FLOw"},{"text":"private elemental function byte_size_I2P(i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Called By proc~~byte_size_i2p~~CalledByGraph proc~byte_size_i2p byte_size_I2P interface~byte_size byte_size interface~byte_size->proc~byte_size_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code byte_size_I2P Source Code elemental function byte_size_I2P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I2P","tags":"","loc":"proc/byte_size_i2p.html","title":"byte_size_I2P – FLOw"},{"text":"private elemental function byte_size_I4P(i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Called By proc~~byte_size_i4p~~CalledByGraph proc~byte_size_i4p byte_size_I4P interface~byte_size byte_size interface~byte_size->proc~byte_size_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code byte_size_I4P Source Code elemental function byte_size_I4P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I4P","tags":"","loc":"proc/byte_size_i4p.html","title":"byte_size_I4P – FLOw"},{"text":"private elemental function byte_size_I8P(i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. Called By proc~~byte_size_i8p~~CalledByGraph proc~byte_size_i8p byte_size_I8P interface~byte_size byte_size interface~byte_size->proc~byte_size_i8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code byte_size_I8P Source Code elemental function byte_size_I8P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of an integer variable. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: i !< Integer variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of i. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_I8P","tags":"","loc":"proc/byte_size_i8p.html","title":"byte_size_I8P – FLOw"},{"text":"private elemental function byte_size_R16P(i) result(bytes) Compute the number of bytes of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Source Code byte_size_R16P Source Code elemental function byte_size_R16P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R16P","tags":"","loc":"proc/byte_size_r16p.html","title":"byte_size_R16P – FLOw"},{"text":"private elemental function byte_size_R4P(i) result(bytes) Compute the number of bytes of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Called By proc~~byte_size_r4p~~CalledByGraph proc~byte_size_r4p byte_size_R4P interface~byte_size byte_size interface~byte_size->proc~byte_size_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code byte_size_R4P Source Code elemental function byte_size_R4P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R4P","tags":"","loc":"proc/byte_size_r4p.html","title":"byte_size_R4P – FLOw"},{"text":"private elemental function byte_size_R8P(i) result(bytes) Compute the number of bytes of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. Called By proc~~byte_size_r8p~~CalledByGraph proc~byte_size_r8p byte_size_R8P interface~byte_size byte_size interface~byte_size->proc~byte_size_r8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code byte_size_R8P Source Code elemental function byte_size_R8P ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a real variable. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: i !< Real variable whose number of bytes must be computed. integer ( I1P ) :: bytes !< Number of bytes of r. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I1P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_R8P","tags":"","loc":"proc/byte_size_r8p.html","title":"byte_size_R8P – FLOw"},{"text":"private elemental function byte_size_chr(i) result(bytes) Compute the number of bytes of a character variable. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bytes must be computed. Return Value integer(kind=I4P) Number of bytes of c. Called By proc~~byte_size_chr~~CalledByGraph proc~byte_size_chr byte_size_chr interface~byte_size byte_size interface~byte_size->proc~byte_size_chr Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code byte_size_chr Source Code elemental function byte_size_chr ( i ) result ( bytes ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the number of bytes of a character variable. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: i !< Character variable whose number of bytes must be computed. integer ( I4P ) :: bytes !< Number of bytes of c. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- bytes = bit_size ( i ) / 8_I4P return !--------------------------------------------------------------------------------------------------------------------------------- endfunction byte_size_chr","tags":"","loc":"proc/byte_size_chr.html","title":"byte_size_chr – FLOw"},{"text":"public interface bit_size Overloading of the intrinsic bit_size function for computing the number of bits of (also) real and character variables. Calls interface~~bit_size~2~~CallsGraph interface~bit_size~2 bit_size proc~bit_size_r8p bit_size_R8P interface~bit_size~2->proc~bit_size_r8p proc~bit_size_chr bit_size_chr interface~bit_size~2->proc~bit_size_chr proc~bit_size_r4p bit_size_R4P interface~bit_size~2->proc~bit_size_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures bit_size_R8P bit_size_R4P bit_size_chr Module Procedures private elemental function bit_size_R8P (i) result(bits) Compute the number of bits of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. private elemental function bit_size_R4P (i) result(bits) Compute the number of bits of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. private elemental function bit_size_chr (i) result(bits) Compute the number of bits of a character variable. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bits must be computed. Return Value integer(kind=I4P) Number of bits of c.","tags":"","loc":"interface/bit_size~2.html","title":"bit_size – FLOw"},{"text":"public interface byte_size Compute the number of bytes of a variable. Calls interface~~byte_size~~CallsGraph interface~byte_size byte_size proc~byte_size_r8p byte_size_R8P interface~byte_size->proc~byte_size_r8p proc~byte_size_i4p byte_size_I4P interface~byte_size->proc~byte_size_i4p proc~byte_size_i8p byte_size_I8P interface~byte_size->proc~byte_size_i8p proc~byte_size_chr byte_size_chr interface~byte_size->proc~byte_size_chr proc~byte_size_i1p byte_size_I1P interface~byte_size->proc~byte_size_i1p proc~byte_size_i2p byte_size_I2P interface~byte_size->proc~byte_size_i2p proc~byte_size_r4p byte_size_R4P interface~byte_size->proc~byte_size_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures byte_size_I8P byte_size_I4P byte_size_I2P byte_size_I1P byte_size_R8P byte_size_R4P byte_size_chr Module Procedures private elemental function byte_size_I8P (i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. private elemental function byte_size_I4P (i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. private elemental function byte_size_I2P (i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. private elemental function byte_size_I1P (i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. private elemental function byte_size_R8P (i) result(bytes) Compute the number of bytes of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. private elemental function byte_size_R4P (i) result(bytes) Compute the number of bytes of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. private elemental function byte_size_chr (i) result(bytes) Compute the number of bytes of a character variable. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bytes must be computed. Return Value integer(kind=I4P) Number of bytes of c.","tags":"","loc":"interface/byte_size.html","title":"byte_size – FLOw"},{"text":"private elemental function bctoi_I1P(bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. Return Value integer(kind=I1P) Number returned. Calls proc~~bctoi_i1p~~CallsGraph proc~bctoi_i1p bctoi_I1P interface~str str proc~bctoi_i1p->interface~str proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_bol str_bol interface~str->proc~str_bol proc~str_a_i4p->proc~str_i4p proc~str_a_i8p->proc~str_i8p proc~compact_real_string compact_real_string proc~str_r8p->proc~compact_real_string proc~str_a_r4p->proc~str_r4p proc~str_a_i1p->proc~str_i1p proc~str_a_r8p->proc~str_r8p proc~str_a_i2p->proc~str_i2p proc~str_r4p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~bctoi_i1p~~CalledByGraph proc~bctoi_i1p bctoi_I1P interface~bcton bcton interface~bcton->proc~bctoi_i1p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bctoi_I1P Source Code elemental function bctoi_I1P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I1P ), intent ( in ) :: knd !< Number kind. integer ( I1P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I1P","tags":"","loc":"proc/bctoi_i1p.html","title":"bctoi_I1P – FLOw"},{"text":"private elemental function bctoi_I2P(bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. Return Value integer(kind=I2P) Number returned. Calls proc~~bctoi_i2p~~CallsGraph proc~bctoi_i2p bctoi_I2P interface~str str proc~bctoi_i2p->interface~str proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_bol str_bol interface~str->proc~str_bol proc~str_a_i4p->proc~str_i4p proc~str_a_i8p->proc~str_i8p proc~compact_real_string compact_real_string proc~str_r8p->proc~compact_real_string proc~str_a_r4p->proc~str_r4p proc~str_a_i1p->proc~str_i1p proc~str_a_r8p->proc~str_r8p proc~str_a_i2p->proc~str_i2p proc~str_r4p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~bctoi_i2p~~CalledByGraph proc~bctoi_i2p bctoi_I2P interface~bcton bcton interface~bcton->proc~bctoi_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bctoi_I2P Source Code elemental function bctoi_I2P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I2P ), intent ( in ) :: knd !< Number kind. integer ( I2P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I2P","tags":"","loc":"proc/bctoi_i2p.html","title":"bctoi_I2P – FLOw"},{"text":"private elemental function bctoi_I4P(bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. Return Value integer(kind=I4P) Number returned. Calls proc~~bctoi_i4p~~CallsGraph proc~bctoi_i4p bctoi_I4P interface~str str proc~bctoi_i4p->interface~str proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_bol str_bol interface~str->proc~str_bol proc~str_a_i4p->proc~str_i4p proc~str_a_i8p->proc~str_i8p proc~compact_real_string compact_real_string proc~str_r8p->proc~compact_real_string proc~str_a_r4p->proc~str_r4p proc~str_a_i1p->proc~str_i1p proc~str_a_r8p->proc~str_r8p proc~str_a_i2p->proc~str_i2p proc~str_r4p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~bctoi_i4p~~CalledByGraph proc~bctoi_i4p bctoi_I4P interface~bcton bcton interface~bcton->proc~bctoi_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bctoi_I4P Source Code elemental function bctoi_I4P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I4P ), intent ( in ) :: knd !< Number kind. integer ( I4P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I4P","tags":"","loc":"proc/bctoi_i4p.html","title":"bctoi_I4P – FLOw"},{"text":"private elemental function bctoi_I8P(bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. Return Value integer(kind=I8P) Number returned. Calls proc~~bctoi_i8p~~CallsGraph proc~bctoi_i8p bctoi_I8P interface~str str proc~bctoi_i8p->interface~str proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_bol str_bol interface~str->proc~str_bol proc~str_a_i4p->proc~str_i4p proc~str_a_i8p->proc~str_i8p proc~compact_real_string compact_real_string proc~str_r8p->proc~compact_real_string proc~str_a_r4p->proc~str_r4p proc~str_a_i1p->proc~str_i1p proc~str_a_r8p->proc~str_r8p proc~str_a_i2p->proc~str_i2p proc~str_r4p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~bctoi_i8p~~CalledByGraph proc~bctoi_i8p bctoi_I8P interface~bcton bcton interface~bcton->proc~bctoi_i8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bctoi_I8P Source Code elemental function bctoi_I8P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. integer ( I8P ), intent ( in ) :: knd !< Number kind. integer ( I8P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctoi_I8P","tags":"","loc":"proc/bctoi_i8p.html","title":"bctoi_I8P – FLOw"},{"text":"private elemental function bctor_R16P(bstr, knd) result(n) Convert bit-string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R16P), intent(in) :: knd Number kind. Return Value real(kind=R16P) Number returned. Calls proc~~bctor_r16p~~CallsGraph proc~bctor_r16p bctor_R16P interface~str str proc~bctor_r16p->interface~str proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_bol str_bol interface~str->proc~str_bol proc~str_a_i4p->proc~str_i4p proc~str_a_i8p->proc~str_i8p proc~compact_real_string compact_real_string proc~str_r8p->proc~compact_real_string proc~str_a_r4p->proc~str_r4p proc~str_a_i1p->proc~str_i1p proc~str_a_r8p->proc~str_r8p proc~str_a_i2p->proc~str_i2p proc~str_r4p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bctor_R16P Source Code elemental function bctor_R16P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R16P ), intent ( in ) :: knd !< Number kind. real ( R16P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R16P","tags":"","loc":"proc/bctor_r16p.html","title":"bctor_R16P – FLOw"},{"text":"private elemental function bctor_R4P(bstr, knd) result(n) Convert bit-string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R4P), intent(in) :: knd Number kind. Return Value real(kind=R4P) Number returned. Calls proc~~bctor_r4p~~CallsGraph proc~bctor_r4p bctor_R4P interface~str str proc~bctor_r4p->interface~str proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_bol str_bol interface~str->proc~str_bol proc~str_a_i4p->proc~str_i4p proc~str_a_i8p->proc~str_i8p proc~compact_real_string compact_real_string proc~str_r8p->proc~compact_real_string proc~str_a_r4p->proc~str_r4p proc~str_a_i1p->proc~str_i1p proc~str_a_r8p->proc~str_r8p proc~str_a_i2p->proc~str_i2p proc~str_r4p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~bctor_r4p~~CalledByGraph proc~bctor_r4p bctor_R4P interface~bcton bcton interface~bcton->proc~bctor_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bctor_R4P Source Code elemental function bctor_R4P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R4P ), intent ( in ) :: knd !< Number kind. real ( R4P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R4P","tags":"","loc":"proc/bctor_r4p.html","title":"bctor_R4P – FLOw"},{"text":"private elemental function bctor_R8P(bstr, knd) result(n) Convert bit-string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R8P), intent(in) :: knd Number kind. Return Value real(kind=R8P) Number returned. Calls proc~~bctor_r8p~~CallsGraph proc~bctor_r8p bctor_R8P interface~str str proc~bctor_r8p->interface~str proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_bol str_bol interface~str->proc~str_bol proc~str_a_i4p->proc~str_i4p proc~str_a_i8p->proc~str_i8p proc~compact_real_string compact_real_string proc~str_r8p->proc~compact_real_string proc~str_a_r4p->proc~str_r4p proc~str_a_i1p->proc~str_i1p proc~str_a_r8p->proc~str_r8p proc~str_a_i2p->proc~str_i2p proc~str_r4p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~bctor_r8p~~CalledByGraph proc~bctor_r8p bctor_R8P interface~bcton bcton interface~bcton->proc~bctor_r8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bctor_R8P Source Code elemental function bctor_R8P ( bstr , knd ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert bit-string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: bstr !< String containing input number. real ( R8P ), intent ( in ) :: knd !< Number kind. real ( R8P ) :: n !< Number returned. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( bstr , '(B' // trim ( str ( bit_size ( knd ), . true .)) // '.' // trim ( str ( bit_size ( knd ), . true .)) // ')' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bctor_R8P","tags":"","loc":"proc/bctor_r8p.html","title":"bctor_R8P – FLOw"},{"text":"private elemental function bstr_I1P(n) result(bstr) Convert integer to string of bits. Note It is assumed that I1P is represented by means of 8 bits, but this is not ensured in all architectures. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Real to be converted. Return Value character(len=8) Returned bit-string containing input number. Called By proc~~bstr_i1p~~CalledByGraph proc~bstr_i1p bstr_I1P interface~bstr bstr interface~bstr->proc~bstr_i1p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bstr_I1P Source Code elemental function bstr_I1P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I1P is represented by means of 8 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Real to be converted. character ( 8 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B8.8)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I1P","tags":"","loc":"proc/bstr_i1p.html","title":"bstr_I1P – FLOw"},{"text":"private elemental function bstr_I2P(n) result(bstr) Convert integer to string of bits. Note It is assumed that I2P is represented by means of 16 bits, but this is not ensured in all architectures. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Real to be converted. Return Value character(len=16) Returned bit-string containing input number. Called By proc~~bstr_i2p~~CalledByGraph proc~bstr_i2p bstr_I2P interface~bstr bstr interface~bstr->proc~bstr_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bstr_I2P Source Code elemental function bstr_I2P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I2P is represented by means of 16 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Real to be converted. character ( 16 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B16.16)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I2P","tags":"","loc":"proc/bstr_i2p.html","title":"bstr_I2P – FLOw"},{"text":"private elemental function bstr_I4P(n) result(bstr) Convert integer to string of bits. Note It is assumed that I4P is represented by means of 32 bits, but this is not ensured in all architectures. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Called By proc~~bstr_i4p~~CalledByGraph proc~bstr_i4p bstr_I4P interface~bstr bstr interface~bstr->proc~bstr_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bstr_I4P Source Code elemental function bstr_I4P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I4P is represented by means of 32 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Real to be converted. character ( 32 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B32.32)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I4P","tags":"","loc":"proc/bstr_i4p.html","title":"bstr_I4P – FLOw"},{"text":"private elemental function bstr_I8P(n) result(bstr) Convert integer to string of bits. Note It is assumed that I8P is represented by means of 64 bits, but this is not ensured in all architectures. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Called By proc~~bstr_i8p~~CalledByGraph proc~bstr_i8p bstr_I8P interface~bstr bstr interface~bstr->proc~bstr_i8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bstr_I8P Source Code elemental function bstr_I8P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string of bits. !< !< @note It is assumed that I8P is represented by means of 64 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Real to be converted. character ( 64 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B64.64)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_I8P","tags":"","loc":"proc/bstr_i8p.html","title":"bstr_I8P – FLOw"},{"text":"private elemental function bstr_R16P(n) result(bstr) Convert real to string of bits. Note It is assumed that R16P is represented by means of 128 bits, but this is not ensured in all architectures. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n Real to be converted. Return Value character(len=128) Returned bit-string containing input number. Source Code bstr_R16P Source Code elemental function bstr_R16P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string of bits. !< !< @note It is assumed that R16P is represented by means of 128 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n !< Real to be converted. character ( 128 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B128.128)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R16P","tags":"","loc":"proc/bstr_r16p.html","title":"bstr_R16P – FLOw"},{"text":"private elemental function bstr_R4P(n) result(bstr) Convert real to string of bits. Note It is assumed that R4P is represented by means of 32 bits, but this is not ensured in all architectures. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. Called By proc~~bstr_r4p~~CalledByGraph proc~bstr_r4p bstr_R4P interface~bstr bstr interface~bstr->proc~bstr_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bstr_R4P Source Code elemental function bstr_R4P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string of bits. !< !< @note It is assumed that R4P is represented by means of 32 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n !< Real to be converted. character ( 32 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B32.32)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R4P","tags":"","loc":"proc/bstr_r4p.html","title":"bstr_R4P – FLOw"},{"text":"private elemental function bstr_R8P(n) result(bstr) Convert real to string of bits. Note It is assumed that R8P is represented by means of 64 bits, but this is not ensured in all architectures. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. Called By proc~~bstr_r8p~~CalledByGraph proc~bstr_r8p bstr_R8P interface~bstr bstr interface~bstr->proc~bstr_r8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code bstr_R8P Source Code elemental function bstr_R8P ( n ) result ( bstr ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string of bits. !< !< @note It is assumed that R8P is represented by means of 64 bits, but this is not ensured in all architectures. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n !< Real to be converted. character ( 64 ) :: bstr !< Returned bit-string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( bstr , '(B64.64)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction bstr_R8P","tags":"","loc":"proc/bstr_r8p.html","title":"bstr_R8P – FLOw"},{"text":"private function ctoi_I1P(str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I1P) Number returned. Called By proc~~ctoi_i1p~~CalledByGraph proc~ctoi_i1p ctoi_I1P interface~cton cton interface~cton->proc~ctoi_i1p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code ctoi_I1P Source Code function ctoi_I1P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I1P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I1P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I1P","tags":"","loc":"proc/ctoi_i1p.html","title":"ctoi_I1P – FLOw"},{"text":"private function ctoi_I2P(str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I2P) Number returned. Called By proc~~ctoi_i2p~~CalledByGraph proc~ctoi_i2p ctoi_I2P interface~cton cton interface~cton->proc~ctoi_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code ctoi_I2P Source Code function ctoi_I2P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I2P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I2P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I2P","tags":"","loc":"proc/ctoi_i2p.html","title":"ctoi_I2P – FLOw"},{"text":"private function ctoi_I4P(str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I4P) Number returned. Called By proc~~ctoi_i4p~~CalledByGraph proc~ctoi_i4p ctoi_I4P interface~cton cton interface~cton->proc~ctoi_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code ctoi_I4P Source Code function ctoi_I4P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I4P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I4P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I4P","tags":"","loc":"proc/ctoi_i4p.html","title":"ctoi_I4P – FLOw"},{"text":"private function ctoi_I8P(str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I8P) Number returned. Called By proc~~ctoi_i8p~~CalledByGraph proc~ctoi_i8p ctoi_I8P interface~cton cton interface~cton->proc~ctoi_i8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code ctoi_I8P Source Code function ctoi_I8P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to integer. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. integer ( I8P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. integer ( I8P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to integer failed! integer(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctoi_I8P","tags":"","loc":"proc/ctoi_i8p.html","title":"ctoi_I8P – FLOw"},{"text":"private function ctor_R16P(str, knd, pref, error) result(n) Convert string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R16P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R16P) Number returned. Source Code ctor_R16P Source Code function ctor_R16P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. real ( R16P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R16P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R16P","tags":"","loc":"proc/ctor_r16p.html","title":"ctor_R16P – FLOw"},{"text":"private function ctor_R4P(str, knd, pref, error) result(n) Convert string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R4P) Number returned. Called By proc~~ctor_r4p~~CalledByGraph proc~ctor_r4p ctor_R4P interface~cton cton interface~cton->proc~ctor_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code ctor_R4P Source Code function ctor_R4P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. real ( R4P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R4P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R4P","tags":"","loc":"proc/ctor_r4p.html","title":"ctor_R4P – FLOw"},{"text":"private function ctor_R8P(str, knd, pref, error) result(n) Convert string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R8P) Number returned. Called By proc~~ctor_r8p~~CalledByGraph proc~ctor_r8p ctor_R8P interface~cton cton interface~cton->proc~ctor_r8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code ctor_R8P Source Code function ctor_R8P ( str , knd , pref , error ) result ( n ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert string to real. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: str !< String containing input number. real ( R8P ), intent ( in ) :: knd !< Number kind. character ( * ), optional , intent ( in ) :: pref !< Prefixing string. integer ( I4P ), optional , intent ( out ) :: error !< Error trapping flag: 0 no errors, >0 error occurs. real ( R8P ) :: n !< Number returned. integer ( I4P ) :: err !< Error trapping flag: 0 no errors, >0 error occurs. character ( len = :), allocatable :: prefd !< Prefixing string. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- read ( str , * , iostat = err ) n ! Casting of str to n. if ( err /= 0 ) then prefd = '' ; if ( present ( pref )) prefd = pref write ( stderr , '(A,I1,A)' ) prefd // ' Error: conversion of string \"' // str // '\" to real failed! real(' , kind ( knd ), ')' endif if ( present ( error )) error = err return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ctor_R8P","tags":"","loc":"proc/ctor_r8p.html","title":"ctor_R8P – FLOw"},{"text":"private elemental function str_I1P(n, no_sign) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Called By proc~~str_i1p~~CalledByGraph proc~str_i1p str_I1P proc~str_a_i1p str_a_I1P proc~str_a_i1p->proc~str_i1p interface~str str interface~str->proc~str_i1p interface~str->proc~str_a_i1p proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~description~2 description proc~description~2->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~description~4 description proc~description~4->interface~str proc~description_vectorial description_vectorial proc~description_vectorial->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~description~3 description proc~description~3->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~description description proc~description->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~description_scalar description_scalar proc~description_scalar->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_I1P Source Code elemental function str_I1P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I1P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I1P","tags":"","loc":"proc/str_i1p.html","title":"str_I1P – FLOw"},{"text":"private elemental function str_I2P(n, no_sign) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Called By proc~~str_i2p~~CalledByGraph proc~str_i2p str_I2P proc~str_a_i2p str_a_I2P proc~str_a_i2p->proc~str_i2p interface~str str interface~str->proc~str_i2p interface~str->proc~str_a_i2p proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~description~2 description proc~description~2->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~description~4 description proc~description~4->interface~str proc~description_vectorial description_vectorial proc~description_vectorial->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~description~3 description proc~description~3->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~description description proc~description->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~description_scalar description_scalar proc~description_scalar->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_I2P Source Code elemental function str_I2P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I2P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I2P","tags":"","loc":"proc/str_i2p.html","title":"str_I2P – FLOw"},{"text":"private elemental function str_I4P(n, no_sign) result(str) Converting integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Called By proc~~str_i4p~~CalledByGraph proc~str_i4p str_I4P proc~str_a_i4p str_a_I4P proc~str_a_i4p->proc~str_i4p interface~str str interface~str->proc~str_i4p interface~str->proc~str_a_i4p proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~description~2 description proc~description~2->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~description~4 description proc~description~4->interface~str proc~description_vectorial description_vectorial proc~description_vectorial->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~description~3 description proc~description~3->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~description description proc~description->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~description_scalar description_scalar proc~description_scalar->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_I4P Source Code elemental function str_I4P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Converting integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I4P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I4P","tags":"","loc":"proc/str_i4p.html","title":"str_I4P – FLOw"},{"text":"private elemental function str_I8P(n, no_sign) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Called By proc~~str_i8p~~CalledByGraph proc~str_i8p str_I8P proc~str_a_i8p str_a_I8P proc~str_a_i8p->proc~str_i8p interface~str str interface~str->proc~str_i8p interface~str->proc~str_a_i8p proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~description~2 description proc~description~2->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~description~4 description proc~description~4->interface~str proc~description_vectorial description_vectorial proc~description_vectorial->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~description~3 description proc~description~3->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~description description proc~description->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~description_scalar description_scalar proc~description_scalar->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_I8P Source Code elemental function str_I8P ( n , no_sign ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Integer to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8P ) n ! Casting of n to string. str = adjustl ( trim ( str )) ! Removing white spaces. if ( n >= 0_I8P ) str = '+' // trim ( str ) ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_I8P","tags":"","loc":"proc/str_i8p.html","title":"str_I8P – FLOw"},{"text":"private elemental function str_R16P(n, no_sign, compact) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=DR16P) Returned string containing input number. Calls proc~~str_r16p~~CallsGraph proc~str_r16p str_R16P proc~compact_real_string compact_real_string proc~str_r16p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~str_r16p~~CalledByGraph proc~str_r16p str_R16P proc~str_a_r16p str_a_R16P proc~str_a_r16p->proc~str_r16p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_R16P Source Code elemental function str_R16P ( n , no_sign , compact ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. logical , intent ( in ), optional :: compact !< Flag for *compacting* string encoding. character ( DR16P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR16P ) n ! Casting of n to string. if ( n > 0._R16P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. if ( present ( compact )) then if ( compact ) call compact_real_string ( string = str ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R16P","tags":"","loc":"proc/str_r16p.html","title":"str_R16P – FLOw"},{"text":"private elemental function str_R4P(n, no_sign, compact) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=DR4P) Returned string containing input number. Calls proc~~str_r4p~~CallsGraph proc~str_r4p str_R4P proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~str_r4p~~CalledByGraph proc~str_r4p str_R4P proc~str_a_r4p str_a_R4P proc~str_a_r4p->proc~str_r4p interface~str str interface~str->proc~str_r4p interface~str->proc~str_a_r4p proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~description~2 description proc~description~2->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~description~4 description proc~description~4->interface~str proc~description_vectorial description_vectorial proc~description_vectorial->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~description~3 description proc~description~3->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~description description proc~description->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~description_scalar description_scalar proc~description_scalar->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_R4P Source Code elemental function str_R4P ( n , no_sign , compact ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. logical , intent ( in ), optional :: compact !< Flag for *compacting* string encoding. character ( DR4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR4P ) n ! Casting of n to string. if ( n > 0._R4P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. if ( present ( compact )) then if ( compact ) call compact_real_string ( string = str ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R4P","tags":"","loc":"proc/str_r4p.html","title":"str_R4P – FLOw"},{"text":"private elemental function str_R8P(n, no_sign, compact) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=DR8P) Returned string containing input number. Calls proc~~str_r8p~~CallsGraph proc~str_r8p str_R8P proc~compact_real_string compact_real_string proc~str_r8p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~str_r8p~~CalledByGraph proc~str_r8p str_R8P proc~str_a_r8p str_a_R8P proc~str_a_r8p->proc~str_r8p interface~str str interface~str->proc~str_r8p interface~str->proc~str_a_r8p proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~description~2 description proc~description~2->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~description~4 description proc~description~4->interface~str proc~description_vectorial description_vectorial proc~description_vectorial->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~description~3 description proc~description~3->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~description description proc~description->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~description_scalar description_scalar proc~description_scalar->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_R8P Source Code elemental function str_R8P ( n , no_sign , compact ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n !< Real to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. logical , intent ( in ), optional :: compact !< Flag for *compacting* string encoding. character ( DR8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FR8P ) n ! Casting of n to string. if ( n > 0._R8P ) str ( 1 : 1 ) = '+' ! Prefixing plus if n>0. if ( present ( no_sign )) str = str ( 2 :) ! Leaving out the sign. if ( present ( compact )) then if ( compact ) call compact_real_string ( string = str ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_R8P","tags":"","loc":"proc/str_r8p.html","title":"str_R8P – FLOw"},{"text":"private pure function str_a_I1P(n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Calls proc~~str_a_i1p~~CallsGraph proc~str_a_i1p str_a_I1P proc~str_i1p str_I1P proc~str_a_i1p->proc~str_i1p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~str_a_i1p~~CalledByGraph proc~str_a_i1p str_a_I1P interface~str str interface~str->proc~str_a_i1p proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~description~2 description proc~description~2->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~description~4 description proc~description~4->interface~str proc~description_vectorial description_vectorial proc~description_vectorial->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~description~3 description proc~description~3->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~description description proc~description->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~description_scalar description_scalar proc~description_scalar->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_a_I1P Source Code pure function str_a_I1P ( n , no_sign , separator , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI1P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- str = '' sep = ',' if ( present ( separator )) sep = separator if ( present ( no_sign )) then do i = 1 , size ( n ) strn = str_I1P ( no_sign = no_sign , n = n ( i )) str = str // sep // trim ( strn ) enddo else do i = 1 , size ( n ) strn = str_I1P ( n = n ( i )) str = str // sep // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I1P","tags":"","loc":"proc/str_a_i1p.html","title":"str_a_I1P – FLOw"},{"text":"private pure function str_a_I2P(n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Calls proc~~str_a_i2p~~CallsGraph proc~str_a_i2p str_a_I2P proc~str_i2p str_I2P proc~str_a_i2p->proc~str_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~str_a_i2p~~CalledByGraph proc~str_a_i2p str_a_I2P interface~str str interface~str->proc~str_a_i2p proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~description~2 description proc~description~2->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~description~4 description proc~description~4->interface~str proc~description_vectorial description_vectorial proc~description_vectorial->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~description~3 description proc~description~3->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~description description proc~description->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~description_scalar description_scalar proc~description_scalar->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_a_I2P Source Code pure function str_a_I2P ( n , no_sign , separator , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI2P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- str = '' sep = ',' if ( present ( separator )) sep = separator if ( present ( no_sign )) then do i = 1 , size ( n ) strn = str_I2P ( no_sign = no_sign , n = n ( i )) str = str // sep // trim ( strn ) enddo else do i = 1 , size ( n ) strn = str_I2P ( n = n ( i )) str = str // sep // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I2P","tags":"","loc":"proc/str_a_i2p.html","title":"str_a_I2P – FLOw"},{"text":"private pure function str_a_I4P(n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Calls proc~~str_a_i4p~~CallsGraph proc~str_a_i4p str_a_I4P proc~str_i4p str_I4P proc~str_a_i4p->proc~str_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~str_a_i4p~~CalledByGraph proc~str_a_i4p str_a_I4P interface~str str interface~str->proc~str_a_i4p proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~description~2 description proc~description~2->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~description~4 description proc~description~4->interface~str proc~description_vectorial description_vectorial proc~description_vectorial->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~description~3 description proc~description~3->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~description description proc~description->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~description_scalar description_scalar proc~description_scalar->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_a_I4P Source Code pure function str_a_I4P ( n , no_sign , separator , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI4P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- str = '' sep = ',' if ( present ( separator )) sep = separator if ( present ( no_sign )) then do i = 1 , size ( n ) strn = str_I4P ( no_sign = no_sign , n = n ( i )) str = str // sep // trim ( strn ) enddo else do i = 1 , size ( n ) strn = str_I4P ( n = n ( i )) str = str // sep // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I4P","tags":"","loc":"proc/str_a_i4p.html","title":"str_a_I4P – FLOw"},{"text":"private pure function str_a_I8P(n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. Calls proc~~str_a_i8p~~CallsGraph proc~str_a_i8p str_a_I8P proc~str_i8p str_I8P proc~str_a_i8p->proc~str_i8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~str_a_i8p~~CalledByGraph proc~str_a_i8p str_a_I8P interface~str str interface~str->proc~str_a_i8p proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~description~2 description proc~description~2->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~description~4 description proc~description~4->interface~str proc~description_vectorial description_vectorial proc~description_vectorial->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~description~3 description proc~description~3->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~description description proc~description->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~description_scalar description_scalar proc~description_scalar->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_a_I8P Source Code pure function str_a_I8P ( n , no_sign , separator , delimiters ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer array to string. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n (:) !< Integer array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DI8P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- str = '' sep = ',' if ( present ( separator )) sep = separator if ( present ( no_sign )) then do i = 1 , size ( n ) strn = str_I8P ( no_sign = no_sign , n = n ( i )) str = str // sep // trim ( strn ) enddo else do i = 1 , size ( n ) strn = str_I8P ( n = n ( i )) str = str // sep // trim ( strn ) enddo endif str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_I8P","tags":"","loc":"proc/str_a_i8p.html","title":"str_a_I8P – FLOw"},{"text":"private pure function str_a_R16P(n, no_sign, separator, delimiters, compact) result(str) Converting real array to string. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator (1) Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=:),\n  allocatable Returned string containing input number. Calls proc~~str_a_r16p~~CallsGraph proc~str_a_r16p str_a_R16P proc~str_r16p str_R16P proc~str_a_r16p->proc~str_r16p proc~compact_real_string compact_real_string proc~str_r16p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_a_R16P Source Code pure function str_a_R16P ( n , no_sign , separator , delimiters , compact ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Converting real array to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator ( 1 ) !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. logical , intent ( in ), optional :: compact !< Flag for *compacting* string encoding. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR16P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- str = '' sep = ',' if ( present ( separator )) sep = separator ( 1 ) do i = 1 , size ( n ) strn = str_R16P ( no_sign = no_sign , compact = compact , n = n ( i )) str = str // sep // trim ( strn ) enddo str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R16P","tags":"","loc":"proc/str_a_r16p.html","title":"str_a_R16P – FLOw"},{"text":"private pure function str_a_R4P(n, no_sign, separator, delimiters, compact) result(str) Convert real array to string. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=:),\n  allocatable Returned string containing input number. Calls proc~~str_a_r4p~~CallsGraph proc~str_a_r4p str_a_R4P proc~str_r4p str_R4P proc~str_a_r4p->proc~str_r4p proc~compact_real_string compact_real_string proc~str_r4p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~str_a_r4p~~CalledByGraph proc~str_a_r4p str_a_R4P interface~str str interface~str->proc~str_a_r4p proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~description~2 description proc~description~2->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~description~4 description proc~description~4->interface~str proc~description_vectorial description_vectorial proc~description_vectorial->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~description~3 description proc~description~3->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~description description proc~description->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~description_scalar description_scalar proc~description_scalar->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_a_R4P Source Code pure function str_a_R4P ( n , no_sign , separator , delimiters , compact ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real array to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. logical , intent ( in ), optional :: compact !< Flag for *compacting* string encoding. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR4P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- str = '' sep = ',' if ( present ( separator )) sep = separator do i = 1 , size ( n ) strn = str_R4P ( no_sign = no_sign , compact = compact , n = n ( i )) str = str // sep // trim ( strn ) enddo str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R4P","tags":"","loc":"proc/str_a_r4p.html","title":"str_a_R4P – FLOw"},{"text":"private pure function str_a_R8P(n, no_sign, separator, delimiters, compact) result(str) Convert real array to string. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=:),\n  allocatable Returned string containing input number. Calls proc~~str_a_r8p~~CallsGraph proc~str_a_r8p str_a_R8P proc~str_r8p str_R8P proc~str_a_r8p->proc~str_r8p proc~compact_real_string compact_real_string proc~str_r8p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~str_a_r8p~~CalledByGraph proc~str_a_r8p str_a_R8P interface~str str interface~str->proc~str_a_r8p proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~description~2 description proc~description~2->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~description~4 description proc~description~4->interface~str proc~description_vectorial description_vectorial proc~description_vectorial->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~description~3 description proc~description~3->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~description description proc~description->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~description_scalar description_scalar proc~description_scalar->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_a_R8P Source Code pure function str_a_R8P ( n , no_sign , separator , delimiters , compact ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real array to string. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( in ) :: n (:) !< Real array to be converted. logical , intent ( in ), optional :: no_sign !< Flag for leaving out the sign. character ( 1 ), intent ( in ), optional :: separator !< Eventual separator of array values. character ( * ), intent ( in ), optional :: delimiters ( 1 : 2 ) !< Eventual delimiters of array values. logical , intent ( in ), optional :: compact !< Flag for *compacting* string encoding. character ( len = :), allocatable :: str !< Returned string containing input number. character ( DR8P ) :: strn !< String containing of element of input array number. character ( len = 1 ) :: sep !< Array values separator integer :: i !< Counter. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- str = '' sep = ',' if ( present ( separator )) sep = separator do i = 1 , size ( n ) strn = str_R8P ( no_sign = no_sign , compact = compact , n = n ( i )) str = str // sep // trim ( strn ) enddo str = trim ( str ( 2 :)) if ( present ( delimiters )) str = delimiters ( 1 ) // str // delimiters ( 2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_a_R8P","tags":"","loc":"proc/str_a_r8p.html","title":"str_a_R8P – FLOw"},{"text":"private elemental function str_bol(n) result(str) Convert logical to string. Arguments Type Intent Optional Attributes Name logical, intent(in) :: n Logical to be converted. Return Value character(len=1) Returned string containing input number plus padding zeros. Called By proc~~str_bol~~CalledByGraph proc~str_bol str_bol interface~str str interface~str->proc~str_bol proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~description~2 description proc~description~2->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~description~4 description proc~description~4->interface~str proc~description_vectorial description_vectorial proc~description_vectorial->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~description~3 description proc~description~3->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~description description proc~description->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~description_scalar description_scalar proc~description_scalar->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code str_bol Source Code elemental function str_bol ( n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert logical to string. !--------------------------------------------------------------------------------------------------------------------------------- logical , intent ( in ) :: n !< Logical to be converted. character ( 1 ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , '(L1)' ) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction str_bol","tags":"","loc":"proc/str_bol.html","title":"str_bol – FLOw"},{"text":"private elemental function strf_I1P(fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number. Called By proc~~strf_i1p~~CalledByGraph proc~strf_i1p strf_I1P interface~str str interface~str->proc~strf_i1p proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~description~2 description proc~description~2->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~description~4 description proc~description~4->interface~str proc~description_vectorial description_vectorial proc~description_vectorial->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~description~3 description proc~description~3->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~description description proc~description->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~description_scalar description_scalar proc~description_scalar->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code strf_I1P Source Code elemental function strf_I1P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I1P ), intent ( in ) :: n !< Integer to be converted. character ( DI1P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I1P","tags":"","loc":"proc/strf_i1p.html","title":"strf_I1P – FLOw"},{"text":"private elemental function strf_I2P(fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number. Called By proc~~strf_i2p~~CalledByGraph proc~strf_i2p strf_I2P interface~str str interface~str->proc~strf_i2p proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~description~2 description proc~description~2->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~description~4 description proc~description~4->interface~str proc~description_vectorial description_vectorial proc~description_vectorial->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~description~3 description proc~description~3->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~description description proc~description->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~description_scalar description_scalar proc~description_scalar->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code strf_I2P Source Code elemental function strf_I2P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I2P ), intent ( in ) :: n !< Integer to be converted. character ( DI2P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I2P","tags":"","loc":"proc/strf_i2p.html","title":"strf_I2P – FLOw"},{"text":"private elemental function strf_I4P(fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number. Called By proc~~strf_i4p~~CalledByGraph proc~strf_i4p strf_I4P interface~str str interface~str->proc~strf_i4p proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~description~2 description proc~description~2->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~description~4 description proc~description~4->interface~str proc~description_vectorial description_vectorial proc~description_vectorial->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~description~3 description proc~description~3->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~description description proc~description->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~description_scalar description_scalar proc~description_scalar->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code strf_I4P Source Code elemental function strf_I4P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I4P ), intent ( in ) :: n !< Integer to be converted. character ( DI4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I4P","tags":"","loc":"proc/strf_i4p.html","title":"strf_I4P – FLOw"},{"text":"private elemental function strf_I8P(fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number. Called By proc~~strf_i8p~~CalledByGraph proc~strf_i8p strf_I8P interface~str str interface~str->proc~strf_i8p proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~description~2 description proc~description~2->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~description~4 description proc~description~4->interface~str proc~description_vectorial description_vectorial proc~description_vectorial->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~description~3 description proc~description~3->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~description description proc~description->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~description_scalar description_scalar proc~description_scalar->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code strf_I8P Source Code elemental function strf_I8P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. integer ( I8P ), intent ( in ) :: n !< Integer to be converted. character ( DI8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_I8P","tags":"","loc":"proc/strf_i8p.html","title":"strf_I8P – FLOw"},{"text":"private elemental function strf_R16P(fm, n) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R16P), intent(in) :: n Real to be converted. Return Value character(len=DR16P) Returned string containing input number. Source Code strf_R16P Source Code elemental function strf_R16P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R16P ), intent ( in ) :: n !< Real to be converted. character ( DR16P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R16P","tags":"","loc":"proc/strf_r16p.html","title":"strf_R16P – FLOw"},{"text":"private elemental function strf_R4P(fm, n) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=DR4P) Returned string containing input number. Called By proc~~strf_r4p~~CalledByGraph proc~strf_r4p strf_R4P interface~str str interface~str->proc~strf_r4p proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~description~2 description proc~description~2->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~description~4 description proc~description~4->interface~str proc~description_vectorial description_vectorial proc~description_vectorial->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~description~3 description proc~description~3->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~description description proc~description->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~description_scalar description_scalar proc~description_scalar->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code strf_R4P Source Code elemental function strf_R4P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R4P ), intent ( in ) :: n !< Real to be converted. character ( DR4P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R4P","tags":"","loc":"proc/strf_r4p.html","title":"strf_R4P – FLOw"},{"text":"private elemental function strf_R8P(fm, n) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=DR8P) Returned string containing input number. Called By proc~~strf_r8p~~CalledByGraph proc~strf_r8p strf_R8P interface~str str interface~str->proc~strf_r8p proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~description~2 description proc~description~2->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~description~4 description proc~description~4->interface~str proc~description_vectorial description_vectorial proc~description_vectorial->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~description~3 description proc~description~3->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~description description proc~description->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~description_scalar description_scalar proc~description_scalar->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code strf_R8P Source Code elemental function strf_R8P ( fm , n ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert real to string. !--------------------------------------------------------------------------------------------------------------------------------- character ( * ), intent ( in ) :: fm !< Format different from the standard for the kind. real ( R8P ), intent ( in ) :: n !< Real to be converted. character ( DR8P ) :: str !< Returned string containing input number. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , trim ( fm )) n return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strf_R8P","tags":"","loc":"proc/strf_r8p.html","title":"strf_R8P – FLOw"},{"text":"private elemental function strz_I1P(n, nz_pad) result(str) Convert integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Called By proc~~strz_i1p~~CalledByGraph proc~strz_i1p strz_I1P interface~strz strz interface~strz->proc~strz_i1p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code strz_I1P Source Code elemental function strz_I1P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI1P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI1PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI1P - nz_pad : DI1P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I1P","tags":"","loc":"proc/strz_i1p.html","title":"strz_I1P – FLOw"},{"text":"private elemental function strz_I2P(n, nz_pad) result(str) Convert integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. Called By proc~~strz_i2p~~CalledByGraph proc~strz_i2p strz_I2P interface~strz strz interface~strz->proc~strz_i2p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code strz_I2P Source Code elemental function strz_I2P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI2P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI2PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI2P - nz_pad : DI2P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I2P","tags":"","loc":"proc/strz_i2p.html","title":"strz_I2P – FLOw"},{"text":"private elemental function strz_I4P(n, nz_pad) result(str) Convert integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. Called By proc~~strz_i4p~~CalledByGraph proc~strz_i4p strz_I4P interface~strz strz interface~strz->proc~strz_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code strz_I4P Source Code elemental function strz_I4P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Convert integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI4P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI4PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI4P - nz_pad : DI4P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I4P","tags":"","loc":"proc/strz_i4p.html","title":"strz_I4P – FLOw"},{"text":"private elemental function strz_I8P(n, nz_pad) result(str) Converting integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Called By proc~~strz_i8p~~CalledByGraph proc~strz_i8p strz_I8P interface~strz strz interface~strz->proc~strz_i8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code strz_I8P Source Code elemental function strz_I8P ( n , nz_pad ) result ( str ) !--------------------------------------------------------------------------------------------------------------------------------- !< Converting integer to string, prefixing with the right number of zeros. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( in ) :: n !< Integer to be converted. integer ( I4P ), intent ( in ), optional :: nz_pad !< Number of zeros padding. character ( DI8P ) :: str !< Returned string containing input number plus padding zeros. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- write ( str , FI8PZP ) n ! Casting of n to string. str = str ( 2 :) ! Leaving out the sign. if ( present ( nz_pad )) str = str ( DI8P - nz_pad : DI8P - 1 ) ! Leaving out the extra zeros padding return !--------------------------------------------------------------------------------------------------------------------------------- endfunction strz_I8P","tags":"","loc":"proc/strz_i8p.html","title":"strz_I8P – FLOw"},{"text":"private pure subroutine compact_real_string(string) Compact a string representing a real number, so that the same value is displayed with fewer characters. Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: string string representation of a real number. Called By proc~~compact_real_string~~CalledByGraph proc~compact_real_string compact_real_string proc~str_r8p str_R8P proc~str_r8p->proc~compact_real_string proc~str_r16p str_R16P proc~str_r16p->proc~compact_real_string proc~str_r4p str_R4P proc~str_r4p->proc~compact_real_string proc~str_a_r8p str_a_R8P proc~str_a_r8p->proc~str_r8p interface~str str interface~str->proc~str_r8p interface~str->proc~str_r4p interface~str->proc~str_a_r8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~description~2 description proc~description~2->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~description~4 description proc~description~4->interface~str proc~description_vectorial description_vectorial proc~description_vectorial->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~description~3 description proc~description~3->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~description description proc~description->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~description_scalar description_scalar proc~description_scalar->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r4p proc~str_a_r16p str_a_R16P proc~str_a_r16p->proc~str_r16p proc~str_a_r4p->proc~str_r4p var panproccompact_real_stringCalledByGraph = svgPanZoom('#proccompact_real_stringCalledByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code compact_real_string Source Code pure subroutine compact_real_string ( string ) !--------------------------------------------------------------------------------------------------------------------------------- !< author: Izaak Beekman !< date: 02/24/2015 !< !< Compact a string representing a real number, so that the same value is displayed with fewer characters. !--------------------------------------------------------------------------------------------------------------------------------- character ( len =* ), intent ( inout ) :: string !< string representation of a real number. character ( len = len ( string )) :: significand !< Significand characters. character ( len = len ( string )) :: expnt !< Exponent characters. character ( len = 2 ) :: separator !< Separator characters. integer ( I4P ) :: exp_start !< Start position of exponent. integer ( I4P ) :: decimal_pos !< Decimal positions. integer ( I4P ) :: sig_trim !< Signature trim. integer ( I4P ) :: exp_trim !< Exponent trim. integer ( I4P ) :: i !< counter !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- string = adjustl ( string ) exp_start = scan ( string , 'eEdD' ) if ( exp_start == 0 ) exp_start = scan ( string , '-+' , back = . true .) decimal_pos = scan ( string , '.' ) if ( exp_start /= 0 ) separator = string ( exp_start : exp_start ) if ( exp_start < decimal_pos ) then ! possibly signed, exponent-less float significand = string sig_trim = len ( trim ( significand )) do i = len ( trim ( significand )), decimal_pos + 2 , - 1 ! look from right to left at 0s, but save one after the decimal place if ( significand ( i : i ) == '0' ) then sig_trim = i - 1 else exit endif enddo string = trim ( significand ( 1 : sig_trim )) elseif ( exp_start > decimal_pos ) then ! float has exponent significand = string ( 1 : exp_start - 1 ) sig_trim = len ( trim ( significand )) do i = len ( trim ( significand )), decimal_pos + 2 , - 1 ! look from right to left at 0s if ( significand ( i : i ) == '0' ) then sig_trim = i - 1 else exit endif enddo expnt = adjustl ( string ( exp_start + 1 :)) if ( expnt ( 1 : 1 ) == '+' . or . expnt ( 1 : 1 ) == '-' ) then separator = trim ( adjustl ( separator )) // expnt ( 1 : 1 ) exp_start = exp_start + 1 expnt = adjustl ( string ( exp_start + 1 :)) endif exp_trim = 1 do i = 1 ,( len ( trim ( expnt )) - 1 ) ! look at exponent leading zeros saving last if ( expnt ( i : i ) == '0' ) then exp_trim = i + 1 else exit endif enddo string = trim ( adjustl ( significand ( 1 : sig_trim ))) // & trim ( adjustl ( separator )) // & trim ( adjustl ( expnt ( exp_trim :))) !else ! mal-formed real, BUT this code should be unreachable endif !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine compact_real_string","tags":"","loc":"proc/compact_real_string.html","title":"compact_real_string – FLOw"},{"text":"public interface bcton Convert bit-string to number (real and integer, bit-string to number type casting). Calls interface~~bcton~~CallsGraph interface~bcton bcton proc~bctoi_i1p bctoi_I1P interface~bcton->proc~bctoi_i1p proc~bctoi_i4p bctoi_I4P interface~bcton->proc~bctoi_i4p proc~bctoi_i2p bctoi_I2P interface~bcton->proc~bctoi_i2p proc~bctor_r8p bctor_R8P interface~bcton->proc~bctor_r8p proc~bctor_r4p bctor_R4P interface~bcton->proc~bctor_r4p proc~bctoi_i8p bctoi_I8P interface~bcton->proc~bctoi_i8p interface~str str proc~bctoi_i1p->interface~str proc~bctoi_i4p->interface~str proc~bctoi_i2p->interface~str proc~bctor_r8p->interface~str proc~bctor_r4p->interface~str proc~bctoi_i8p->interface~str proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_bol str_bol interface~str->proc~str_bol proc~str_a_i4p->proc~str_i4p proc~str_a_i8p->proc~str_i8p proc~compact_real_string compact_real_string proc~str_r8p->proc~compact_real_string proc~str_a_r4p->proc~str_r4p proc~str_a_i1p->proc~str_i1p proc~str_a_r8p->proc~str_r8p proc~str_a_i2p->proc~str_i2p proc~str_r4p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures bctor_R8P bctor_R4P bctoi_I8P bctoi_I4P bctoi_I2P bctoi_I1P Module Procedures private elemental function bctor_R8P (bstr, knd) result(n) Convert bit-string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R8P), intent(in) :: knd Number kind. Return Value real(kind=R8P) Number returned. private elemental function bctor_R4P (bstr, knd) result(n) Convert bit-string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R4P), intent(in) :: knd Number kind. Return Value real(kind=R4P) Number returned. private elemental function bctoi_I8P (bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. Return Value integer(kind=I8P) Number returned. private elemental function bctoi_I4P (bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. Return Value integer(kind=I4P) Number returned. private elemental function bctoi_I2P (bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. Return Value integer(kind=I2P) Number returned. private elemental function bctoi_I1P (bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. Return Value integer(kind=I1P) Number returned.","tags":"","loc":"interface/bcton.html","title":"bcton – FLOw"},{"text":"public interface bstr Convert number (real and integer) to bit-string (number to bit-string type casting). Calls interface~~bstr~~CallsGraph interface~bstr bstr proc~bstr_i2p bstr_I2P interface~bstr->proc~bstr_i2p proc~bstr_r4p bstr_R4P interface~bstr->proc~bstr_r4p proc~bstr_r8p bstr_R8P interface~bstr->proc~bstr_r8p proc~bstr_i8p bstr_I8P interface~bstr->proc~bstr_i8p proc~bstr_i4p bstr_I4P interface~bstr->proc~bstr_i4p proc~bstr_i1p bstr_I1P interface~bstr->proc~bstr_i1p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures bstr_R8P bstr_R4P bstr_I8P bstr_I4P bstr_I2P bstr_I1P Module Procedures private elemental function bstr_R8P (n) result(bstr) Convert real to string of bits. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. private elemental function bstr_R4P (n) result(bstr) Convert real to string of bits. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. private elemental function bstr_I8P (n) result(bstr) Convert integer to string of bits. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. private elemental function bstr_I4P (n) result(bstr) Convert integer to string of bits. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. private elemental function bstr_I2P (n) result(bstr) Convert integer to string of bits. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Real to be converted. Return Value character(len=16) Returned bit-string containing input number. private elemental function bstr_I1P (n) result(bstr) Convert integer to string of bits. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Real to be converted. Return Value character(len=8) Returned bit-string containing input number.","tags":"","loc":"interface/bstr.html","title":"bstr – FLOw"},{"text":"public interface cton Convert string to number (real and integer, string to number type casting). Calls interface~~cton~~CallsGraph interface~cton cton proc~ctoi_i4p ctoi_I4P interface~cton->proc~ctoi_i4p proc~ctoi_i8p ctoi_I8P interface~cton->proc~ctoi_i8p proc~ctoi_i1p ctoi_I1P interface~cton->proc~ctoi_i1p proc~ctoi_i2p ctoi_I2P interface~cton->proc~ctoi_i2p proc~ctor_r4p ctor_R4P interface~cton->proc~ctor_r4p proc~ctor_r8p ctor_R8P interface~cton->proc~ctor_r8p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures ctor_R8P ctor_R4P ctoi_I8P ctoi_I4P ctoi_I2P ctoi_I1P Module Procedures private function ctor_R8P (str, knd, pref, error) result(n) Convert string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R8P) Number returned. private function ctor_R4P (str, knd, pref, error) result(n) Convert string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R4P) Number returned. private function ctoi_I8P (str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I8P) Number returned. private function ctoi_I4P (str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I4P) Number returned. private function ctoi_I2P (str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I2P) Number returned. private function ctoi_I1P (str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I1P) Number returned.","tags":"","loc":"interface/cton.html","title":"cton – FLOw"},{"text":"public interface str Convert number (real and integer) to string (number to string type casting). Calls interface~~str~~CallsGraph interface~str str proc~strf_r4p strf_R4P interface~str->proc~strf_r4p proc~strf_i1p strf_I1P interface~str->proc~strf_i1p proc~str_a_i4p str_a_I4P interface~str->proc~str_a_i4p proc~str_a_i8p str_a_I8P interface~str->proc~str_a_i8p proc~str_i1p str_I1P interface~str->proc~str_i1p proc~str_r8p str_R8P interface~str->proc~str_r8p proc~strf_r8p strf_R8P interface~str->proc~strf_r8p proc~str_a_r4p str_a_R4P interface~str->proc~str_a_r4p proc~str_i4p str_I4P interface~str->proc~str_i4p proc~str_a_i1p str_a_I1P interface~str->proc~str_a_i1p proc~strf_i2p strf_I2P interface~str->proc~strf_i2p proc~str_i2p str_I2P interface~str->proc~str_i2p proc~str_a_r8p str_a_R8P interface~str->proc~str_a_r8p proc~str_a_i2p str_a_I2P interface~str->proc~str_a_i2p proc~strf_i8p strf_I8P interface~str->proc~strf_i8p proc~strf_i4p strf_I4P interface~str->proc~strf_i4p proc~str_r4p str_R4P interface~str->proc~str_r4p proc~str_i8p str_I8P interface~str->proc~str_i8p proc~str_bol str_bol interface~str->proc~str_bol proc~str_a_i4p->proc~str_i4p proc~str_a_i8p->proc~str_i8p proc~compact_real_string compact_real_string proc~str_r8p->proc~compact_real_string proc~str_a_r4p->proc~str_r4p proc~str_a_i1p->proc~str_i1p proc~str_a_r8p->proc~str_r8p proc~str_a_i2p->proc~str_i2p proc~str_r4p->proc~compact_real_string Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By interface~~str~~CalledByGraph interface~str str proc~bctoi_i1p bctoi_I1P proc~bctoi_i1p->interface~str proc~description~2 description proc~description~2->interface~str proc~bctor_r8p bctor_R8P proc~bctor_r8p->interface~str proc~description~4 description proc~description~4->interface~str proc~description_vectorial description_vectorial proc~description_vectorial->interface~str proc~bctor_r16p bctor_R16P proc~bctor_r16p->interface~str proc~description~3 description proc~description~3->interface~str proc~bctoi_i8p bctoi_I8P proc~bctoi_i8p->interface~str proc~description description proc~description->interface~str proc~bctoi_i2p bctoi_I2P proc~bctoi_i2p->interface~str proc~description_scalar description_scalar proc~description_scalar->interface~str proc~bctoi_i4p bctoi_I4P proc~bctoi_i4p->interface~str proc~bctor_r4p bctor_R4P proc~bctor_r4p->interface~str interface~bcton bcton interface~bcton->proc~bctoi_i1p interface~bcton->proc~bctor_r8p interface~bcton->proc~bctoi_i8p interface~bcton->proc~bctoi_i2p interface~bcton->proc~bctoi_i4p interface~bcton->proc~bctor_r4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures strf_R8P str_R8P strf_R4P str_R4P strf_I8P str_I8P strf_I4P str_I4P strf_I2P str_I2P strf_I1P str_I1P str_bol str_a_R8P str_a_R4P str_a_I8P str_a_I4P str_a_I2P str_a_I1P Module Procedures private elemental function strf_R8P (fm, n) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=DR8P) Returned string containing input number. private elemental function str_R8P (n, no_sign, compact) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=DR8P) Returned string containing input number. private elemental function strf_R4P (fm, n) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=DR4P) Returned string containing input number. private elemental function str_R4P (n, no_sign, compact) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=DR4P) Returned string containing input number. private elemental function strf_I8P (fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number. private elemental function str_I8P (n, no_sign) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. private elemental function strf_I4P (fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number. private elemental function str_I4P (n, no_sign) result(str) Converting integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. private elemental function strf_I2P (fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number. private elemental function str_I2P (n, no_sign) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. private elemental function strf_I1P (fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number. private elemental function str_I1P (n, no_sign) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. private elemental function str_bol (n) result(str) Convert logical to string. Arguments Type Intent Optional Attributes Name logical, intent(in) :: n Logical to be converted. Return Value character(len=1) Returned string containing input number plus padding zeros. private pure function str_a_R8P (n, no_sign, separator, delimiters, compact) result(str) Convert real array to string. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_R4P (n, no_sign, separator, delimiters, compact) result(str) Convert real array to string. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_I8P (n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_I4P (n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_I2P (n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_I1P (n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number.","tags":"","loc":"interface/str.html","title":"str – FLOw"},{"text":"public interface strz Convert integer, to string, prefixing with the right number of zeros (integer to string type casting with zero padding). Calls interface~~strz~~CallsGraph interface~strz strz proc~strz_i1p strz_I1P interface~strz->proc~strz_i1p proc~strz_i8p strz_I8P interface~strz->proc~strz_i8p proc~strz_i2p strz_I2P interface~strz->proc~strz_i2p proc~strz_i4p strz_I4P interface~strz->proc~strz_i4p Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Module Procedures strz_I8P strz_I4P strz_I2P strz_I1P Module Procedures private elemental function strz_I8P (n, nz_pad) result(str) Converting integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. private elemental function strz_I4P (n, nz_pad) result(str) Convert integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. private elemental function strz_I2P (n, nz_pad) result(str) Convert integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. private elemental function strz_I1P (n, nz_pad) result(str) Convert integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI1P) Returned string containing input number plus padding zeros.","tags":"","loc":"interface/strz.html","title":"strz – FLOw"},{"text":"private elemental function I1P_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~i1p_eq_self~~CallsGraph proc~i1p_eq_self I1P_eq_self proc~norml2 normL2 proc~i1p_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code I1P_eq_self Source Code elemental function I1P_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) == real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I1P_eq_self","tags":"","loc":"proc/i1p_eq_self.html","title":"I1P_eq_self – FLOw"},{"text":"private elemental function I1P_great_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~i1p_great_eq_self~~CallsGraph proc~i1p_great_eq_self I1P_great_eq_self proc~norml2 normL2 proc~i1p_great_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code I1P_great_eq_self Source Code elemental function I1P_great_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) >= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I1P_great_eq_self","tags":"","loc":"proc/i1p_great_eq_self.html","title":"I1P_great_eq_self – FLOw"},{"text":"private elemental function I1P_great_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~i1p_great_self~~CallsGraph proc~i1p_great_self I1P_great_self proc~norml2 normL2 proc~i1p_great_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code I1P_great_self Source Code elemental function I1P_great_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) > normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I1P_great_self","tags":"","loc":"proc/i1p_great_self.html","title":"I1P_great_self – FLOw"},{"text":"private elemental function I1P_low_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~i1p_low_eq_self~~CallsGraph proc~i1p_low_eq_self I1P_low_eq_self proc~norml2 normL2 proc~i1p_low_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code I1P_low_eq_self Source Code elemental function I1P_low_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) <= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I1P_low_eq_self","tags":"","loc":"proc/i1p_low_eq_self.html","title":"I1P_low_eq_self – FLOw"},{"text":"private elemental function I1P_low_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~i1p_low_self~~CallsGraph proc~i1p_low_self I1P_low_self proc~norml2 normL2 proc~i1p_low_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code I1P_low_self Source Code elemental function I1P_low_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) < normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I1P_low_self","tags":"","loc":"proc/i1p_low_self.html","title":"I1P_low_self – FLOw"},{"text":"private elemental function I1P_not_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~i1p_not_eq_self~~CallsGraph proc~i1p_not_eq_self I1P_not_eq_self proc~norml2 normL2 proc~i1p_not_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code I1P_not_eq_self Source Code elemental function I1P_not_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) /= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I1P_not_eq_self","tags":"","loc":"proc/i1p_not_eq_self.html","title":"I1P_not_eq_self – FLOw"},{"text":"private elemental function I2P_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~i2p_eq_self~~CallsGraph proc~i2p_eq_self I2P_eq_self proc~norml2 normL2 proc~i2p_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code I2P_eq_self Source Code elemental function I2P_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) == real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I2P_eq_self","tags":"","loc":"proc/i2p_eq_self.html","title":"I2P_eq_self – FLOw"},{"text":"private elemental function I2P_great_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~i2p_great_eq_self~~CallsGraph proc~i2p_great_eq_self I2P_great_eq_self proc~norml2 normL2 proc~i2p_great_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code I2P_great_eq_self Source Code elemental function I2P_great_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) >= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I2P_great_eq_self","tags":"","loc":"proc/i2p_great_eq_self.html","title":"I2P_great_eq_self – FLOw"},{"text":"private elemental function I2P_great_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~i2p_great_self~~CallsGraph proc~i2p_great_self I2P_great_self proc~norml2 normL2 proc~i2p_great_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code I2P_great_self Source Code elemental function I2P_great_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) > normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I2P_great_self","tags":"","loc":"proc/i2p_great_self.html","title":"I2P_great_self – FLOw"},{"text":"private elemental function I2P_low_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~i2p_low_eq_self~~CallsGraph proc~i2p_low_eq_self I2P_low_eq_self proc~norml2 normL2 proc~i2p_low_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code I2P_low_eq_self Source Code elemental function I2P_low_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) <= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I2P_low_eq_self","tags":"","loc":"proc/i2p_low_eq_self.html","title":"I2P_low_eq_self – FLOw"},{"text":"private elemental function I2P_low_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~i2p_low_self~~CallsGraph proc~i2p_low_self I2P_low_self proc~norml2 normL2 proc~i2p_low_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code I2P_low_self Source Code elemental function I2P_low_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) < normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I2P_low_self","tags":"","loc":"proc/i2p_low_self.html","title":"I2P_low_self – FLOw"},{"text":"private elemental function I2P_not_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~i2p_not_eq_self~~CallsGraph proc~i2p_not_eq_self I2P_not_eq_self proc~norml2 normL2 proc~i2p_not_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code I2P_not_eq_self Source Code elemental function I2P_not_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) /= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I2P_not_eq_self","tags":"","loc":"proc/i2p_not_eq_self.html","title":"I2P_not_eq_self – FLOw"},{"text":"private elemental function I4P_eq_self(scal, self) result(compare) @brief Procedure returns .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~i4p_eq_self~~CallsGraph proc~i4p_eq_self I4P_eq_self proc~norml2 normL2 proc~i4p_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code I4P_eq_self Source Code elemental function I4P_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< @brief Procedure returns .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) == real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I4P_eq_self","tags":"","loc":"proc/i4p_eq_self.html","title":"I4P_eq_self – FLOw"},{"text":"private elemental function I4P_great_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~i4p_great_eq_self~~CallsGraph proc~i4p_great_eq_self I4P_great_eq_self proc~norml2 normL2 proc~i4p_great_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code I4P_great_eq_self Source Code elemental function I4P_great_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) >= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I4P_great_eq_self","tags":"","loc":"proc/i4p_great_eq_self.html","title":"I4P_great_eq_self – FLOw"},{"text":"private elemental function I4P_great_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~i4p_great_self~~CallsGraph proc~i4p_great_self I4P_great_self proc~norml2 normL2 proc~i4p_great_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code I4P_great_self Source Code elemental function I4P_great_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) > normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I4P_great_self","tags":"","loc":"proc/i4p_great_self.html","title":"I4P_great_self – FLOw"},{"text":"private elemental function I4P_low_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~i4p_low_eq_self~~CallsGraph proc~i4p_low_eq_self I4P_low_eq_self proc~norml2 normL2 proc~i4p_low_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code I4P_low_eq_self Source Code elemental function I4P_low_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) <= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I4P_low_eq_self","tags":"","loc":"proc/i4p_low_eq_self.html","title":"I4P_low_eq_self – FLOw"},{"text":"private elemental function I4P_low_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~i4p_low_self~~CallsGraph proc~i4p_low_self I4P_low_self proc~norml2 normL2 proc~i4p_low_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code I4P_low_self Source Code elemental function I4P_low_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) < normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I4P_low_self","tags":"","loc":"proc/i4p_low_self.html","title":"I4P_low_self – FLOw"},{"text":"private elemental function I4P_not_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~i4p_not_eq_self~~CallsGraph proc~i4p_not_eq_self I4P_not_eq_self proc~norml2 normL2 proc~i4p_not_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code I4P_not_eq_self Source Code elemental function I4P_not_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) /= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I4P_not_eq_self","tags":"","loc":"proc/i4p_not_eq_self.html","title":"I4P_not_eq_self – FLOw"},{"text":"private elemental function I8P_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~i8p_eq_self~~CallsGraph proc~i8p_eq_self I8P_eq_self proc~norml2 normL2 proc~i8p_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code I8P_eq_self Source Code elemental function I8P_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) == real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I8P_eq_self","tags":"","loc":"proc/i8p_eq_self.html","title":"I8P_eq_self – FLOw"},{"text":"private elemental function I8P_great_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~i8p_great_eq_self~~CallsGraph proc~i8p_great_eq_self I8P_great_eq_self proc~norml2 normL2 proc~i8p_great_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code I8P_great_eq_self Source Code elemental function I8P_great_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) >= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I8P_great_eq_self","tags":"","loc":"proc/i8p_great_eq_self.html","title":"I8P_great_eq_self – FLOw"},{"text":"private elemental function I8P_great_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~i8p_great_self~~CallsGraph proc~i8p_great_self I8P_great_self proc~norml2 normL2 proc~i8p_great_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code I8P_great_self Source Code elemental function I8P_great_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) > normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I8P_great_self","tags":"","loc":"proc/i8p_great_self.html","title":"I8P_great_self – FLOw"},{"text":"private elemental function I8P_low_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~i8p_low_eq_self~~CallsGraph proc~i8p_low_eq_self I8P_low_eq_self proc~norml2 normL2 proc~i8p_low_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code I8P_low_eq_self Source Code elemental function I8P_low_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) <= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I8P_low_eq_self","tags":"","loc":"proc/i8p_low_eq_self.html","title":"I8P_low_eq_self – FLOw"},{"text":"private elemental function I8P_low_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~i8p_low_self~~CallsGraph proc~i8p_low_self I8P_low_self proc~norml2 normL2 proc~i8p_low_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code I8P_low_self Source Code elemental function I8P_low_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) < normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I8P_low_self","tags":"","loc":"proc/i8p_low_self.html","title":"I8P_low_self – FLOw"},{"text":"private elemental function I8P_not_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~i8p_not_eq_self~~CallsGraph proc~i8p_not_eq_self I8P_not_eq_self proc~norml2 normL2 proc~i8p_not_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code I8P_not_eq_self Source Code elemental function I8P_not_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) /= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction I8P_not_eq_self","tags":"","loc":"proc/i8p_not_eq_self.html","title":"I8P_not_eq_self – FLOw"},{"text":"private elemental function R16P_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~r16p_eq_self~~CallsGraph proc~r16p_eq_self R16P_eq_self proc~norml2 normL2 proc~r16p_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code R16P_eq_self Source Code elemental function R16P_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) == real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction R16P_eq_self","tags":"","loc":"proc/r16p_eq_self.html","title":"R16P_eq_self – FLOw"},{"text":"private elemental function R16P_great_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~r16p_great_eq_self~~CallsGraph proc~r16p_great_eq_self R16P_great_eq_self proc~norml2 normL2 proc~r16p_great_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code R16P_great_eq_self Source Code elemental function R16P_great_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) >= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction R16P_great_eq_self","tags":"","loc":"proc/r16p_great_eq_self.html","title":"R16P_great_eq_self – FLOw"},{"text":"private elemental function R16P_great_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~r16p_great_self~~CallsGraph proc~r16p_great_self R16P_great_self proc~norml2 normL2 proc~r16p_great_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code R16P_great_self Source Code elemental function R16P_great_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) > normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction R16P_great_self","tags":"","loc":"proc/r16p_great_self.html","title":"R16P_great_self – FLOw"},{"text":"private elemental function R16P_low_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~r16p_low_eq_self~~CallsGraph proc~r16p_low_eq_self R16P_low_eq_self proc~norml2 normL2 proc~r16p_low_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code R16P_low_eq_self Source Code elemental function R16P_low_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) <= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction R16P_low_eq_self","tags":"","loc":"proc/r16p_low_eq_self.html","title":"R16P_low_eq_self – FLOw"},{"text":"private elemental function R16P_low_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~r16p_low_self~~CallsGraph proc~r16p_low_self R16P_low_self proc~norml2 normL2 proc~r16p_low_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code R16P_low_self Source Code elemental function R16P_low_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) < normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction R16P_low_self","tags":"","loc":"proc/r16p_low_self.html","title":"R16P_low_self – FLOw"},{"text":"private elemental function R16P_not_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~r16p_not_eq_self~~CallsGraph proc~r16p_not_eq_self R16P_not_eq_self proc~norml2 normL2 proc~r16p_not_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code R16P_not_eq_self Source Code elemental function R16P_not_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) /= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction R16P_not_eq_self","tags":"","loc":"proc/r16p_not_eq_self.html","title":"R16P_not_eq_self – FLOw"},{"text":"private elemental function R4P_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~r4p_eq_self~~CallsGraph proc~r4p_eq_self R4P_eq_self proc~norml2 normL2 proc~r4p_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code R4P_eq_self Source Code elemental function R4P_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) == real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction R4P_eq_self","tags":"","loc":"proc/r4p_eq_self.html","title":"R4P_eq_self – FLOw"},{"text":"private elemental function R4P_great_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~r4p_great_eq_self~~CallsGraph proc~r4p_great_eq_self R4P_great_eq_self proc~norml2 normL2 proc~r4p_great_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code R4P_great_eq_self Source Code elemental function R4P_great_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) >= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction R4P_great_eq_self","tags":"","loc":"proc/r4p_great_eq_self.html","title":"R4P_great_eq_self – FLOw"},{"text":"private elemental function R4P_great_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~r4p_great_self~~CallsGraph proc~r4p_great_self R4P_great_self proc~norml2 normL2 proc~r4p_great_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code R4P_great_self Source Code elemental function R4P_great_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) > normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction R4P_great_self","tags":"","loc":"proc/r4p_great_self.html","title":"R4P_great_self – FLOw"},{"text":"private elemental function R4P_low_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~r4p_low_eq_self~~CallsGraph proc~r4p_low_eq_self R4P_low_eq_self proc~norml2 normL2 proc~r4p_low_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code R4P_low_eq_self Source Code elemental function R4P_low_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) <= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction R4P_low_eq_self","tags":"","loc":"proc/r4p_low_eq_self.html","title":"R4P_low_eq_self – FLOw"},{"text":"private elemental function R4P_low_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~r4p_low_self~~CallsGraph proc~r4p_low_self R4P_low_self proc~norml2 normL2 proc~r4p_low_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code R4P_low_self Source Code elemental function R4P_low_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) < normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction R4P_low_self","tags":"","loc":"proc/r4p_low_self.html","title":"R4P_low_self – FLOw"},{"text":"private elemental function R4P_not_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~r4p_not_eq_self~~CallsGraph proc~r4p_not_eq_self R4P_not_eq_self proc~norml2 normL2 proc~r4p_not_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code R4P_not_eq_self Source Code elemental function R4P_not_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) /= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction R4P_not_eq_self","tags":"","loc":"proc/r4p_not_eq_self.html","title":"R4P_not_eq_self – FLOw"},{"text":"private elemental function R8P_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~r8p_eq_self~~CallsGraph proc~r8p_eq_self R8P_eq_self proc~norml2 normL2 proc~r8p_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code R8P_eq_self Source Code elemental function R8P_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) == real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction R8P_eq_self","tags":"","loc":"proc/r8p_eq_self.html","title":"R8P_eq_self – FLOw"},{"text":"private elemental function R8P_great_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~r8p_great_eq_self~~CallsGraph proc~r8p_great_eq_self R8P_great_eq_self proc~norml2 normL2 proc~r8p_great_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code R8P_great_eq_self Source Code elemental function R8P_great_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) >= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction R8P_great_eq_self","tags":"","loc":"proc/r8p_great_eq_self.html","title":"R8P_great_eq_self – FLOw"},{"text":"private elemental function R8P_great_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~r8p_great_self~~CallsGraph proc~r8p_great_self R8P_great_self proc~norml2 normL2 proc~r8p_great_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code R8P_great_self Source Code elemental function R8P_great_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) > normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction R8P_great_self","tags":"","loc":"proc/r8p_great_self.html","title":"R8P_great_self – FLOw"},{"text":"private elemental function R8P_low_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~r8p_low_eq_self~~CallsGraph proc~r8p_low_eq_self R8P_low_eq_self proc~norml2 normL2 proc~r8p_low_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code R8P_low_eq_self Source Code elemental function R8P_low_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( IN ) :: scal ! Scalar. class ( Vector ), intent ( IN ) :: self ! Vector. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) <= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction R8P_low_eq_self","tags":"","loc":"proc/r8p_low_eq_self.html","title":"R8P_low_eq_self – FLOw"},{"text":"private elemental function R8P_low_self(scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~r8p_low_self~~CallsGraph proc~r8p_low_self R8P_low_self proc~norml2 normL2 proc~r8p_low_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code R8P_low_self Source Code elemental function R8P_low_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) < normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction R8P_low_self","tags":"","loc":"proc/r8p_low_self.html","title":"R8P_low_self – FLOw"},{"text":"private elemental function R8P_not_eq_self(scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical Calls proc~~r8p_not_eq_self~~CallsGraph proc~r8p_not_eq_self R8P_not_eq_self proc~norml2 normL2 proc~r8p_not_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code R8P_not_eq_self Source Code elemental function R8P_not_eq_self ( scal , self ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) /= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction R8P_not_eq_self","tags":"","loc":"proc/r8p_not_eq_self.html","title":"R8P_not_eq_self – FLOw"},{"text":"private elemental function ScalI1P_mul_self(scal, self) result(mul) Multiply scalar (integer I1P) for self. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) Source Code ScalI1P_mul_self Source Code elemental function ScalI1P_mul_self ( scal , self ) result ( mul ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply scalar (integer I1P) for self. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: mul !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- mul % x = real ( scal , R8P ) * self % x mul % y = real ( scal , R8P ) * self % y mul % z = real ( scal , R8P ) * self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalI1P_mul_self","tags":"","loc":"proc/scali1p_mul_self.html","title":"ScalI1P_mul_self – FLOw"},{"text":"private elemental function ScalI1P_sub_self(scal, self) result(sub) Subtract scalar (integer I1P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) Source Code ScalI1P_sub_self Source Code elemental function ScalI1P_sub_self ( scal , self ) result ( sub ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract scalar (integer I1P) and self. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: sub !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- sub % x = real ( scal , R8P ) - self % x sub % y = real ( scal , R8P ) - self % y sub % z = real ( scal , R8P ) - self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalI1P_sub_self","tags":"","loc":"proc/scali1p_sub_self.html","title":"ScalI1P_sub_self – FLOw"},{"text":"private elemental function ScalI1P_sum_self(scal, self) result(summ) Sum scalar (integer I1P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) Source Code ScalI1P_sum_self Source Code elemental function ScalI1P_sum_self ( scal , self ) result ( summ ) !--------------------------------------------------------------------------------------------------------------------------------- !< Sum scalar (integer I1P) and self. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I1P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: summ !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- summ % x = real ( scal , R8P ) + self % x summ % y = real ( scal , R8P ) + self % y summ % z = real ( scal , R8P ) + self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalI1P_sum_self","tags":"","loc":"proc/scali1p_sum_self.html","title":"ScalI1P_sum_self – FLOw"},{"text":"private elemental function ScalI2P_mul_self(scal, self) result(mul) Multiply scalar (integer I2P) for self. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) Source Code ScalI2P_mul_self Source Code elemental function ScalI2P_mul_self ( scal , self ) result ( mul ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply scalar (integer I2P) for self. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: mul !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- mul % x = real ( scal , R8P ) * self % x mul % y = real ( scal , R8P ) * self % y mul % z = real ( scal , R8P ) * self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalI2P_mul_self","tags":"","loc":"proc/scali2p_mul_self.html","title":"ScalI2P_mul_self – FLOw"},{"text":"private elemental function ScalI2P_sub_self(scal, self) result(sub) Subtract scalar (integer I2P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) Source Code ScalI2P_sub_self Source Code elemental function ScalI2P_sub_self ( scal , self ) result ( sub ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract scalar (integer I2P) and self. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: sub !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- sub % x = real ( scal , R8P ) - self % x sub % y = real ( scal , R8P ) - self % y sub % z = real ( scal , R8P ) - self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalI2P_sub_self","tags":"","loc":"proc/scali2p_sub_self.html","title":"ScalI2P_sub_self – FLOw"},{"text":"private elemental function ScalI2P_sum_self(scal, self) result(summ) Sum scalar (integer I2P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) Source Code ScalI2P_sum_self Source Code elemental function ScalI2P_sum_self ( scal , self ) result ( summ ) !--------------------------------------------------------------------------------------------------------------------------------- !< Sum scalar (integer I2P) and self. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I2P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: summ !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- summ % x = real ( scal , R8P ) + self % x summ % y = real ( scal , R8P ) + self % y summ % z = real ( scal , R8P ) + self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalI2P_sum_self","tags":"","loc":"proc/scali2p_sum_self.html","title":"ScalI2P_sum_self – FLOw"},{"text":"private elemental function ScalI4P_mul_self(scal, self) result(mul) Multiply scalar (integer I4P) for self. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) Source Code ScalI4P_mul_self Source Code elemental function ScalI4P_mul_self ( scal , self ) result ( mul ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply scalar (integer I4P) for self. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: mul !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- mul % x = real ( scal , R8P ) * self % x mul % y = real ( scal , R8P ) * self % y mul % z = real ( scal , R8P ) * self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalI4P_mul_self","tags":"","loc":"proc/scali4p_mul_self.html","title":"ScalI4P_mul_self – FLOw"},{"text":"private elemental function ScalI4P_sub_self(scal, self) result(sub) Subtract scalar (integer I4P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) Source Code ScalI4P_sub_self Source Code elemental function ScalI4P_sub_self ( scal , self ) result ( sub ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract scalar (integer I4P) and self. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: sub !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- sub % x = real ( scal , R8P ) - self % x sub % y = real ( scal , R8P ) - self % y sub % z = real ( scal , R8P ) - self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalI4P_sub_self","tags":"","loc":"proc/scali4p_sub_self.html","title":"ScalI4P_sub_self – FLOw"},{"text":"private elemental function ScalI4P_sum_self(scal, self) result(summ) Sum scalar (integer I4P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) Source Code ScalI4P_sum_self Source Code elemental function ScalI4P_sum_self ( scal , self ) result ( summ ) !--------------------------------------------------------------------------------------------------------------------------------- !< Sum scalar (integer I4P) and self. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I4P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: summ !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- summ % x = real ( scal , R8P ) + self % x summ % y = real ( scal , R8P ) + self % y summ % z = real ( scal , R8P ) + self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalI4P_sum_self","tags":"","loc":"proc/scali4p_sum_self.html","title":"ScalI4P_sum_self – FLOw"},{"text":"private elemental function ScalI8P_mul_self(scal, self) result(mul) Multiply scalar (integer I8P) for self. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) Source Code ScalI8P_mul_self Source Code elemental function ScalI8P_mul_self ( scal , self ) result ( mul ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply scalar (integer I8P) for self. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: mul !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- mul % x = real ( scal , R8P ) * self % x mul % y = real ( scal , R8P ) * self % y mul % z = real ( scal , R8P ) * self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalI8P_mul_self","tags":"","loc":"proc/scali8p_mul_self.html","title":"ScalI8P_mul_self – FLOw"},{"text":"private elemental function ScalI8P_sub_self(scal, self) result(sub) Subtract scalar (integer I8P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) Source Code ScalI8P_sub_self Source Code elemental function ScalI8P_sub_self ( scal , self ) result ( sub ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract scalar (integer I8P) and self. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: sub !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- sub % x = real ( scal , R8P ) - self % x sub % y = real ( scal , R8P ) - self % y sub % z = real ( scal , R8P ) - self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalI8P_sub_self","tags":"","loc":"proc/scali8p_sub_self.html","title":"ScalI8P_sub_self – FLOw"},{"text":"private elemental function ScalI8P_sum_self(scal, self) result(summ) Sum scalar (integer I8P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) Source Code ScalI8P_sum_self Source Code elemental function ScalI8P_sum_self ( scal , self ) result ( summ ) !--------------------------------------------------------------------------------------------------------------------------------- !< Sum scalar (integer I8P) and self. !--------------------------------------------------------------------------------------------------------------------------------- integer ( I8P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: summ !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- summ % x = real ( scal , R8P ) + self % x summ % y = real ( scal , R8P ) + self % y summ % z = real ( scal , R8P ) + self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalI8P_sum_self","tags":"","loc":"proc/scali8p_sum_self.html","title":"ScalI8P_sum_self – FLOw"},{"text":"private elemental function ScalR16P_mul_self(scal, self) result(mul) Multiply scalar (real R16P) for self. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) Source Code ScalR16P_mul_self Source Code elemental function ScalR16P_mul_self ( scal , self ) result ( mul ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply scalar (real R16P) for self. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: mul !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- mul % x = real ( scal , R8P ) * self % x mul % y = real ( scal , R8P ) * self % y mul % z = real ( scal , R8P ) * self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalR16P_mul_self","tags":"","loc":"proc/scalr16p_mul_self.html","title":"ScalR16P_mul_self – FLOw"},{"text":"private elemental function ScalR16P_sub_self(scal, self) result(sub) Subtract scalar (real R16P) and self. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) Source Code ScalR16P_sub_self Source Code elemental function ScalR16P_sub_self ( scal , self ) result ( sub ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract scalar (real R16P) and self. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: sub !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- sub % x = real ( scal , R8P ) - self % x sub % y = real ( scal , R8P ) - self % y sub % z = real ( scal , R8P ) - self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalR16P_sub_self","tags":"","loc":"proc/scalr16p_sub_self.html","title":"ScalR16P_sub_self – FLOw"},{"text":"private elemental function ScalR16P_sum_self(scal, self) result(summ) Sum scalar (real R16P) and self. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) Source Code ScalR16P_sum_self Source Code elemental function ScalR16P_sum_self ( scal , self ) result ( summ ) !--------------------------------------------------------------------------------------------------------------------------------- !< Sum scalar (real R16P) and self. !--------------------------------------------------------------------------------------------------------------------------------- real ( R16P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: summ !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- summ % x = real ( scal , R8P ) + self % x summ % y = real ( scal , R8P ) + self % y summ % z = real ( scal , R8P ) + self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalR16P_sum_self","tags":"","loc":"proc/scalr16p_sum_self.html","title":"ScalR16P_sum_self – FLOw"},{"text":"private elemental function ScalR4P_mul_self(scal, self) result(mul) Multiply scalar (real R4P) for self. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) Source Code ScalR4P_mul_self Source Code elemental function ScalR4P_mul_self ( scal , self ) result ( mul ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply scalar (real R4P) for self. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: mul !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- mul % x = real ( scal , R8P ) * self % x mul % y = real ( scal , R8P ) * self % y mul % z = real ( scal , R8P ) * self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalR4P_mul_self","tags":"","loc":"proc/scalr4p_mul_self.html","title":"ScalR4P_mul_self – FLOw"},{"text":"private elemental function ScalR4P_sub_self(scal, self) result(sub) Subtract scalar (real R4P) and self. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) Source Code ScalR4P_sub_self Source Code elemental function ScalR4P_sub_self ( scal , self ) result ( sub ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract scalar (real R4P) and self. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: sub !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- sub % x = real ( scal , R8P ) - self % x sub % y = real ( scal , R8P ) - self % y sub % z = real ( scal , R8P ) - self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalR4P_sub_self","tags":"","loc":"proc/scalr4p_sub_self.html","title":"ScalR4P_sub_self – FLOw"},{"text":"private elemental function ScalR4P_sum_self(scal, self) result(summ) Sum scalar (real R4P) and self. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) Source Code ScalR4P_sum_self Source Code elemental function ScalR4P_sum_self ( scal , self ) result ( summ ) !--------------------------------------------------------------------------------------------------------------------------------- !< Sum scalar (real R4P) and self. !--------------------------------------------------------------------------------------------------------------------------------- real ( R4P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: summ !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- summ % x = real ( scal , R8P ) + self % x summ % y = real ( scal , R8P ) + self % y summ % z = real ( scal , R8P ) + self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalR4P_sum_self","tags":"","loc":"proc/scalr4p_sum_self.html","title":"ScalR4P_sum_self – FLOw"},{"text":"private elemental function ScalR8P_mul_self(scal, self) result(mul) Multiply scalar (real R8P) for self. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) Source Code ScalR8P_mul_self Source Code elemental function ScalR8P_mul_self ( scal , self ) result ( mul ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply scalar (real R8P) for self. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: mul !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- mul % x = real ( scal , R8P ) * self % x mul % y = real ( scal , R8P ) * self % y mul % z = real ( scal , R8P ) * self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalR8P_mul_self","tags":"","loc":"proc/scalr8p_mul_self.html","title":"ScalR8P_mul_self – FLOw"},{"text":"private elemental function ScalR8P_sub_self(scal, self) result(sub) Subtract scalar (real R8P) and self. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) Source Code ScalR8P_sub_self Source Code elemental function ScalR8P_sub_self ( scal , self ) result ( sub ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract scalar (real R8P) and self. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: sub !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- sub % x = real ( scal , R8P ) - self % x sub % y = real ( scal , R8P ) - self % y sub % z = real ( scal , R8P ) - self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalR8P_sub_self","tags":"","loc":"proc/scalr8p_sub_self.html","title":"ScalR8P_sub_self – FLOw"},{"text":"private elemental function ScalR8P_sum_self(scal, self) result(summ) Sum scalar (real R8P) and self. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) Source Code ScalR8P_sum_self Source Code elemental function ScalR8P_sum_self ( scal , self ) result ( summ ) !--------------------------------------------------------------------------------------------------------------------------------- !< Sum scalar (real R8P) and self. !--------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( IN ) :: scal class ( Vector ), intent ( IN ) :: self type ( Vector ) :: summ !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- summ % x = real ( scal , R8P ) + self % x summ % y = real ( scal , R8P ) + self % y summ % z = real ( scal , R8P ) + self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction ScalR8P_sum_self","tags":"","loc":"proc/scalr8p_sum_self.html","title":"ScalR8P_sum_self – FLOw"},{"text":"private elemental function crossproduct(vec1, vec2) result(cross) Compute the cross product of 2 vectors.  \\vec V=\\left({y_1 z_2 - z_1 y_2}\\right)\\vec i +\n           \\left({z_1 x_2 - x_1 z_2}\\right)\\vec j +\n           \\left({x_1 y_2 - y_1 x_2}\\right)\\vec k \n where  x_i ,  y_i  and  z_i   i=1,2  are the components of the vectors. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: vec1 First vector. type( Vector ), intent(in) :: vec2 Second vector. Return Value type( Vector ) Cross product vector. Source Code crossproduct Source Code elemental function crossproduct ( vec1 , vec2 ) result ( cross ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the cross product of 2 vectors. !< !<  \\vec V=\\left({y_1 z_2 - z_1 y_2}\\right)\\vec i + !<           \\left({z_1 x_2 - x_1 z_2}\\right)\\vec j + !<           \\left({x_1 y_2 - y_1 x_2}\\right)\\vec k  !< where  x_i ,  y_i  and  z_i   i=1,2  are the components of the vectors. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: vec1 !< First vector. type ( Vector ), intent ( IN ) :: vec2 !< Second vector. type ( Vector ) :: cross !< Cross product vector. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- cross % x = ( vec1 % y * vec2 % z ) - ( vec1 % z * vec2 % y ) cross % y = ( vec1 % z * vec2 % x ) - ( vec1 % x * vec2 % z ) cross % z = ( vec1 % x * vec2 % y ) - ( vec1 % y * vec2 % x ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction crossproduct","tags":"","loc":"proc/crossproduct.html","title":"crossproduct – FLOw"},{"text":"private elemental function dotproduct(vec1, vec2) result(dot) Compute the scalar (dot) product of 2 vectors.  {\\rm D}= x_1 \\cdot x_2 + y_1 \\cdot y_2 + z_1 \\cdot z_2 \n where  x_i ,  y_i  and  z_i   i=1,2  are the components of the vectors. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: vec1 First vector. type( Vector ), intent(in) :: vec2 Second vector. Return Value real(kind=R8P) Dot product. Source Code dotproduct Source Code elemental function dotproduct ( vec1 , vec2 ) result ( dot ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the scalar (dot) product of 2 vectors. !< !<  {\\rm D}= x_1 \\cdot x_2 + y_1 \\cdot y_2 + z_1 \\cdot z_2  !< where  x_i ,  y_i  and  z_i   i=1,2  are the components of the vectors. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: vec1 !< First vector. type ( Vector ), intent ( IN ) :: vec2 !< Second vector. real ( R8P ) :: dot !< Dot product. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- dot = ( vec1 % x * vec2 % x ) + ( vec1 % y * vec2 % y ) + ( vec1 % z * vec2 % z ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction dotproduct","tags":"","loc":"proc/dotproduct.html","title":"dotproduct – FLOw"},{"text":"public elemental function face_normal3(pt1, pt2, pt3, norm) result(fnormal) Calculate the normal of the face defined by the 3 points vector pt1, pt2 and pt3. The convention for the points numeration is the following: 1.----.2\n   \\   |\n    \\  |\n     \\ |\n      \\|\n       .3 The normal is calculated by the cross product of the side s12 for the side s13: s12 x s13.\n The normal is normalized if the variable 'norm' is passed (with any value). Arguments Type Intent Optional Attributes Name type( Vector ), intent(in) :: pt1 First face point. type( Vector ), intent(in) :: pt2 Second face point. type( Vector ), intent(in) :: pt3 Third face point. character(len=1), intent(in), optional :: norm If 'norm' is passed as argument the normal is normalized. Return Value type( Vector ) Face normal. Calls proc~~face_normal3~~CallsGraph proc~face_normal3 face_normal3 proc~normalize normalize proc~face_normal3->proc~normalize proc~norml2 normL2 proc~normalize->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code face_normal3 Source Code elemental function face_normal3 ( pt1 , pt2 , pt3 , norm ) result ( fnormal ) !--------------------------------------------------------------------------------------------------------------------------------- !< Calculate the normal of the face defined by the 3 points vector pt1, pt2 and pt3. !< !< The convention for the points numeration is the following: !<``` !< 1.----.2 !<   \\   | !<    \\  | !<     \\ | !<      \\| !<       .3 !<``` !< The normal is calculated by the cross product of the side s12 for the side s13: s12 x s13. !< The normal is normalized if the variable 'norm' is passed (with any value). !--------------------------------------------------------------------------------------------------------------------------------- type ( Vector ), intent ( IN ) :: pt1 !< First face point. type ( Vector ), intent ( IN ) :: pt2 !< Second face point. type ( Vector ), intent ( IN ) :: pt3 !< Third face point. character ( 1 ), intent ( IN ), optional :: norm !< If 'norm' is passed as argument the normal is normalized. type ( Vector ) :: fnormal !< Face normal. type ( Vector ) :: s12 !< Face 1-2 diagonals. type ( Vector ) :: s13 !< Face 1-3 diagonals. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- s12 = pt2 - pt1 s13 = pt3 - pt1 if ( present ( norm )) then fnormal = normalize ( s12 . cross . s13 ) else fnormal = 0.5_R8P * ( s12 . cross . s13 ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction face_normal3","tags":"","loc":"proc/face_normal3.html","title":"face_normal3 – FLOw"},{"text":"public elemental function face_normal4(pt1, pt2, pt3, pt4, norm) result(fnormal) Calculate the normal of the face defined by 4 points vector pt1, pt2, pt3 and pt4. The convention for the points numeration is the following: 1.----------.2\n  |          |\n  |          |\n  |          |\n  |          |\n 4.----------.3 The normal is calculated by the cross product of the diagonal d13 for the diagonal d24: d13 x d24.\n The normal is normalized if the variable norm is passed (with any value). Arguments Type Intent Optional Attributes Name type( Vector ), intent(in) :: pt1 First face point. type( Vector ), intent(in) :: pt2 Second face point. type( Vector ), intent(in) :: pt3 Third face point. type( Vector ), intent(in) :: pt4 Fourth face point. character(len=1), intent(in), optional :: norm If 'norm' is passed as argument the normal is normalized. Return Value type( Vector ) Face normal. Calls proc~~face_normal4~~CallsGraph proc~face_normal4 face_normal4 proc~normalize normalize proc~face_normal4->proc~normalize proc~norml2 normL2 proc~normalize->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code face_normal4 Source Code elemental function face_normal4 ( pt1 , pt2 , pt3 , pt4 , norm ) result ( fnormal ) !--------------------------------------------------------------------------------------------------------------------------------- !< Calculate the normal of the face defined by 4 points vector pt1, pt2, pt3 and pt4. !< !< The convention for the points numeration is the following: !<``` !< 1.----------.2 !<  |          | !<  |          | !<  |          | !<  |          | !< 4.----------.3 !<``` !< The normal is calculated by the cross product of the diagonal d13 for the diagonal d24: d13 x d24. !< The normal is normalized if the variable *norm* is passed (with any value). !--------------------------------------------------------------------------------------------------------------------------------- type ( Vector ), intent ( IN ) :: pt1 !< First face point. type ( Vector ), intent ( IN ) :: pt2 !< Second face point. type ( Vector ), intent ( IN ) :: pt3 !< Third face point. type ( Vector ), intent ( IN ) :: pt4 !< Fourth face point. character ( 1 ), intent ( IN ), optional :: norm !< If 'norm' is passed as argument the normal is normalized. type ( Vector ) :: fnormal !< Face normal. type ( Vector ) :: d13 !< Face 1-3 diagonal. type ( Vector ) :: d24 !< Face 2-4 diagonal. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- d13 = pt3 - pt1 d24 = pt4 - pt2 if ( present ( norm )) then fnormal = normalize ( d13 . cross . d24 ) else fnormal = 0.5_R8P * ( d13 . cross . d24 ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction face_normal4","tags":"","loc":"proc/face_normal4.html","title":"face_normal4 – FLOw"},{"text":"private function iolen_vector_self(vec) result(iolen) Compute IO length. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: vec Vector. Return Value integer(kind=I4P) IO length. Source Code iolen_vector_self Source Code function iolen_vector_self ( vec ) result ( iolen ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute IO length. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: vec !< Vector. integer ( I4P ) :: iolen !< IO length. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- inquire ( iolength = iolen ) vec % x , vec % y , vec % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction iolen_vector_self","tags":"","loc":"proc/iolen_vector_self.html","title":"iolen_vector_self – FLOw"},{"text":"private elemental function negative_self(self) result(neg) Applay unary - to a self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self Return Value type( Vector ) Source Code negative_self Source Code elemental function negative_self ( self ) result ( neg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Applay unary - to a self. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self type ( Vector ) :: neg !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- neg % x = - self % x neg % y = - self % y neg % z = - self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction negative_self","tags":"","loc":"proc/negative_self.html","title":"negative_self – FLOw"},{"text":"public elemental function normL2(vec) result(norm) Compute the norm L2 of a vector. The norm L2 if defined as  N = \\sqrt {x&#94;2  + y&#94;2  + z&#94;2 } . Arguments Type Intent Optional Attributes Name type( Vector ), intent(in) :: vec Vector. Return Value real(kind=R8P) Norm L2. Called By proc~~norml2~~CalledByGraph proc~norml2 normL2 proc~self_not_eq_i1p self_not_eq_I1P proc~self_not_eq_i1p->proc~norml2 proc~self_eq_i1p self_eq_I1P proc~self_eq_i1p->proc~norml2 proc~self_eq_i2p self_eq_I2P proc~self_eq_i2p->proc~norml2 proc~self_eq_i4p self_eq_I4P proc~self_eq_i4p->proc~norml2 proc~self_eq_i8p self_eq_I8P proc~self_eq_i8p->proc~norml2 proc~self_eq_r16p self_eq_R16P proc~self_eq_r16p->proc~norml2 proc~self_eq_r4p self_eq_R4P proc~self_eq_r4p->proc~norml2 proc~self_not_eq_i2p self_not_eq_I2P proc~self_not_eq_i2p->proc~norml2 proc~self_eq_r8p self_eq_R8P proc~self_eq_r8p->proc~norml2 proc~self_eq_self self_eq_self proc~self_eq_self->proc~norml2 proc~normalize normalize proc~self_eq_self->proc~normalize proc~self_great_i1p self_great_I1P proc~self_great_i1p->proc~norml2 proc~self_great_i2p self_great_I2P proc~self_great_i2p->proc~norml2 proc~self_great_i4p self_great_I4P proc~self_great_i4p->proc~norml2 proc~self_great_i8p self_great_I8P proc~self_great_i8p->proc~norml2 proc~self_not_eq_i4p self_not_eq_I4P proc~self_not_eq_i4p->proc~norml2 proc~self_great_r16p self_great_R16P proc~self_great_r16p->proc~norml2 proc~self_great_r4p self_great_R4P proc~self_great_r4p->proc~norml2 proc~self_great_r8p self_great_R8P proc~self_great_r8p->proc~norml2 proc~self_great_eq_i1p self_great_eq_I1P proc~self_great_eq_i1p->proc~norml2 proc~self_great_eq_i2p self_great_eq_I2P proc~self_great_eq_i2p->proc~norml2 proc~self_great_eq_i4p self_great_eq_I4P proc~self_great_eq_i4p->proc~norml2 proc~self_not_eq_i8p self_not_eq_I8P proc~self_not_eq_i8p->proc~norml2 proc~self_great_eq_i8p self_great_eq_I8P proc~self_great_eq_i8p->proc~norml2 proc~self_great_eq_r16p self_great_eq_R16P proc~self_great_eq_r16p->proc~norml2 proc~normalized_self normalized_self proc~normalized_self->proc~norml2 proc~self_great_eq_r4p self_great_eq_R4P proc~self_great_eq_r4p->proc~norml2 proc~self_great_eq_r8p self_great_eq_R8P proc~self_great_eq_r8p->proc~norml2 proc~parallel parallel proc~parallel->proc~norml2 proc~parallel->proc~normalize proc~self_great_eq_self self_great_eq_self proc~self_great_eq_self->proc~norml2 proc~self_great_self self_great_self proc~self_great_self->proc~norml2 proc~self_not_eq_r16p self_not_eq_R16P proc~self_not_eq_r16p->proc~norml2 proc~self_low_i1p self_low_I1P proc~self_low_i1p->proc~norml2 proc~self_low_i2p self_low_I2P proc~self_low_i2p->proc~norml2 proc~self_low_i4p self_low_I4P proc~self_low_i4p->proc~norml2 proc~i4p_low_eq_self I4P_low_eq_self proc~i4p_low_eq_self->proc~norml2 proc~self_low_i8p self_low_I8P proc~self_low_i8p->proc~norml2 proc~i4p_low_self I4P_low_self proc~i4p_low_self->proc~norml2 proc~self_low_r16p self_low_R16P proc~self_low_r16p->proc~norml2 proc~i4p_not_eq_self I4P_not_eq_self proc~i4p_not_eq_self->proc~norml2 proc~self_not_eq_r4p self_not_eq_R4P proc~self_not_eq_r4p->proc~norml2 proc~self_low_r4p self_low_R4P proc~self_low_r4p->proc~norml2 proc~i8p_eq_self I8P_eq_self proc~i8p_eq_self->proc~norml2 proc~r4p_great_eq_self R4P_great_eq_self proc~r4p_great_eq_self->proc~norml2 proc~self_low_r8p self_low_R8P proc~self_low_r8p->proc~norml2 proc~i8p_great_eq_self I8P_great_eq_self proc~i8p_great_eq_self->proc~norml2 proc~self_low_eq_i1p self_low_eq_I1P proc~self_low_eq_i1p->proc~norml2 proc~i8p_great_self I8P_great_self proc~i8p_great_self->proc~norml2 proc~self_low_eq_i2p self_low_eq_I2P proc~self_low_eq_i2p->proc~norml2 proc~i8p_low_eq_self I8P_low_eq_self proc~i8p_low_eq_self->proc~norml2 proc~self_low_eq_i4p self_low_eq_I4P proc~self_low_eq_i4p->proc~norml2 proc~i8p_low_self I8P_low_self proc~i8p_low_self->proc~norml2 proc~self_low_eq_i8p self_low_eq_I8P proc~self_low_eq_i8p->proc~norml2 proc~i8p_not_eq_self I8P_not_eq_self proc~i8p_not_eq_self->proc~norml2 proc~self_not_eq_r8p self_not_eq_R8P proc~self_not_eq_r8p->proc~norml2 proc~self_low_eq_r16p self_low_eq_R16P proc~self_low_eq_r16p->proc~norml2 proc~r16p_eq_self R16P_eq_self proc~r16p_eq_self->proc~norml2 proc~r4p_great_self R4P_great_self proc~r4p_great_self->proc~norml2 proc~self_low_eq_r4p self_low_eq_R4P proc~self_low_eq_r4p->proc~norml2 proc~r16p_great_eq_self R16P_great_eq_self proc~r16p_great_eq_self->proc~norml2 proc~self_low_eq_r8p self_low_eq_R8P proc~self_low_eq_r8p->proc~norml2 proc~r16p_great_self R16P_great_self proc~r16p_great_self->proc~norml2 proc~normalize_self normalize_self proc~normalize_self->proc~norml2 proc~self_low_eq_self self_low_eq_self proc~self_low_eq_self->proc~norml2 proc~r16p_low_eq_self R16P_low_eq_self proc~r16p_low_eq_self->proc~norml2 proc~self_low_self self_low_self proc~self_low_self->proc~norml2 proc~r16p_low_self R16P_low_self proc~r16p_low_self->proc~norml2 proc~r16p_not_eq_self R16P_not_eq_self proc~r16p_not_eq_self->proc~norml2 proc~self_not_eq_self self_not_eq_self proc~self_not_eq_self->proc~norml2 proc~self_not_eq_self->proc~normalize proc~r4p_eq_self R4P_eq_self proc~r4p_eq_self->proc~norml2 proc~i1p_eq_self I1P_eq_self proc~i1p_eq_self->proc~norml2 proc~i1p_great_eq_self I1P_great_eq_self proc~i1p_great_eq_self->proc~norml2 proc~r4p_low_eq_self R4P_low_eq_self proc~r4p_low_eq_self->proc~norml2 proc~i1p_great_self I1P_great_self proc~i1p_great_self->proc~norml2 proc~r4p_low_self R4P_low_self proc~r4p_low_self->proc~norml2 proc~i1p_low_eq_self I1P_low_eq_self proc~i1p_low_eq_self->proc~norml2 proc~r4p_not_eq_self R4P_not_eq_self proc~r4p_not_eq_self->proc~norml2 proc~i1p_low_self I1P_low_self proc~i1p_low_self->proc~norml2 proc~r8p_eq_self R8P_eq_self proc~r8p_eq_self->proc~norml2 proc~i1p_not_eq_self I1P_not_eq_self proc~i1p_not_eq_self->proc~norml2 proc~r8p_great_eq_self R8P_great_eq_self proc~r8p_great_eq_self->proc~norml2 proc~i2p_eq_self I2P_eq_self proc~i2p_eq_self->proc~norml2 proc~r8p_great_self R8P_great_self proc~r8p_great_self->proc~norml2 proc~i2p_great_eq_self I2P_great_eq_self proc~i2p_great_eq_self->proc~norml2 proc~r8p_low_eq_self R8P_low_eq_self proc~r8p_low_eq_self->proc~norml2 proc~i2p_great_self I2P_great_self proc~i2p_great_self->proc~norml2 proc~r8p_low_self R8P_low_self proc~r8p_low_self->proc~norml2 proc~i2p_low_eq_self I2P_low_eq_self proc~i2p_low_eq_self->proc~norml2 proc~r8p_not_eq_self R8P_not_eq_self proc~r8p_not_eq_self->proc~norml2 proc~i2p_low_self I2P_low_self proc~i2p_low_self->proc~norml2 proc~normalize->proc~norml2 proc~i2p_not_eq_self I2P_not_eq_self proc~i2p_not_eq_self->proc~norml2 proc~i4p_eq_self I4P_eq_self proc~i4p_eq_self->proc~norml2 proc~i4p_great_eq_self I4P_great_eq_self proc~i4p_great_eq_self->proc~norml2 proc~i4p_great_self I4P_great_self proc~i4p_great_self->proc~norml2 proc~face_normal4 face_normal4 proc~face_normal4->proc~normalize proc~face_normal4_self face_normal4_self proc~face_normal4_self->proc~normalize proc~face_normal3 face_normal3 proc~face_normal3->proc~normalize proc~face_normal3_self face_normal3_self proc~face_normal3_self->proc~normalize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code normL2 Source Code elemental function normL2 ( vec ) result ( norm ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the norm L2 of a vector. !< !< The norm L2 if defined as  N = \\sqrt {x&#94;2  + y&#94;2  + z&#94;2 } . !--------------------------------------------------------------------------------------------------------------------------------- type ( Vector ), intent ( IN ) :: vec !< Vector. real ( R8P ) :: norm !< Norm L2. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- norm = sqrt (( vec % x * vec % x ) + ( vec % y * vec % y ) + ( vec % z * vec % z )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction normL2","tags":"","loc":"proc/norml2.html","title":"normL2 – FLOw"},{"text":"private elemental function normL2_self(vec) result(norm) Compute the norm L2 of a vector. The norm L2 if defined as  N = \\sqrt {x&#94;2  + y&#94;2  + z&#94;2 } . Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: vec Vector. Return Value real(kind=R8P) Norm L2. Source Code normL2_self Source Code elemental function normL2_self ( vec ) result ( norm ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the norm L2 of a vector. !< !< The norm L2 if defined as  N = \\sqrt {x&#94;2  + y&#94;2  + z&#94;2 } . !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: vec !< Vector. real ( R8P ) :: norm !< Norm L2. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- norm = sqrt (( vec % x * vec % x ) + ( vec % y * vec % y ) + ( vec % z * vec % z )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction normL2_self","tags":"","loc":"proc/norml2_self.html","title":"normL2_self – FLOw"},{"text":"public elemental function normalize(vec) result(norm) Normalize a vector. The normalization is made by means of norm L2. If the norm L2 of the vector is less than the parameter smallR8P the\n normalization value is set to normL2(vec)+smallR8P. Arguments Type Intent Optional Attributes Name type( Vector ), intent(in) :: vec Vector to be normalized. Return Value type( Vector ) Vector normalized. Calls proc~~normalize~~CallsGraph proc~normalize normalize proc~norml2 normL2 proc~normalize->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Called By proc~~normalize~~CalledByGraph proc~normalize normalize proc~face_normal4 face_normal4 proc~face_normal4->proc~normalize proc~self_eq_self self_eq_self proc~self_eq_self->proc~normalize proc~self_not_eq_self self_not_eq_self proc~self_not_eq_self->proc~normalize proc~face_normal4_self face_normal4_self proc~face_normal4_self->proc~normalize proc~parallel parallel proc~parallel->proc~normalize proc~face_normal3 face_normal3 proc~face_normal3->proc~normalize proc~face_normal3_self face_normal3_self proc~face_normal3_self->proc~normalize Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code normalize Source Code elemental function normalize ( vec ) result ( norm ) !--------------------------------------------------------------------------------------------------------------------------------- !< Normalize a vector. !< !< The normalization is made by means of norm L2. If the norm L2 of the vector is less than the parameter smallR8P the !< normalization value is set to normL2(vec)+smallR8P. !--------------------------------------------------------------------------------------------------------------------------------- type ( Vector ), intent ( IN ) :: vec !< Vector to be normalized. type ( Vector ) :: norm !< Vector normalized. real ( R8P ) :: nm !< Norm L2 of vector. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- nm = normL2 ( vec ) if ( nm < smallR8P ) then nm = nm + smallR8P endif norm % x = vec % x / nm norm % y = vec % y / nm norm % z = vec % z / nm return !--------------------------------------------------------------------------------------------------------------------------------- endfunction normalize","tags":"","loc":"proc/normalize.html","title":"normalize – FLOw"},{"text":"private elemental function normalized_self(vec) result(norm) Get a normalized copy of a vector. The normalization is made by means of norm L2. If the norm L2 of the vector is less than the parameter smallR8P the\n normalization value is set to normL2(vec)+smallR8P. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: vec Vector to be normalized. Return Value type( Vector ) Normalized copy. Calls proc~~normalized_self~~CallsGraph proc~normalized_self normalized_self proc~norml2 normL2 proc~normalized_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code normalized_self Source Code elemental function normalized_self ( vec ) result ( norm ) !--------------------------------------------------------------------------------------------------------------------------------- !< Get a normalized copy of a vector. !< !< The normalization is made by means of norm L2. If the norm L2 of the vector is less than the parameter smallR8P the !< normalization value is set to normL2(vec)+smallR8P. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: vec !< Vector to be normalized. type ( Vector ) :: norm !< Normalized copy. real ( R8P ) :: nm !< Norm L2 of vector. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- nm = normL2 ( vec ) if ( nm < smallR8P ) then nm = nm + smallR8P endif norm % x = vec % x / nm norm % y = vec % y / nm norm % z = vec % z / nm return !--------------------------------------------------------------------------------------------------------------------------------- endfunction normalized_self","tags":"","loc":"proc/normalized_self.html","title":"normalized_self – FLOw"},{"text":"private elemental function orthogonal(vec1, vec2) result(ortho) Compute the component of vec1 orthogonal to vec2. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: vec1 First vector. type( Vector ), intent(in) :: vec2 Second vector. Return Value type( Vector ) Component of of vec1 orthogonal to vec2. Source Code orthogonal Source Code elemental function orthogonal ( vec1 , vec2 ) result ( ortho ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the component of vec1 orthogonal to vec2. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: vec1 !< First vector. type ( Vector ), intent ( IN ) :: vec2 !< Second vector. type ( Vector ) :: ortho !< Component of of vec1 orthogonal to vec2. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- ortho = vec1 - ( vec1 . paral . vec2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction orthogonal","tags":"","loc":"proc/orthogonal.html","title":"orthogonal – FLOw"},{"text":"private elemental function parallel(vec1, vec2) result(paral) Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: vec1 Compute the component of vec1 parallel to vec2.\n First vector. type( Vector ), intent(in) :: vec2 Second vector. Return Value type( Vector ) Component of of vec1 parallel to vec2. Calls proc~~parallel~~CallsGraph proc~parallel parallel proc~norml2 normL2 proc~parallel->proc~norml2 proc~normalize normalize proc~parallel->proc~normalize proc~normalize->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code parallel Source Code elemental function parallel ( vec1 , vec2 ) result ( paral ) !--------------------------------------------------------------------------------------------------------------------------------- !> Compute the component of vec1 parallel to vec2. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: vec1 !< First vector. type ( Vector ), intent ( IN ) :: vec2 !< Second vector. type ( Vector ) :: paral !< Component of of vec1 parallel to vec2. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- paral = ( vec1 . dot . vec2 ) * normalize ( vec2 ) / normL2 ( vec2 ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction parallel","tags":"","loc":"proc/parallel.html","title":"parallel – FLOw"},{"text":"private elemental function positive_self(self) result(pos) Applay unary + to a self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self Return Value type( Vector ) Source Code positive_self Source Code elemental function positive_self ( self ) result ( pos ) !--------------------------------------------------------------------------------------------------------------------------------- !< Applay unary + to a self. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self type ( Vector ) :: pos !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- pos % x = + self % x pos % y = + self % y pos % z = + self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction positive_self","tags":"","loc":"proc/positive_self.html","title":"positive_self – FLOw"},{"text":"private elemental function self_div_ScalI1P(self, scal) result(div) Divide self for scalar (integer I1P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value type( Vector ) Source Code self_div_ScalI1P Source Code elemental function self_div_ScalI1P ( self , scal ) result ( div ) !--------------------------------------------------------------------------------------------------------------------------------- !< Divide self for scalar (integer I1P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I1P ), intent ( IN ) :: scal type ( Vector ) :: div !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- div % x = self % x / real ( scal , R8P ) div % y = self % y / real ( scal , R8P ) div % z = self % z / real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_div_ScalI1P","tags":"","loc":"proc/self_div_scali1p.html","title":"self_div_ScalI1P – FLOw"},{"text":"private elemental function self_div_ScalI2P(self, scal) result(div) Divide self for scalar (integer I2P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value type( Vector ) Source Code self_div_ScalI2P Source Code elemental function self_div_ScalI2P ( self , scal ) result ( div ) !--------------------------------------------------------------------------------------------------------------------------------- !< Divide self for scalar (integer I2P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I2P ), intent ( IN ) :: scal type ( Vector ) :: div !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- div % x = self % x / real ( scal , R8P ) div % y = self % y / real ( scal , R8P ) div % z = self % z / real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_div_ScalI2P","tags":"","loc":"proc/self_div_scali2p.html","title":"self_div_ScalI2P – FLOw"},{"text":"private elemental function self_div_ScalI4P(self, scal) result(div) Divide self for scalar (integer I4P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value type( Vector ) Source Code self_div_ScalI4P Source Code elemental function self_div_ScalI4P ( self , scal ) result ( div ) !--------------------------------------------------------------------------------------------------------------------------------- !< Divide self for scalar (integer I4P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I4P ), intent ( IN ) :: scal type ( Vector ) :: div !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- div % x = self % x / real ( scal , R8P ) div % y = self % y / real ( scal , R8P ) div % z = self % z / real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_div_ScalI4P","tags":"","loc":"proc/self_div_scali4p.html","title":"self_div_ScalI4P – FLOw"},{"text":"private elemental function self_div_ScalI8P(self, scal) result(div) Divide self for scalar (integer I8P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value type( Vector ) Source Code self_div_ScalI8P Source Code elemental function self_div_ScalI8P ( self , scal ) result ( div ) !--------------------------------------------------------------------------------------------------------------------------------- !< Divide self for scalar (integer I8P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I8P ), intent ( IN ) :: scal type ( Vector ) :: div !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- div % x = self % x / real ( scal , R8P ) div % y = self % y / real ( scal , R8P ) div % z = self % z / real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_div_ScalI8P","tags":"","loc":"proc/self_div_scali8p.html","title":"self_div_ScalI8P – FLOw"},{"text":"private elemental function self_div_ScalR16P(self, scal) result(div) Divide self for scalar (real R16P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R16P), intent(in) :: scal Return Value type( Vector ) Source Code self_div_ScalR16P Source Code elemental function self_div_ScalR16P ( self , scal ) result ( div ) !--------------------------------------------------------------------------------------------------------------------------------- !< Divide self for scalar (real R16P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self real ( R16P ), intent ( IN ) :: scal type ( Vector ) :: div !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- div % x = self % x / real ( scal , R8P ) div % y = self % y / real ( scal , R8P ) div % z = self % z / real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_div_ScalR16P","tags":"","loc":"proc/self_div_scalr16p.html","title":"self_div_ScalR16P – FLOw"},{"text":"private elemental function self_div_ScalR4P(self, scal) result(div) Divide self for scalar (real R4P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value type( Vector ) Source Code self_div_ScalR4P Source Code elemental function self_div_ScalR4P ( self , scal ) result ( div ) !--------------------------------------------------------------------------------------------------------------------------------- !< Divide self for scalar (real R4P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self real ( R4P ), intent ( IN ) :: scal type ( Vector ) :: div !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- div % x = self % x / real ( scal , R8P ) div % y = self % y / real ( scal , R8P ) div % z = self % z / real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_div_ScalR4P","tags":"","loc":"proc/self_div_scalr4p.html","title":"self_div_ScalR4P – FLOw"},{"text":"private elemental function self_div_ScalR8P(self, scal) result(div) Divide self for scalar (real R8P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value type( Vector ) Source Code self_div_ScalR8P Source Code elemental function self_div_ScalR8P ( self , scal ) result ( div ) !--------------------------------------------------------------------------------------------------------------------------------- !< Divide self for scalar (real R8P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self real ( R8P ), intent ( IN ) :: scal type ( Vector ) :: div !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- div % x = self % x / real ( scal , R8P ) div % y = self % y / real ( scal , R8P ) div % z = self % z / real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_div_ScalR8P","tags":"","loc":"proc/self_div_scalr8p.html","title":"self_div_ScalR8P – FLOw"},{"text":"private elemental function self_div_self(self1, self2) result(div) Divide self for self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 type( Vector ), intent(in) :: self2 Return Value type( Vector ) Source Code self_div_self Source Code elemental function self_div_self ( self1 , self2 ) result ( div ) !--------------------------------------------------------------------------------------------------------------------------------- !< Divide self for self. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self1 type ( Vector ), intent ( IN ) :: self2 type ( Vector ) :: div !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- div % x = self1 % x / self2 % x div % y = self1 % y / self2 % y div % z = self1 % z / self2 % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_div_self","tags":"","loc":"proc/self_div_self.html","title":"self_div_self – FLOw"},{"text":"private elemental function self_eq_I1P(self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value logical Calls proc~~self_eq_i1p~~CallsGraph proc~self_eq_i1p self_eq_I1P proc~norml2 normL2 proc~self_eq_i1p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_eq_I1P Source Code elemental function self_eq_I1P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. integer ( I1P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) == real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_eq_I1P","tags":"","loc":"proc/self_eq_i1p.html","title":"self_eq_I1P – FLOw"},{"text":"private elemental function self_eq_I2P(self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value logical Calls proc~~self_eq_i2p~~CallsGraph proc~self_eq_i2p self_eq_I2P proc~norml2 normL2 proc~self_eq_i2p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_eq_I2P Source Code elemental function self_eq_I2P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. integer ( I2P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) == real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_eq_I2P","tags":"","loc":"proc/self_eq_i2p.html","title":"self_eq_I2P – FLOw"},{"text":"private elemental function self_eq_I4P(self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value logical Calls proc~~self_eq_i4p~~CallsGraph proc~self_eq_i4p self_eq_I4P proc~norml2 normL2 proc~self_eq_i4p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_eq_I4P Source Code elemental function self_eq_I4P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. integer ( I4P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) == real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_eq_I4P","tags":"","loc":"proc/self_eq_i4p.html","title":"self_eq_I4P – FLOw"},{"text":"private elemental function self_eq_I8P(self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value logical Calls proc~~self_eq_i8p~~CallsGraph proc~self_eq_i8p self_eq_I8P proc~norml2 normL2 proc~self_eq_i8p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_eq_I8P Source Code elemental function self_eq_I8P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. integer ( I8P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) == real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_eq_I8P","tags":"","loc":"proc/self_eq_i8p.html","title":"self_eq_I8P – FLOw"},{"text":"private elemental function self_eq_R16P(self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R16P), intent(in) :: scal Return Value logical Calls proc~~self_eq_r16p~~CallsGraph proc~self_eq_r16p self_eq_R16P proc~norml2 normL2 proc~self_eq_r16p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_eq_R16P Source Code elemental function self_eq_R16P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. real ( R16P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) == real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_eq_R16P","tags":"","loc":"proc/self_eq_r16p.html","title":"self_eq_R16P – FLOw"},{"text":"private elemental function self_eq_R4P(self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value logical Calls proc~~self_eq_r4p~~CallsGraph proc~self_eq_r4p self_eq_R4P proc~norml2 normL2 proc~self_eq_r4p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_eq_R4P Source Code elemental function self_eq_R4P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. real ( R4P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) == real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_eq_R4P","tags":"","loc":"proc/self_eq_r4p.html","title":"self_eq_R4P – FLOw"},{"text":"private elemental function self_eq_R8P(self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value logical Calls proc~~self_eq_r8p~~CallsGraph proc~self_eq_r8p self_eq_R8P proc~norml2 normL2 proc~self_eq_r8p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_eq_R8P Source Code elemental function self_eq_R8P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. real ( R8P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) == real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_eq_R8P","tags":"","loc":"proc/self_eq_r8p.html","title":"self_eq_R8P – FLOw"},{"text":"private elemental function self_eq_self(self1, self2) result(compare) Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 Return .true. if the normL2 of the self1 is = with respect the normL2 of self2 and the directions of\n self1 and self2 are the same, .false. otherwise. type( Vector ), intent(in) :: self2 Return Value logical Calls proc~~self_eq_self~~CallsGraph proc~self_eq_self self_eq_self proc~norml2 normL2 proc~self_eq_self->proc~norml2 proc~normalize normalize proc~self_eq_self->proc~normalize proc~normalize->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_eq_self Source Code elemental function self_eq_self ( self1 , self2 ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !> Return .true. if the normL2 of the self1 is = with respect the normL2 of self2 and the directions of !> self1 and self2 are the same, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self1 ! First selftor. type ( Vector ), intent ( IN ) :: self2 ! Second selftor. logical :: compare ! The result of the comparison. type ( Vector ) :: n1 ! Normalizations of self1. type ( Vector ) :: n2 ! Normalizations of self2. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self1 ) == normL2 ( self2 )) if ( compare ) then ! the normL2 are the same, checking the directions n1 = normalize ( self1 ) n2 = normalize ( self2 ) compare = (( n1 % x == n2 % x ). AND .( n1 % y == n2 % y ). AND .( n1 % z == n2 % z )) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_eq_self","tags":"","loc":"proc/self_eq_self.html","title":"self_eq_self – FLOw"},{"text":"private elemental function self_great_I1P(self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value logical Calls proc~~self_great_i1p~~CallsGraph proc~self_great_i1p self_great_I1P proc~norml2 normL2 proc~self_great_i1p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_great_I1P Source Code elemental function self_great_I1P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. integer ( I1P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) > real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_great_I1P","tags":"","loc":"proc/self_great_i1p.html","title":"self_great_I1P – FLOw"},{"text":"private elemental function self_great_I2P(self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value logical Calls proc~~self_great_i2p~~CallsGraph proc~self_great_i2p self_great_I2P proc~norml2 normL2 proc~self_great_i2p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_great_I2P Source Code elemental function self_great_I2P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. integer ( I2P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) > real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_great_I2P","tags":"","loc":"proc/self_great_i2p.html","title":"self_great_I2P – FLOw"},{"text":"private elemental function self_great_I4P(self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value logical Calls proc~~self_great_i4p~~CallsGraph proc~self_great_i4p self_great_I4P proc~norml2 normL2 proc~self_great_i4p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_great_I4P Source Code elemental function self_great_I4P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. integer ( I4P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) > real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_great_I4P","tags":"","loc":"proc/self_great_i4p.html","title":"self_great_I4P – FLOw"},{"text":"private elemental function self_great_I8P(self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value logical Calls proc~~self_great_i8p~~CallsGraph proc~self_great_i8p self_great_I8P proc~norml2 normL2 proc~self_great_i8p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_great_I8P Source Code elemental function self_great_I8P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. integer ( I8P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) > real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_great_I8P","tags":"","loc":"proc/self_great_i8p.html","title":"self_great_I8P – FLOw"},{"text":"private elemental function self_great_R16P(self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R16P), intent(in) :: scal Return Value logical Calls proc~~self_great_r16p~~CallsGraph proc~self_great_r16p self_great_R16P proc~norml2 normL2 proc~self_great_r16p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_great_R16P Source Code elemental function self_great_R16P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. real ( R16P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) > real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_great_R16P","tags":"","loc":"proc/self_great_r16p.html","title":"self_great_R16P – FLOw"},{"text":"private elemental function self_great_R4P(self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value logical Calls proc~~self_great_r4p~~CallsGraph proc~self_great_r4p self_great_R4P proc~norml2 normL2 proc~self_great_r4p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_great_R4P Source Code elemental function self_great_R4P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. real ( R4P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) > real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_great_R4P","tags":"","loc":"proc/self_great_r4p.html","title":"self_great_R4P – FLOw"},{"text":"private elemental function self_great_R8P(self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value logical Calls proc~~self_great_r8p~~CallsGraph proc~self_great_r8p self_great_R8P proc~norml2 normL2 proc~self_great_r8p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_great_R8P Source Code elemental function self_great_R8P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. real ( R8P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) > real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_great_R8P","tags":"","loc":"proc/self_great_r8p.html","title":"self_great_R8P – FLOw"},{"text":"private elemental function self_great_eq_I1P(self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value logical Calls proc~~self_great_eq_i1p~~CallsGraph proc~self_great_eq_i1p self_great_eq_I1P proc~norml2 normL2 proc~self_great_eq_i1p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_great_eq_I1P Source Code elemental function self_great_eq_I1P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. integer ( I1P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) >= real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_great_eq_I1P","tags":"","loc":"proc/self_great_eq_i1p.html","title":"self_great_eq_I1P – FLOw"},{"text":"private elemental function self_great_eq_I2P(self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value logical Calls proc~~self_great_eq_i2p~~CallsGraph proc~self_great_eq_i2p self_great_eq_I2P proc~norml2 normL2 proc~self_great_eq_i2p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_great_eq_I2P Source Code elemental function self_great_eq_I2P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. integer ( I2P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) >= real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_great_eq_I2P","tags":"","loc":"proc/self_great_eq_i2p.html","title":"self_great_eq_I2P – FLOw"},{"text":"private elemental function self_great_eq_I4P(self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value logical Calls proc~~self_great_eq_i4p~~CallsGraph proc~self_great_eq_i4p self_great_eq_I4P proc~norml2 normL2 proc~self_great_eq_i4p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_great_eq_I4P Source Code elemental function self_great_eq_I4P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. integer ( I4P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) >= real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_great_eq_I4P","tags":"","loc":"proc/self_great_eq_i4p.html","title":"self_great_eq_I4P – FLOw"},{"text":"private elemental function self_great_eq_I8P(self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value logical Calls proc~~self_great_eq_i8p~~CallsGraph proc~self_great_eq_i8p self_great_eq_I8P proc~norml2 normL2 proc~self_great_eq_i8p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_great_eq_I8P Source Code elemental function self_great_eq_I8P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. integer ( I8P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) >= real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_great_eq_I8P","tags":"","loc":"proc/self_great_eq_i8p.html","title":"self_great_eq_I8P – FLOw"},{"text":"private elemental function self_great_eq_R16P(self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R16P), intent(in) :: scal Return Value logical Calls proc~~self_great_eq_r16p~~CallsGraph proc~self_great_eq_r16p self_great_eq_R16P proc~norml2 normL2 proc~self_great_eq_r16p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_great_eq_R16P Source Code elemental function self_great_eq_R16P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. real ( R16P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) >= real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_great_eq_R16P","tags":"","loc":"proc/self_great_eq_r16p.html","title":"self_great_eq_R16P – FLOw"},{"text":"private elemental function self_great_eq_R4P(self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value logical Calls proc~~self_great_eq_r4p~~CallsGraph proc~self_great_eq_r4p self_great_eq_R4P proc~norml2 normL2 proc~self_great_eq_r4p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_great_eq_R4P Source Code elemental function self_great_eq_R4P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. real ( R4P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) >= real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_great_eq_R4P","tags":"","loc":"proc/self_great_eq_r4p.html","title":"self_great_eq_R4P – FLOw"},{"text":"private elemental function self_great_eq_R8P(self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value logical Calls proc~~self_great_eq_r8p~~CallsGraph proc~self_great_eq_r8p self_great_eq_R8P proc~norml2 normL2 proc~self_great_eq_r8p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_great_eq_R8P Source Code elemental function self_great_eq_R8P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. real ( R8P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) >= real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_great_eq_R8P","tags":"","loc":"proc/self_great_eq_r8p.html","title":"self_great_eq_R8P – FLOw"},{"text":"private elemental function self_great_eq_self(self1, self2) result(compare) Return .true. if the normL2 of the self1 is >= with respect the normL2 of self2, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 type( Vector ), intent(in) :: self2 Return Value logical Calls proc~~self_great_eq_self~~CallsGraph proc~self_great_eq_self self_great_eq_self proc~norml2 normL2 proc~self_great_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_great_eq_self Source Code elemental function self_great_eq_self ( self1 , self2 ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is >= with respect the normL2 of self2, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self1 ! First selftor. type ( Vector ), intent ( IN ) :: self2 ! Second selftor. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self1 ) >= normL2 ( self2 )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_great_eq_self","tags":"","loc":"proc/self_great_eq_self.html","title":"self_great_eq_self – FLOw"},{"text":"private elemental function self_great_self(self1, self2) result(compare) Return .true. if the normL2 of the self1 is > with respect the normL2 of self2, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 type( Vector ), intent(in) :: self2 Return Value logical Calls proc~~self_great_self~~CallsGraph proc~self_great_self self_great_self proc~norml2 normL2 proc~self_great_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_great_self Source Code elemental function self_great_self ( self1 , self2 ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is > with respect the normL2 of self2, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self1 ! First selftor. type ( Vector ), intent ( IN ) :: self2 ! Second selftor. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self1 ) > normL2 ( self2 )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_great_self","tags":"","loc":"proc/self_great_self.html","title":"self_great_self – FLOw"},{"text":"private elemental function self_low_I1P(self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value logical Calls proc~~self_low_i1p~~CallsGraph proc~self_low_i1p self_low_I1P proc~norml2 normL2 proc~self_low_i1p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_low_I1P Source Code elemental function self_low_I1P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I1P ), intent ( IN ) :: scal logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) < real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_low_I1P","tags":"","loc":"proc/self_low_i1p.html","title":"self_low_I1P – FLOw"},{"text":"private elemental function self_low_I2P(self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value logical Calls proc~~self_low_i2p~~CallsGraph proc~self_low_i2p self_low_I2P proc~norml2 normL2 proc~self_low_i2p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_low_I2P Source Code elemental function self_low_I2P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I2P ), intent ( IN ) :: scal logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) < real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_low_I2P","tags":"","loc":"proc/self_low_i2p.html","title":"self_low_I2P – FLOw"},{"text":"private elemental function self_low_I4P(self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value logical Calls proc~~self_low_i4p~~CallsGraph proc~self_low_i4p self_low_I4P proc~norml2 normL2 proc~self_low_i4p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_low_I4P Source Code elemental function self_low_I4P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I4P ), intent ( IN ) :: scal logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) < real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_low_I4P","tags":"","loc":"proc/self_low_i4p.html","title":"self_low_I4P – FLOw"},{"text":"private elemental function self_low_I8P(self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value logical Calls proc~~self_low_i8p~~CallsGraph proc~self_low_i8p self_low_I8P proc~norml2 normL2 proc~self_low_i8p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_low_I8P Source Code elemental function self_low_I8P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I8P ), intent ( IN ) :: scal logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) < real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_low_I8P","tags":"","loc":"proc/self_low_i8p.html","title":"self_low_I8P – FLOw"},{"text":"private elemental function self_low_R16P(self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R16P), intent(in) :: scal Return Value logical Calls proc~~self_low_r16p~~CallsGraph proc~self_low_r16p self_low_R16P proc~norml2 normL2 proc~self_low_r16p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_low_R16P Source Code elemental function self_low_R16P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self real ( R16P ), intent ( IN ) :: scal logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) < real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_low_R16P","tags":"","loc":"proc/self_low_r16p.html","title":"self_low_R16P – FLOw"},{"text":"private elemental function self_low_R4P(self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value logical Calls proc~~self_low_r4p~~CallsGraph proc~self_low_r4p self_low_R4P proc~norml2 normL2 proc~self_low_r4p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_low_R4P Source Code elemental function self_low_R4P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self real ( R4P ), intent ( IN ) :: scal logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) < real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_low_R4P","tags":"","loc":"proc/self_low_r4p.html","title":"self_low_R4P – FLOw"},{"text":"private elemental function self_low_R8P(self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value logical Calls proc~~self_low_r8p~~CallsGraph proc~self_low_r8p self_low_R8P proc~norml2 normL2 proc~self_low_r8p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_low_R8P Source Code elemental function self_low_R8P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self real ( R8P ), intent ( IN ) :: scal logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) < real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_low_R8P","tags":"","loc":"proc/self_low_r8p.html","title":"self_low_R8P – FLOw"},{"text":"private elemental function self_low_eq_I1P(self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value logical Calls proc~~self_low_eq_i1p~~CallsGraph proc~self_low_eq_i1p self_low_eq_I1P proc~norml2 normL2 proc~self_low_eq_i1p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_low_eq_I1P Source Code elemental function self_low_eq_I1P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. integer ( I1P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) <= real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_low_eq_I1P","tags":"","loc":"proc/self_low_eq_i1p.html","title":"self_low_eq_I1P – FLOw"},{"text":"private elemental function self_low_eq_I2P(self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value logical Calls proc~~self_low_eq_i2p~~CallsGraph proc~self_low_eq_i2p self_low_eq_I2P proc~norml2 normL2 proc~self_low_eq_i2p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_low_eq_I2P Source Code elemental function self_low_eq_I2P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. integer ( I2P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) <= real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_low_eq_I2P","tags":"","loc":"proc/self_low_eq_i2p.html","title":"self_low_eq_I2P – FLOw"},{"text":"private elemental function self_low_eq_I4P(self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value logical Calls proc~~self_low_eq_i4p~~CallsGraph proc~self_low_eq_i4p self_low_eq_I4P proc~norml2 normL2 proc~self_low_eq_i4p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_low_eq_I4P Source Code elemental function self_low_eq_I4P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. integer ( I4P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) <= real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_low_eq_I4P","tags":"","loc":"proc/self_low_eq_i4p.html","title":"self_low_eq_I4P – FLOw"},{"text":"private elemental function self_low_eq_I8P(self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value logical Calls proc~~self_low_eq_i8p~~CallsGraph proc~self_low_eq_i8p self_low_eq_I8P proc~norml2 normL2 proc~self_low_eq_i8p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_low_eq_I8P Source Code elemental function self_low_eq_I8P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. integer ( I8P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) <= real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_low_eq_I8P","tags":"","loc":"proc/self_low_eq_i8p.html","title":"self_low_eq_I8P – FLOw"},{"text":"private elemental function self_low_eq_R16P(self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R16P), intent(in) :: scal Return Value logical Calls proc~~self_low_eq_r16p~~CallsGraph proc~self_low_eq_r16p self_low_eq_R16P proc~norml2 normL2 proc~self_low_eq_r16p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_low_eq_R16P Source Code elemental function self_low_eq_R16P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. real ( R16P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) <= real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_low_eq_R16P","tags":"","loc":"proc/self_low_eq_r16p.html","title":"self_low_eq_R16P – FLOw"},{"text":"private elemental function self_low_eq_R4P(self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value logical Calls proc~~self_low_eq_r4p~~CallsGraph proc~self_low_eq_r4p self_low_eq_R4P proc~norml2 normL2 proc~self_low_eq_r4p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_low_eq_R4P Source Code elemental function self_low_eq_R4P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. real ( R4P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) <= real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_low_eq_R4P","tags":"","loc":"proc/self_low_eq_r4p.html","title":"self_low_eq_R4P – FLOw"},{"text":"private elemental function self_low_eq_R8P(self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value logical Calls proc~~self_low_eq_r8p~~CallsGraph proc~self_low_eq_r8p self_low_eq_R8P proc~norml2 normL2 proc~self_low_eq_r8p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_low_eq_R8P Source Code elemental function self_low_eq_R8P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self ! Vector. real ( R8P ), intent ( IN ) :: scal ! Scalar. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self ) <= real ( scal , R8P )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_low_eq_R8P","tags":"","loc":"proc/self_low_eq_r8p.html","title":"self_low_eq_R8P – FLOw"},{"text":"private elemental function self_low_eq_self(self1, self2) result(compare) Return .true. if the normL2 of the self1 is <= with respect the normL2 of self2, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 type( Vector ), intent(in) :: self2 Return Value logical Calls proc~~self_low_eq_self~~CallsGraph proc~self_low_eq_self self_low_eq_self proc~norml2 normL2 proc~self_low_eq_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_low_eq_self Source Code elemental function self_low_eq_self ( self1 , self2 ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is <= with respect the normL2 of self2, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self1 ! First selftor. type ( Vector ), intent ( IN ) :: self2 ! Second selftor. logical :: compare ! The result of the comparison. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self1 ) <= normL2 ( self2 )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_low_eq_self","tags":"","loc":"proc/self_low_eq_self.html","title":"self_low_eq_self – FLOw"},{"text":"private elemental function self_low_self(self1, self2) result(compare) Return .true. if the normL2 of the self1 is < with respect the normL2 of self2, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 type( Vector ), intent(in) :: self2 Return Value logical Calls proc~~self_low_self~~CallsGraph proc~self_low_self self_low_self proc~norml2 normL2 proc~self_low_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_low_self Source Code elemental function self_low_self ( self1 , self2 ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is < with respect the normL2 of self2, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self1 type ( Vector ), intent ( IN ) :: self2 logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self1 ) < normL2 ( self2 )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_low_self","tags":"","loc":"proc/self_low_self.html","title":"self_low_self – FLOw"},{"text":"private elemental function self_mul_ScalI1P(self, scal) result(mul) Multiply self for scalar (integer I1P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value type( Vector ) Source Code self_mul_ScalI1P Source Code elemental function self_mul_ScalI1P ( self , scal ) result ( mul ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply self for scalar (integer I1P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I1P ), intent ( IN ) :: scal type ( Vector ) :: mul !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- mul % x = real ( scal , R8P ) * self % x mul % y = real ( scal , R8P ) * self % y mul % z = real ( scal , R8P ) * self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_mul_ScalI1P","tags":"","loc":"proc/self_mul_scali1p.html","title":"self_mul_ScalI1P – FLOw"},{"text":"private elemental function self_mul_ScalI2P(self, scal) result(mul) Multiply self for scalar (integer I2P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value type( Vector ) Source Code self_mul_ScalI2P Source Code elemental function self_mul_ScalI2P ( self , scal ) result ( mul ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply self for scalar (integer I2P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I2P ), intent ( IN ) :: scal type ( Vector ) :: mul !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- mul % x = real ( scal , R8P ) * self % x mul % y = real ( scal , R8P ) * self % y mul % z = real ( scal , R8P ) * self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_mul_ScalI2P","tags":"","loc":"proc/self_mul_scali2p.html","title":"self_mul_ScalI2P – FLOw"},{"text":"private elemental function self_mul_ScalI4P(self, scal) result(mul) Multiply self for scalar (integer I4P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value type( Vector ) Source Code self_mul_ScalI4P Source Code elemental function self_mul_ScalI4P ( self , scal ) result ( mul ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply self for scalar (integer I4P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I4P ), intent ( IN ) :: scal type ( Vector ) :: mul !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- mul % x = real ( scal , R8P ) * self % x mul % y = real ( scal , R8P ) * self % y mul % z = real ( scal , R8P ) * self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_mul_ScalI4P","tags":"","loc":"proc/self_mul_scali4p.html","title":"self_mul_ScalI4P – FLOw"},{"text":"private elemental function self_mul_ScalI8P(self, scal) result(mul) Multiply self for scalar (integer I8P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value type( Vector ) Source Code self_mul_ScalI8P Source Code elemental function self_mul_ScalI8P ( self , scal ) result ( mul ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply self for scalar (integer I8P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I8P ), intent ( IN ) :: scal type ( Vector ) :: mul !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- mul % x = real ( scal , R8P ) * self % x mul % y = real ( scal , R8P ) * self % y mul % z = real ( scal , R8P ) * self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_mul_ScalI8P","tags":"","loc":"proc/self_mul_scali8p.html","title":"self_mul_ScalI8P – FLOw"},{"text":"private elemental function self_mul_ScalR16P(self, scal) result(mul) Multiply self for scalar (real R16P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R16P), intent(in) :: scal Return Value type( Vector ) Source Code self_mul_ScalR16P Source Code elemental function self_mul_ScalR16P ( self , scal ) result ( mul ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply self for scalar (real R16P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self real ( R16P ), intent ( IN ) :: scal type ( Vector ) :: mul !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- mul % x = real ( scal , R8P ) * self % x mul % y = real ( scal , R8P ) * self % y mul % z = real ( scal , R8P ) * self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_mul_ScalR16P","tags":"","loc":"proc/self_mul_scalr16p.html","title":"self_mul_ScalR16P – FLOw"},{"text":"private elemental function self_mul_ScalR4P(self, scal) result(mul) Multiply self for scalar (real R4P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value type( Vector ) Source Code self_mul_ScalR4P Source Code elemental function self_mul_ScalR4P ( self , scal ) result ( mul ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply self for scalar (real R4P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self real ( R4P ), intent ( IN ) :: scal type ( Vector ) :: mul !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- mul % x = real ( scal , R8P ) * self % x mul % y = real ( scal , R8P ) * self % y mul % z = real ( scal , R8P ) * self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_mul_ScalR4P","tags":"","loc":"proc/self_mul_scalr4p.html","title":"self_mul_ScalR4P – FLOw"},{"text":"private elemental function self_mul_ScalR8P(self, scal) result(mul) Multiply self for scalar (real R8P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value type( Vector ) Source Code self_mul_ScalR8P Source Code elemental function self_mul_ScalR8P ( self , scal ) result ( mul ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply self for scalar (real R8P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self real ( R8P ), intent ( IN ) :: scal type ( Vector ) :: mul !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- mul % x = real ( scal , R8P ) * self % x mul % y = real ( scal , R8P ) * self % y mul % z = real ( scal , R8P ) * self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_mul_ScalR8P","tags":"","loc":"proc/self_mul_scalr8p.html","title":"self_mul_ScalR8P – FLOw"},{"text":"private elemental function self_mul_self(self1, self2) result(mul) Multiply (by components) two selfs. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 type( Vector ), intent(in) :: self2 Return Value type( Vector ) Source Code self_mul_self Source Code elemental function self_mul_self ( self1 , self2 ) result ( mul ) !--------------------------------------------------------------------------------------------------------------------------------- !< Multiply (by components) two selfs. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self1 type ( Vector ), intent ( IN ) :: self2 type ( Vector ) :: mul !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- mul % x = self1 % x * self2 % x mul % y = self1 % y * self2 % y mul % z = self1 % z * self2 % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_mul_self","tags":"","loc":"proc/self_mul_self.html","title":"self_mul_self – FLOw"},{"text":"private elemental function self_not_eq_I1P(self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value logical Calls proc~~self_not_eq_i1p~~CallsGraph proc~self_not_eq_i1p self_not_eq_I1P proc~norml2 normL2 proc~self_not_eq_i1p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_not_eq_I1P Source Code elemental function self_not_eq_I1P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I1P ), intent ( IN ) :: scal logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) /= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_not_eq_I1P","tags":"","loc":"proc/self_not_eq_i1p.html","title":"self_not_eq_I1P – FLOw"},{"text":"private elemental function self_not_eq_I2P(self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value logical Calls proc~~self_not_eq_i2p~~CallsGraph proc~self_not_eq_i2p self_not_eq_I2P proc~norml2 normL2 proc~self_not_eq_i2p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_not_eq_I2P Source Code elemental function self_not_eq_I2P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I2P ), intent ( IN ) :: scal logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) /= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_not_eq_I2P","tags":"","loc":"proc/self_not_eq_i2p.html","title":"self_not_eq_I2P – FLOw"},{"text":"private elemental function self_not_eq_I4P(self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value logical Calls proc~~self_not_eq_i4p~~CallsGraph proc~self_not_eq_i4p self_not_eq_I4P proc~norml2 normL2 proc~self_not_eq_i4p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_not_eq_I4P Source Code elemental function self_not_eq_I4P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I4P ), intent ( IN ) :: scal logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) /= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_not_eq_I4P","tags":"","loc":"proc/self_not_eq_i4p.html","title":"self_not_eq_I4P – FLOw"},{"text":"private elemental function self_not_eq_I8P(self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value logical Calls proc~~self_not_eq_i8p~~CallsGraph proc~self_not_eq_i8p self_not_eq_I8P proc~norml2 normL2 proc~self_not_eq_i8p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_not_eq_I8P Source Code elemental function self_not_eq_I8P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I8P ), intent ( IN ) :: scal logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) /= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_not_eq_I8P","tags":"","loc":"proc/self_not_eq_i8p.html","title":"self_not_eq_I8P – FLOw"},{"text":"private elemental function self_not_eq_R16P(self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R16P), intent(in) :: scal Return Value logical Calls proc~~self_not_eq_r16p~~CallsGraph proc~self_not_eq_r16p self_not_eq_R16P proc~norml2 normL2 proc~self_not_eq_r16p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_not_eq_R16P Source Code elemental function self_not_eq_R16P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self real ( R16P ), intent ( IN ) :: scal logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) /= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_not_eq_R16P","tags":"","loc":"proc/self_not_eq_r16p.html","title":"self_not_eq_R16P – FLOw"},{"text":"private elemental function self_not_eq_R4P(self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value logical Calls proc~~self_not_eq_r4p~~CallsGraph proc~self_not_eq_r4p self_not_eq_R4P proc~norml2 normL2 proc~self_not_eq_r4p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_not_eq_R4P Source Code elemental function self_not_eq_R4P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self real ( R4P ), intent ( IN ) :: scal logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) /= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_not_eq_R4P","tags":"","loc":"proc/self_not_eq_r4p.html","title":"self_not_eq_R4P – FLOw"},{"text":"private elemental function self_not_eq_R8P(self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value logical Calls proc~~self_not_eq_r8p~~CallsGraph proc~self_not_eq_r8p self_not_eq_R8P proc~norml2 normL2 proc~self_not_eq_r8p->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_not_eq_R8P Source Code elemental function self_not_eq_R8P ( self , scal ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self real ( R8P ), intent ( IN ) :: scal logical :: compare !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( real ( scal , R8P ) /= normL2 ( self )) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_not_eq_R8P","tags":"","loc":"proc/self_not_eq_r8p.html","title":"self_not_eq_R8P – FLOw"},{"text":"private elemental function self_not_eq_self(self1, self2) result(compare) Return .true. if the normL2 of the self1 is /= with respect the normL2 of self2 or if the directions of self1\n and self2 are different, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 First selftor. type( Vector ), intent(in) :: self2 Second selftor. Return Value logical The result of the comparison. Calls proc~~self_not_eq_self~~CallsGraph proc~self_not_eq_self self_not_eq_self proc~norml2 normL2 proc~self_not_eq_self->proc~norml2 proc~normalize normalize proc~self_not_eq_self->proc~normalize proc~normalize->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code self_not_eq_self Source Code elemental function self_not_eq_self ( self1 , self2 ) result ( compare ) !--------------------------------------------------------------------------------------------------------------------------------- !< Return .true. if the normL2 of the self1 is /= with respect the normL2 of self2 or if the directions of self1 !< and self2 are different, .false. otherwise. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self1 !< First selftor. type ( Vector ), intent ( IN ) :: self2 !< Second selftor. logical :: compare !< The result of the comparison. type ( Vector ) :: n1 !< Normalizations of self1. type ( Vector ) :: n2 !< Normalizations of self2. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- compare = ( normL2 ( self1 ) /= normL2 ( self2 )) if (. not . compare ) then ! the normL2 are the same, checking the directions n1 = normalize ( self1 ) n2 = normalize ( self2 ) compare = (( n1 % x /= n2 % x ). OR .( n1 % y /= n2 % y ). OR .( n1 % z /= n2 % z )) endif return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_not_eq_self","tags":"","loc":"proc/self_not_eq_self.html","title":"self_not_eq_self – FLOw"},{"text":"private elemental function self_sub_ScalI1P(self, scal) result(sub) Subtract self and scalar (integer I1P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value type( Vector ) Source Code self_sub_ScalI1P Source Code elemental function self_sub_ScalI1P ( self , scal ) result ( sub ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract self and scalar (integer I1P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I1P ), intent ( IN ) :: scal type ( Vector ) :: sub !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- sub % x = self % x - real ( scal , R8P ) sub % y = self % y - real ( scal , R8P ) sub % z = self % z - real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_sub_ScalI1P","tags":"","loc":"proc/self_sub_scali1p.html","title":"self_sub_ScalI1P – FLOw"},{"text":"private elemental function self_sub_ScalI2P(self, scal) result(sub) Subtract self and scalar (integer I2P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value type( Vector ) Source Code self_sub_ScalI2P Source Code elemental function self_sub_ScalI2P ( self , scal ) result ( sub ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract self and scalar (integer I2P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I2P ), intent ( IN ) :: scal type ( Vector ) :: sub !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- sub % x = self % x - real ( scal , R8P ) sub % y = self % y - real ( scal , R8P ) sub % z = self % z - real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_sub_ScalI2P","tags":"","loc":"proc/self_sub_scali2p.html","title":"self_sub_ScalI2P – FLOw"},{"text":"private elemental function self_sub_ScalI4P(self, scal) result(sub) Subtract self and scalar (integer I4P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value type( Vector ) Source Code self_sub_ScalI4P Source Code elemental function self_sub_ScalI4P ( self , scal ) result ( sub ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract self and scalar (integer I4P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I4P ), intent ( IN ) :: scal type ( Vector ) :: sub !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- sub % x = self % x - real ( scal , R8P ) sub % y = self % y - real ( scal , R8P ) sub % z = self % z - real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_sub_ScalI4P","tags":"","loc":"proc/self_sub_scali4p.html","title":"self_sub_ScalI4P – FLOw"},{"text":"private elemental function self_sub_ScalI8P(self, scal) result(sub) Subtract self and scalar (integer I8P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value type( Vector ) Source Code self_sub_ScalI8P Source Code elemental function self_sub_ScalI8P ( self , scal ) result ( sub ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract self and scalar (integer I8P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I8P ), intent ( IN ) :: scal type ( Vector ) :: sub !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- sub % x = self % x - real ( scal , R8P ) sub % y = self % y - real ( scal , R8P ) sub % z = self % z - real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_sub_ScalI8P","tags":"","loc":"proc/self_sub_scali8p.html","title":"self_sub_ScalI8P – FLOw"},{"text":"private elemental function self_sub_ScalR16P(self, scal) result(sub) Subtract self and scalar (real R16P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R16P), intent(in) :: scal Return Value type( Vector ) Source Code self_sub_ScalR16P Source Code elemental function self_sub_ScalR16P ( self , scal ) result ( sub ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract self and scalar (real R16P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self real ( R16P ), intent ( IN ) :: scal type ( Vector ) :: sub !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- sub % x = self % x - real ( scal , R8P ) sub % y = self % y - real ( scal , R8P ) sub % z = self % z - real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_sub_ScalR16P","tags":"","loc":"proc/self_sub_scalr16p.html","title":"self_sub_ScalR16P – FLOw"},{"text":"private elemental function self_sub_ScalR4P(self, scal) result(sub) Subtract self and scalar (real R4P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value type( Vector ) Source Code self_sub_ScalR4P Source Code elemental function self_sub_ScalR4P ( self , scal ) result ( sub ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract self and scalar (real R4P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self real ( R4P ), intent ( IN ) :: scal type ( Vector ) :: sub !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- sub % x = self % x - real ( scal , R8P ) sub % y = self % y - real ( scal , R8P ) sub % z = self % z - real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_sub_ScalR4P","tags":"","loc":"proc/self_sub_scalr4p.html","title":"self_sub_ScalR4P – FLOw"},{"text":"private elemental function self_sub_ScalR8P(self, scal) result(sub) Subtract self and scalar (real R8P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value type( Vector ) Source Code self_sub_ScalR8P Source Code elemental function self_sub_ScalR8P ( self , scal ) result ( sub ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract self and scalar (real R8P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self real ( R8P ), intent ( IN ) :: scal type ( Vector ) :: sub !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- sub % x = self % x - real ( scal , R8P ) sub % y = self % y - real ( scal , R8P ) sub % z = self % z - real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_sub_ScalR8P","tags":"","loc":"proc/self_sub_scalr8p.html","title":"self_sub_ScalR8P – FLOw"},{"text":"private elemental function self_sub_self(self1, self2) result(sub) Subtract self and self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 type( Vector ), intent(in) :: self2 Return Value type( Vector ) Source Code self_sub_self Source Code elemental function self_sub_self ( self1 , self2 ) result ( sub ) !--------------------------------------------------------------------------------------------------------------------------------- !< Subtract self and self. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self1 type ( Vector ), intent ( IN ) :: self2 type ( Vector ) :: sub !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- sub % x = self1 % x - self2 % x sub % y = self1 % y - self2 % y sub % z = self1 % z - self2 % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_sub_self","tags":"","loc":"proc/self_sub_self.html","title":"self_sub_self – FLOw"},{"text":"private elemental function self_sum_ScalI1P(self, scal) result(summ) Sum self and scalar (integer I1P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value type( Vector ) Source Code self_sum_ScalI1P Source Code elemental function self_sum_ScalI1P ( self , scal ) result ( summ ) !--------------------------------------------------------------------------------------------------------------------------------- !< Sum self and scalar (integer I1P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I1P ), intent ( IN ) :: scal type ( Vector ) :: summ !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- summ % x = real ( scal , R8P ) + self % x summ % y = real ( scal , R8P ) + self % y summ % z = real ( scal , R8P ) + self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_sum_ScalI1P","tags":"","loc":"proc/self_sum_scali1p.html","title":"self_sum_ScalI1P – FLOw"},{"text":"private elemental function self_sum_ScalI2P(self, scal) result(summ) Sum self and scalar (integer I2P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value type( Vector ) Source Code self_sum_ScalI2P Source Code elemental function self_sum_ScalI2P ( self , scal ) result ( summ ) !--------------------------------------------------------------------------------------------------------------------------------- !< Sum self and scalar (integer I2P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I2P ), intent ( IN ) :: scal type ( Vector ) :: summ !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- summ % x = real ( scal , R8P ) + self % x summ % y = real ( scal , R8P ) + self % y summ % z = real ( scal , R8P ) + self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_sum_ScalI2P","tags":"","loc":"proc/self_sum_scali2p.html","title":"self_sum_ScalI2P – FLOw"},{"text":"private elemental function self_sum_ScalI4P(self, scal) result(summ) Sum self and scalar (integer I4P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value type( Vector ) Source Code self_sum_ScalI4P Source Code elemental function self_sum_ScalI4P ( self , scal ) result ( summ ) !--------------------------------------------------------------------------------------------------------------------------------- !< Sum self and scalar (integer I4P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I4P ), intent ( IN ) :: scal type ( Vector ) :: summ !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- summ % x = real ( scal , R8P ) + self % x summ % y = real ( scal , R8P ) + self % y summ % z = real ( scal , R8P ) + self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_sum_ScalI4P","tags":"","loc":"proc/self_sum_scali4p.html","title":"self_sum_ScalI4P – FLOw"},{"text":"private elemental function self_sum_ScalI8P(self, scal) result(summ) Sum self and scalar (integer I8P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value type( Vector ) Source Code self_sum_ScalI8P Source Code elemental function self_sum_ScalI8P ( self , scal ) result ( summ ) !--------------------------------------------------------------------------------------------------------------------------------- !< Sum self and scalar (integer I8P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self integer ( I8P ), intent ( IN ) :: scal type ( Vector ) :: summ !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- summ % x = real ( scal , R8P ) + self % x summ % y = real ( scal , R8P ) + self % y summ % z = real ( scal , R8P ) + self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_sum_ScalI8P","tags":"","loc":"proc/self_sum_scali8p.html","title":"self_sum_ScalI8P – FLOw"},{"text":"private elemental function self_sum_ScalR16P(self, scal) result(summ) Sum self and scalar (real R16P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R16P), intent(in) :: scal Return Value type( Vector ) Source Code self_sum_ScalR16P Source Code elemental function self_sum_ScalR16P ( self , scal ) result ( summ ) !--------------------------------------------------------------------------------------------------------------------------------- !< Sum self and scalar (real R16P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self real ( R16P ), intent ( IN ) :: scal type ( Vector ) :: summ !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- summ % x = real ( scal , R8P ) + self % x summ % y = real ( scal , R8P ) + self % y summ % z = real ( scal , R8P ) + self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_sum_ScalR16P","tags":"","loc":"proc/self_sum_scalr16p.html","title":"self_sum_ScalR16P – FLOw"},{"text":"private elemental function self_sum_ScalR4P(self, scal) result(summ) Sum self and scalar (real R4P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value type( Vector ) Source Code self_sum_ScalR4P Source Code elemental function self_sum_ScalR4P ( self , scal ) result ( summ ) !--------------------------------------------------------------------------------------------------------------------------------- !< Sum self and scalar (real R4P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self real ( R4P ), intent ( IN ) :: scal type ( Vector ) :: summ !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- summ % x = real ( scal , R8P ) + self % x summ % y = real ( scal , R8P ) + self % y summ % z = real ( scal , R8P ) + self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_sum_ScalR4P","tags":"","loc":"proc/self_sum_scalr4p.html","title":"self_sum_ScalR4P – FLOw"},{"text":"private elemental function self_sum_ScalR8P(self, scal) result(summ) Sum self and scalar (real R8P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value type( Vector ) Source Code self_sum_ScalR8P Source Code elemental function self_sum_ScalR8P ( self , scal ) result ( summ ) !--------------------------------------------------------------------------------------------------------------------------------- !< Sum self and scalar (real R8P). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self real ( R8P ), intent ( IN ) :: scal type ( Vector ) :: summ !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- summ % x = real ( scal , R8P ) + self % x summ % y = real ( scal , R8P ) + self % y summ % z = real ( scal , R8P ) + self % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_sum_ScalR8P","tags":"","loc":"proc/self_sum_scalr8p.html","title":"self_sum_ScalR8P – FLOw"},{"text":"private elemental function self_sum_self(self1, self2) result(summ) Sum self and self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 type( Vector ), intent(in) :: self2 Return Value type( Vector ) Source Code self_sum_self Source Code elemental function self_sum_self ( self1 , self2 ) result ( summ ) !--------------------------------------------------------------------------------------------------------------------------------- !< Sum self and self. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: self1 type ( Vector ), intent ( IN ) :: self2 type ( Vector ) :: summ !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- summ % x = self1 % x + self2 % x summ % y = self1 % y + self2 % y summ % z = self1 % z + self2 % z return !--------------------------------------------------------------------------------------------------------------------------------- endfunction self_sum_self","tags":"","loc":"proc/self_sum_self.html","title":"self_sum_self – FLOw"},{"text":"public elemental function sq_norm(vec) result(sq) Compute the square of the norm of a vector. The square norm if defined as  N = x&#94;2  + y&#94;2  + z&#94;2 . Arguments Type Intent Optional Attributes Name type( Vector ), intent(in) :: vec Vector. Return Value real(kind=R8P) Square of the Norm. Source Code sq_norm Source Code elemental function sq_norm ( vec ) result ( sq ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the square of the norm of a vector. !< !< The square norm if defined as  N = x&#94;2  + y&#94;2  + z&#94;2 . !--------------------------------------------------------------------------------------------------------------------------------- type ( Vector ), intent ( IN ) :: vec !< Vector. real ( R8P ) :: sq !< Square of the Norm. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- sq = ( vec % x * vec % x ) + ( vec % y * vec % y ) + ( vec % z * vec % z ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sq_norm","tags":"","loc":"proc/sq_norm.html","title":"sq_norm – FLOw"},{"text":"private elemental function sq_norm_self(vec) result(sq) Compute the square of the norm of a vector. The square norm if defined as  N = x&#94;2  + y&#94;2  + z&#94;2 . Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: vec Vector. Return Value real(kind=R8P) Square of the Norm. Source Code sq_norm_self Source Code elemental function sq_norm_self ( vec ) result ( sq ) !--------------------------------------------------------------------------------------------------------------------------------- !< Compute the square of the norm of a vector. !< !< The square norm if defined as  N = x&#94;2  + y&#94;2  + z&#94;2 . !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: vec !< Vector. real ( R8P ) :: sq !< Square of the Norm. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- sq = ( vec % x * vec % x ) + ( vec % y * vec % y ) + ( vec % z * vec % z ) return !--------------------------------------------------------------------------------------------------------------------------------- endfunction sq_norm_self","tags":"","loc":"proc/sq_norm_self.html","title":"sq_norm_self – FLOw"},{"text":"private elemental subroutine assign_ScalI1P(self, scal) Assignment between a scalar (integer I1P) and self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: self integer(kind=I1P), intent(in) :: scal Source Code assign_ScalI1P Source Code elemental subroutine assign_ScalI1P ( self , scal ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment between a scalar (integer I1P) and self. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( INOUT ) :: self integer ( I1P ), intent ( IN ) :: scal !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % x = real ( scal , R8P ) self % y = real ( scal , R8P ) self % z = real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_ScalI1P","tags":"","loc":"proc/assign_scali1p.html","title":"assign_ScalI1P – FLOw"},{"text":"private elemental subroutine assign_ScalI2P(self, scal) Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: self Assignment between a scalar (integer I2P) and self. integer(kind=I2P), intent(in) :: scal Source Code assign_ScalI2P Source Code elemental subroutine assign_ScalI2P ( self , scal ) !--------------------------------------------------------------------------------------------------------------------------------- !> Assignment between a scalar (integer I2P) and self. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( INOUT ) :: self integer ( I2P ), intent ( IN ) :: scal !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % x = real ( scal , R8P ) self % y = real ( scal , R8P ) self % z = real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_ScalI2P","tags":"","loc":"proc/assign_scali2p.html","title":"assign_ScalI2P – FLOw"},{"text":"private elemental subroutine assign_ScalI4P(self, scal) Assignment between a scalar (integer I4P) and self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: self integer(kind=I4P), intent(in) :: scal Source Code assign_ScalI4P Source Code elemental subroutine assign_ScalI4P ( self , scal ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment between a scalar (integer I4P) and self. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( INOUT ) :: self integer ( I4P ), intent ( IN ) :: scal !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % x = real ( scal , R8P ) self % y = real ( scal , R8P ) self % z = real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_ScalI4P","tags":"","loc":"proc/assign_scali4p.html","title":"assign_ScalI4P – FLOw"},{"text":"private elemental subroutine assign_ScalI8P(self, scal) Assignment between a scalar (integer I8P) and self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: self integer(kind=I8P), intent(in) :: scal Source Code assign_ScalI8P Source Code elemental subroutine assign_ScalI8P ( self , scal ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment between a scalar (integer I8P) and self. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( INOUT ) :: self integer ( I8P ), intent ( IN ) :: scal !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % x = real ( scal , R8P ) self % y = real ( scal , R8P ) self % z = real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_ScalI8P","tags":"","loc":"proc/assign_scali8p.html","title":"assign_ScalI8P – FLOw"},{"text":"private elemental subroutine assign_ScalR16P(self, scal) Assignment between a scalar (real R16P) and self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: self real(kind=R16P), intent(in) :: scal Source Code assign_ScalR16P Source Code elemental subroutine assign_ScalR16P ( self , scal ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment between a scalar (real R16P) and self. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( INOUT ) :: self real ( R16P ), intent ( IN ) :: scal !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % x = real ( scal , R8P ) self % y = real ( scal , R8P ) self % z = real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_ScalR16P","tags":"","loc":"proc/assign_scalr16p.html","title":"assign_ScalR16P – FLOw"},{"text":"private elemental subroutine assign_ScalR4P(self, scal) Assignment between a scalar (real R4P) and self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: self real(kind=R4P), intent(in) :: scal Source Code assign_ScalR4P Source Code elemental subroutine assign_ScalR4P ( self , scal ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment between a scalar (real R4P) and self. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( INOUT ) :: self real ( R4P ), intent ( IN ) :: scal !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % x = real ( scal , R8P ) self % y = real ( scal , R8P ) self % z = real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_ScalR4P","tags":"","loc":"proc/assign_scalr4p.html","title":"assign_ScalR4P – FLOw"},{"text":"private elemental subroutine assign_ScalR8P(self, scal) Assignment between a scalar (real R8P) and self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: self real(kind=R8P), intent(in) :: scal Source Code assign_ScalR8P Source Code elemental subroutine assign_ScalR8P ( self , scal ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment between a scalar (real R8P) and self. !--------------------------------------------------------------------------------------------------------------------------------- implicit none class ( Vector ), intent ( INOUT ) :: self real ( R8P ), intent ( IN ) :: scal !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self % x = real ( scal , R8P ) self % y = real ( scal , R8P ) self % z = real ( scal , R8P ) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_ScalR8P","tags":"","loc":"proc/assign_scalr8p.html","title":"assign_ScalR8P – FLOw"},{"text":"private pure subroutine assign_self(self1, self2) Assignment between two selfs. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: self1 class( Vector ), intent(in) :: self2 Source Code assign_self Source Code pure subroutine assign_self ( self1 , self2 ) !--------------------------------------------------------------------------------------------------------------------------------- !< Assignment between two selfs. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( INOUT ) :: self1 class ( Vector ), intent ( IN ) :: self2 !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- self1 % x = self2 % x self1 % y = self2 % y self1 % z = self2 % z return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine assign_self","tags":"","loc":"proc/assign_self.html","title":"assign_self – FLOw"},{"text":"private elemental subroutine face_normal3_self(fnormal, pt1, pt2, pt3, norm) Calculate the normal of the face defined by the 3 points vector pt1, pt2 and pt3. The convention for the points numeration is the following: 1.----.2\n   \\   |\n    \\  |\n     \\ |\n      \\|\n       .3 The normal is calculated by the cross product of the side s12 for the side s13: s12 x s13.\n The normal is normalized if the variable norm is passed (with any value). Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: fnormal Face normal. type( Vector ), intent(in) :: pt1 First face point. type( Vector ), intent(in) :: pt2 Second face point. type( Vector ), intent(in) :: pt3 Third face point. character(len=1), intent(in), optional :: norm If 'norm' is passed as argument the normal is normalized. Calls proc~~face_normal3_self~~CallsGraph proc~face_normal3_self face_normal3_self proc~normalize normalize proc~face_normal3_self->proc~normalize proc~norml2 normL2 proc~normalize->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code face_normal3_self Source Code elemental subroutine face_normal3_self ( fnormal , pt1 , pt2 , pt3 , norm ) !--------------------------------------------------------------------------------------------------------------------------------- !< Calculate the normal of the face defined by the 3 points vector pt1, pt2 and pt3. !< !< The convention for the points numeration is the following: !<``` !< 1.----.2 !<   \\   | !<    \\  | !<     \\ | !<      \\| !<       .3 !<``` !< The normal is calculated by the cross product of the side s12 for the side s13: s12 x s13. !< The normal is normalized if the variable *norm* is passed (with any value). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( INOUT ) :: fnormal !< Face normal. type ( Vector ), intent ( IN ) :: pt1 !< First face point. type ( Vector ), intent ( IN ) :: pt2 !< Second face point. type ( Vector ), intent ( IN ) :: pt3 !< Third face point. character ( 1 ), optional , intent ( IN ) :: norm !< If 'norm' is passed as argument the normal is normalized. type ( Vector ) :: s12 !< Face 1-2 diagonals. type ( Vector ) :: s13 !< Face 1-3 diagonals. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- s12 = pt2 - pt1 s13 = pt3 - pt1 if ( present ( norm )) then fnormal = normalize ( s12 . cross . s13 ) else fnormal = 0.5_R8P * ( s12 . cross . s13 ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine face_normal3_self","tags":"","loc":"proc/face_normal3_self.html","title":"face_normal3_self – FLOw"},{"text":"private elemental subroutine face_normal4_self(fnormal, pt1, pt2, pt3, pt4, norm) Calculate the normal of the face defined by 4 points vector pt1, pt2, pt3 and pt4. The convention for the points numeration is the following: 1.----------.2\n  |          |\n  |          |\n  |          |\n  |          |\n 4.----------.3 The normal is calculated by the cross product of the diagonal d13 for the diagonal d24: d13 x d24.\n The normal is normalized if the variable norm is passed (with any value). Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: fnormal Face normal. type( Vector ), intent(in) :: pt1 First face point. type( Vector ), intent(in) :: pt2 Second face point. type( Vector ), intent(in) :: pt3 Third face point. type( Vector ), intent(in) :: pt4 Fourth face point. character(len=1), intent(in), optional :: norm If 'norm' is passed as argument the normal is normalized. Calls proc~~face_normal4_self~~CallsGraph proc~face_normal4_self face_normal4_self proc~normalize normalize proc~face_normal4_self->proc~normalize proc~norml2 normL2 proc~normalize->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code face_normal4_self Source Code elemental subroutine face_normal4_self ( fnormal , pt1 , pt2 , pt3 , pt4 , norm ) !< Calculate the normal of the face defined by 4 points vector pt1, pt2, pt3 and pt4. !< !< The convention for the points numeration is the following: !<``` !< 1.----------.2 !<  |          | !<  |          | !<  |          | !<  |          | !< 4.----------.3 !<``` !< The normal is calculated by the cross product of the diagonal d13 for the diagonal d24: d13 x d24. !< The normal is normalized if the variable *norm* is passed (with any value). !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( INOUT ) :: fnormal !< Face normal. type ( Vector ), intent ( IN ) :: pt1 !< First face point. type ( Vector ), intent ( IN ) :: pt2 !< Second face point. type ( Vector ), intent ( IN ) :: pt3 !< Third face point. type ( Vector ), intent ( IN ) :: pt4 !< Fourth face point. character ( 1 ), optional , intent ( IN ) :: norm !< If 'norm' is passed as argument the normal is normalized. type ( Vector ) :: d13 !< Face 1-3 diagonals. type ( Vector ) :: d24 !< Face 2-4 diagonals. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- d13 = pt3 - pt1 d24 = pt4 - pt2 if ( present ( norm )) then fnormal = normalize ( d13 . cross . d24 ) else fnormal = 0.5_R8P * ( d13 . cross . d24 ) endif return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine face_normal4_self","tags":"","loc":"proc/face_normal4_self.html","title":"face_normal4_self – FLOw"},{"text":"private elemental subroutine init_vector_self(vec) Initialize components of Vector variable. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: vec Vector. Source Code init_vector_self Source Code elemental subroutine init_vector_self ( vec ) !--------------------------------------------------------------------------------------------------------------------------------- !< Initialize components of Vector variable. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( INOUT ) :: vec !< Vector. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- vec % x = 0._R8P vec % y = 0._R8P vec % z = 0._R8P return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine init_vector_self","tags":"","loc":"proc/init_vector_self.html","title":"init_vector_self – FLOw"},{"text":"private subroutine load_vector_self(vec, unit, pos, iostat, iomsg) Load Vector data. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: vec Vector data. integer(kind=I4P), intent(in) :: unit Logic unit. integer(kind=I8P), intent(in), optional :: pos Position specifier. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message. Source Code load_vector_self Source Code subroutine load_vector_self ( vec , unit , pos , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Load Vector data. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( INOUT ) :: vec !< Vector data. integer ( I4P ), intent ( IN ) :: unit !< Logic unit. integer ( I8P ), optional , intent ( IN ) :: pos !< Position specifier. integer ( I4P ), optional , intent ( OUT ) :: iostat !< IO error. character ( * ), optional , intent ( OUT ) :: iomsg !< IO error message. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< Temporary variable for IO error message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( pos )) then read ( unit = unit , pos = pos , iostat = iostatd , iomsg = iomsgd ) vec % x , vec % y , vec % z else read ( unit = unit , iostat = iostatd , iomsg = iomsgd ) vec % x , vec % y , vec % z endif if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = trim ( adjustl ( iomsgd )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine load_vector_self","tags":"","loc":"proc/load_vector_self.html","title":"load_vector_self – FLOw"},{"text":"private elemental subroutine normalize_self(vec) Normalize a vector. The normalization is made by means of norm L2. If the norm L2 of the vector is less than the parameter smallR8P the\n normalization value is set to normL2(vec)+smallR8P. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: vec Vector to be normalized. Calls proc~~normalize_self~~CallsGraph proc~normalize_self normalize_self proc~norml2 normL2 proc~normalize_self->proc~norml2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Source Code normalize_self Source Code elemental subroutine normalize_self ( vec ) !--------------------------------------------------------------------------------------------------------------------------------- !< Normalize a vector. !< !< The normalization is made by means of norm L2. If the norm L2 of the vector is less than the parameter smallR8P the !< normalization value is set to normL2(vec)+smallR8P. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( INOUT ) :: vec !< Vector to be normalized. real ( R8P ) :: nm !< Norm L2 of vector. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- nm = normL2 ( vec ) if ( nm < smallR8P ) then nm = nm + smallR8P endif vec % x = vec % x / nm vec % y = vec % y / nm vec % z = vec % z / nm return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine normalize_self","tags":"","loc":"proc/normalize_self.html","title":"normalize_self – FLOw"},{"text":"private subroutine print_vector_self(vec, unit, pref, iostat, iomsg) Print in a pretty ascii format the components of type Vector. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: vec Vector. integer(kind=I4P), intent(in), optional :: unit Logic unit. character(len=*), intent(in), optional :: pref Prefixing string for outputs. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message. Source Code print_vector_self Source Code subroutine print_vector_self ( vec , unit , pref , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Print in a pretty ascii format the components of type Vector. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: vec !< Vector. integer ( I4P ), optional , intent ( IN ) :: unit !< Logic unit. character ( * ), optional , intent ( IN ) :: pref !< Prefixing string for outputs. integer ( I4P ), optional , intent ( OUT ) :: iostat !< IO error. character ( * ), optional , intent ( OUT ) :: iomsg !< IO error message. character ( len = :), allocatable :: prefd !< Prefixing string. integer ( I4P ) :: unitd !< Logic unit. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< Temporary variable for IO error message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- unitd = stdout ; if ( present ( unit )) unitd = unit prefd = '' ; if ( present ( pref )) prefd = pref write ( unitd , '(A)' , iostat = iostatd , iomsg = iomsgd ) pref // ' Component x ' // str ( n = vec % x ) write ( unitd , '(A)' , iostat = iostatd , iomsg = iomsgd ) pref // ' Component y ' // str ( n = vec % y ) write ( unitd , '(A)' , iostat = iostatd , iomsg = iomsgd ) pref // ' Component z ' // str ( n = vec % z ) if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = trim ( adjustl ( iomsgd )) return !--------------------------------------------------------------------------------------------------------------------------------- contains elemental function str ( n ) result ( str_ ) !------------------------------------------------------------------------------------------------------------------------------- !< Procedure for converting real to string. This function achieves casting of real to string. !------------------------------------------------------------------------------------------------------------------------------- real ( R8P ), intent ( IN ) :: n !< Real to be converted. character ( DR8P ) :: str_ !< Returned string containing input number. !------------------------------------------------------------------------------------------------------------------------------- !------------------------------------------------------------------------------------------------------------------------------- write ( str_ , FR8P ) n ! Casting of n to string. if ( n > 0._R8P ) str_ ( 1 : 1 ) = '+' ! Prefixing plus if n>0. return !------------------------------------------------------------------------------------------------------------------------------- endfunction str endsubroutine print_vector_self","tags":"","loc":"proc/print_vector_self.html","title":"print_vector_self – FLOw"},{"text":"private subroutine save_vector_self(vec, unit, pos, iostat, iomsg) Save Vector data. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: vec Vector data. integer(kind=I4P), intent(in) :: unit Logic unit. integer(kind=I8P), intent(in), optional :: pos Position specifier. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message. Source Code save_vector_self Source Code subroutine save_vector_self ( vec , unit , pos , iostat , iomsg ) !--------------------------------------------------------------------------------------------------------------------------------- !< Save Vector data. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( IN ) :: vec !< Vector data. integer ( I4P ), intent ( IN ) :: unit !< Logic unit. integer ( I8P ), optional , intent ( IN ) :: pos !< Position specifier. integer ( I4P ), optional , intent ( OUT ) :: iostat !< IO error. character ( * ), optional , intent ( OUT ) :: iomsg !< IO error message. integer ( I4P ) :: iostatd !< IO error. character ( 500 ) :: iomsgd !< Temporary variable for IO error message. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( pos )) then write ( unit = unit , pos = pos , iostat = iostatd , iomsg = iomsgd ) vec % x , vec % y , vec % z else write ( unit = unit , iostat = iostatd , iomsg = iomsgd ) vec % x , vec % y , vec % z endif if ( present ( iostat )) iostat = iostatd if ( present ( iomsg )) iomsg = trim ( adjustl ( iomsgd )) return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine save_vector_self","tags":"","loc":"proc/save_vector_self.html","title":"save_vector_self – FLOw"},{"text":"private elemental subroutine set_vector_self(vec, x, y, z) Set components of Vector variable. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: vec Vector. real(kind=R8P), intent(in), optional :: x Cartesian component in x direction. real(kind=R8P), intent(in), optional :: y Cartesian component in y direction. real(kind=R8P), intent(in), optional :: z Cartesian component in z direction. Source Code set_vector_self Source Code elemental subroutine set_vector_self ( vec , x , y , z ) !--------------------------------------------------------------------------------------------------------------------------------- !< Set components of Vector variable. !--------------------------------------------------------------------------------------------------------------------------------- class ( Vector ), intent ( INOUT ) :: vec !< Vector. real ( R8P ), intent ( IN ), optional :: x !< Cartesian component in x direction. real ( R8P ), intent ( IN ), optional :: y !< Cartesian component in y direction. real ( R8P ), intent ( IN ), optional :: z !< Cartesian component in z direction. !--------------------------------------------------------------------------------------------------------------------------------- !--------------------------------------------------------------------------------------------------------------------------------- if ( present ( x )) vec % x = x if ( present ( y )) vec % y = y if ( present ( z )) vec % z = z return !--------------------------------------------------------------------------------------------------------------------------------- endsubroutine set_vector_self","tags":"","loc":"proc/set_vector_self.html","title":"set_vector_self – FLOw"},{"text":"Uses: flow_compressible_transformations flow_conservative_compressible flow_conservative_object flow_eos_compressible flow_eos_object flow_field_object flow_field_scalar_vectorial flow_primitive_compressible flow_primitive_compressible_multispecie flow_primitive_object module~~flow~~UsesGraph module~flow flow module~flow_primitive_compressible_multispecie flow_primitive_compressible_multispecie module~flow_primitive_compressible_multispecie->module~flow module~flow_eos_object flow_eos_object module~flow_eos_object->module~flow module~flow_eos_object->module~flow_primitive_compressible_multispecie module~flow_conservative_object flow_conservative_object module~flow_eos_object->module~flow_conservative_object module~flow_compressible_transformations flow_compressible_transformations module~flow_eos_object->module~flow_compressible_transformations module~flow_eos_compressible flow_eos_compressible module~flow_eos_object->module~flow_eos_compressible module~flow_conservative_compressible flow_conservative_compressible module~flow_eos_object->module~flow_conservative_compressible module~flow_primitive_compressible flow_primitive_compressible module~flow_eos_object->module~flow_primitive_compressible module~flow_primitive_object flow_primitive_object module~flow_eos_object->module~flow_primitive_object module~flow_field_scalar_vectorial flow_field_scalar_vectorial module~flow_field_scalar_vectorial->module~flow module~flow_field_object flow_field_object module~flow_field_object->module~flow module~flow_field_object->module~flow_primitive_compressible_multispecie module~flow_field_object->module~flow_field_scalar_vectorial module~flow_field_object->module~flow_conservative_object module~flow_field_object->module~flow_conservative_compressible module~flow_field_object->module~flow_primitive_compressible module~flow_field_object->module~flow_primitive_object module~flow_conservative_object->module~flow module~flow_conservative_object->module~flow_conservative_compressible module~flow_compressible_transformations->module~flow module~flow_eos_compressible->module~flow module~flow_conservative_compressible->module~flow module~flow_conservative_compressible->module~flow_compressible_transformations module~flow_primitive_compressible->module~flow module~flow_primitive_compressible->module~flow_compressible_transformations module~flow_primitive_object->module~flow module~flow_primitive_object->module~flow_primitive_compressible_multispecie module~flow_primitive_object->module~flow_primitive_compressible module~penf penf module~penf->module~flow_primitive_compressible_multispecie module~penf->module~flow_eos_object module~penf->module~flow_field_scalar_vectorial module~penf->module~flow_field_object module~penf->module~flow_conservative_object module~penf->module~flow_compressible_transformations module~penf->module~flow_eos_compressible module~penf->module~flow_conservative_compressible module~penf->module~flow_primitive_compressible module~penf->module~flow_primitive_object module~vecfor VecFor module~vecfor->module~flow_primitive_compressible_multispecie module~vecfor->module~flow_field_scalar_vectorial module~vecfor->module~flow_conservative_object module~vecfor->module~flow_compressible_transformations module~vecfor->module~flow_conservative_compressible module~vecfor->module~flow_primitive_compressible module~vecfor->module~flow_primitive_object module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_stringify penf_stringify module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~flow_conservative_compressible iso_fortran_env->module~flow_primitive_compressible iso_fortran_env->module~vecfor iso_fortran_env->module~penf_stringify var panmoduleflowUsesGraph = svgPanZoom('#moduleflowUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FLOw, Fortran fLuid Object Used By module~~flow~~UsedByGraph module~flow flow program~flow_test_conservative_compressible_sub flow_test_conservative_compressible_sub module~flow->program~flow_test_conservative_compressible_sub program~flow_test_eos_compressible flow_test_eos_compressible module~flow->program~flow_test_eos_compressible program~flow_test_primitive_compressible_add flow_test_primitive_compressible_add module~flow->program~flow_test_primitive_compressible_add program~flow_test_primitive_compressible_assign flow_test_primitive_compressible_assign module~flow->program~flow_test_primitive_compressible_assign program~flow_test_primitive_compressible_div flow_test_primitive_compressible_div module~flow->program~flow_test_primitive_compressible_div program~flow_test_primitive_compressible_eq flow_test_primitive_compressible_eq module~flow->program~flow_test_primitive_compressible_eq program~flow_test_primitive_compressible_mul flow_test_primitive_compressible_mul module~flow->program~flow_test_primitive_compressible_mul program~flow_test_primitive_compressible_multispecie_add flow_test_primitive_compressible_multispecie_add module~flow->program~flow_test_primitive_compressible_multispecie_add program~flow_test_primitive_compressible_multispecie_assign flow_test_primitive_compressible_multispecie_assign module~flow->program~flow_test_primitive_compressible_multispecie_assign program~flow_test_primitive_compressible_multispecie_div flow_test_primitive_compressible_multispecie_div module~flow->program~flow_test_primitive_compressible_multispecie_div program~flow_test_primitive_compressible_multispecie_eq flow_test_primitive_compressible_multispecie_eq module~flow->program~flow_test_primitive_compressible_multispecie_eq program~flow_test_primitive_compressible_multispecie_mul flow_test_primitive_compressible_multispecie_mul module~flow->program~flow_test_primitive_compressible_multispecie_mul program~flow_test_primitive_compressible_multispecie_not_eq flow_test_primitive_compressible_multispecie_not_eq module~flow->program~flow_test_primitive_compressible_multispecie_not_eq program~flow_test_primitive_compressible_multispecie_add~2 flow_test_primitive_compressible_multispecie_add module~flow->program~flow_test_primitive_compressible_multispecie_add~2 program~flow_test_primitive_compressible_multispecie_sub flow_test_primitive_compressible_multispecie_sub module~flow->program~flow_test_primitive_compressible_multispecie_sub program~flow_test_primitive_compressible_not_eq flow_test_primitive_compressible_not_eq module~flow->program~flow_test_primitive_compressible_not_eq program~flow_test_primitive_compressible_add~2 flow_test_primitive_compressible_add module~flow->program~flow_test_primitive_compressible_add~2 program~flow_test_primitive_compressible_sub flow_test_primitive_compressible_sub module~flow->program~flow_test_primitive_compressible_sub program~flow_test_compressible_transformations flow_test_compressible_transformations module~flow->program~flow_test_compressible_transformations program~flow_test_conservative_compressible_add flow_test_conservative_compressible_add module~flow->program~flow_test_conservative_compressible_add program~flow_test_conservative_compressible_assign flow_test_conservative_compressible_assign module~flow->program~flow_test_conservative_compressible_assign program~flow_test_conservative_compressible_div flow_test_conservative_compressible_div module~flow->program~flow_test_conservative_compressible_div program~flow_test_conservative_compressible_eq flow_test_conservative_compressible_eq module~flow->program~flow_test_conservative_compressible_eq program~flow_test_conservative_compressible_mul flow_test_conservative_compressible_mul module~flow->program~flow_test_conservative_compressible_mul program~flow_test_conservative_compressible_not_eq flow_test_conservative_compressible_not_eq module~flow->program~flow_test_conservative_compressible_not_eq program~flow_test_conservative_compressible_add~2 flow_test_conservative_compressible_add module~flow->program~flow_test_conservative_compressible_add~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it.","tags":"","loc":"module/flow.html","title":"flow – FLOw"},{"text":"Uses: flow_conservative_compressible flow_eos_object flow_primitive_compressible penf VecFor module~~flow_compressible_transformations~~UsesGraph module~flow_compressible_transformations flow_compressible_transformations module~penf penf module~penf->module~flow_compressible_transformations module~flow_conservative_compressible flow_conservative_compressible module~penf->module~flow_conservative_compressible module~flow_eos_object flow_eos_object module~penf->module~flow_eos_object module~flow_primitive_compressible flow_primitive_compressible module~penf->module~flow_primitive_compressible module~flow_conservative_object flow_conservative_object module~penf->module~flow_conservative_object module~flow_field_object flow_field_object module~penf->module~flow_field_object module~flow_primitive_object flow_primitive_object module~penf->module~flow_primitive_object module~flow_conservative_compressible->module~flow_compressible_transformations module~flow_eos_object->module~flow_compressible_transformations module~flow_eos_object->module~flow_conservative_compressible module~flow_eos_object->module~flow_primitive_compressible module~flow_eos_object->module~flow_conservative_object module~flow_eos_object->module~flow_primitive_object module~vecfor VecFor module~vecfor->module~flow_compressible_transformations module~vecfor->module~flow_conservative_compressible module~vecfor->module~flow_primitive_compressible module~vecfor->module~flow_conservative_object module~vecfor->module~flow_primitive_object module~flow_primitive_compressible->module~flow_compressible_transformations module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_stringify penf_stringify module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~flow_conservative_compressible iso_fortran_env->module~vecfor iso_fortran_env->module~flow_primitive_compressible iso_fortran_env->module~penf_stringify module~flow_conservative_object->module~flow_conservative_compressible module~flow_field_object->module~flow_conservative_compressible module~flow_field_object->module~flow_primitive_compressible module~flow_field_object->module~flow_conservative_object module~flow_field_object->module~flow_primitive_object module~flow_primitive_object->module~flow_primitive_compressible var panmoduleflow_compressible_transformationsUsesGraph = svgPanZoom('#moduleflow_compressible_transformationsUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FLOw compressible variables transformations. Used By module~~flow_compressible_transformations~~UsedByGraph module~flow_compressible_transformations flow_compressible_transformations module~flow flow module~flow_compressible_transformations->module~flow program~flow_test_conservative_compressible_sub flow_test_conservative_compressible_sub module~flow->program~flow_test_conservative_compressible_sub program~flow_test_eos_compressible flow_test_eos_compressible module~flow->program~flow_test_eos_compressible program~flow_test_primitive_compressible_add flow_test_primitive_compressible_add module~flow->program~flow_test_primitive_compressible_add program~flow_test_primitive_compressible_assign flow_test_primitive_compressible_assign module~flow->program~flow_test_primitive_compressible_assign program~flow_test_primitive_compressible_div flow_test_primitive_compressible_div module~flow->program~flow_test_primitive_compressible_div program~flow_test_primitive_compressible_eq flow_test_primitive_compressible_eq module~flow->program~flow_test_primitive_compressible_eq program~flow_test_primitive_compressible_mul flow_test_primitive_compressible_mul module~flow->program~flow_test_primitive_compressible_mul program~flow_test_primitive_compressible_multispecie_add flow_test_primitive_compressible_multispecie_add module~flow->program~flow_test_primitive_compressible_multispecie_add program~flow_test_primitive_compressible_multispecie_assign flow_test_primitive_compressible_multispecie_assign module~flow->program~flow_test_primitive_compressible_multispecie_assign program~flow_test_primitive_compressible_multispecie_div flow_test_primitive_compressible_multispecie_div module~flow->program~flow_test_primitive_compressible_multispecie_div program~flow_test_primitive_compressible_multispecie_eq flow_test_primitive_compressible_multispecie_eq module~flow->program~flow_test_primitive_compressible_multispecie_eq program~flow_test_primitive_compressible_multispecie_mul flow_test_primitive_compressible_multispecie_mul module~flow->program~flow_test_primitive_compressible_multispecie_mul program~flow_test_primitive_compressible_multispecie_not_eq flow_test_primitive_compressible_multispecie_not_eq module~flow->program~flow_test_primitive_compressible_multispecie_not_eq program~flow_test_primitive_compressible_multispecie_add~2 flow_test_primitive_compressible_multispecie_add module~flow->program~flow_test_primitive_compressible_multispecie_add~2 program~flow_test_primitive_compressible_multispecie_sub flow_test_primitive_compressible_multispecie_sub module~flow->program~flow_test_primitive_compressible_multispecie_sub program~flow_test_primitive_compressible_not_eq flow_test_primitive_compressible_not_eq module~flow->program~flow_test_primitive_compressible_not_eq program~flow_test_primitive_compressible_add~2 flow_test_primitive_compressible_add module~flow->program~flow_test_primitive_compressible_add~2 program~flow_test_primitive_compressible_sub flow_test_primitive_compressible_sub module~flow->program~flow_test_primitive_compressible_sub program~flow_test_compressible_transformations flow_test_compressible_transformations module~flow->program~flow_test_compressible_transformations program~flow_test_conservative_compressible_add flow_test_conservative_compressible_add module~flow->program~flow_test_conservative_compressible_add program~flow_test_conservative_compressible_assign flow_test_conservative_compressible_assign module~flow->program~flow_test_conservative_compressible_assign program~flow_test_conservative_compressible_div flow_test_conservative_compressible_div module~flow->program~flow_test_conservative_compressible_div program~flow_test_conservative_compressible_eq flow_test_conservative_compressible_eq module~flow->program~flow_test_conservative_compressible_eq program~flow_test_conservative_compressible_mul flow_test_conservative_compressible_mul module~flow->program~flow_test_conservative_compressible_mul program~flow_test_conservative_compressible_not_eq flow_test_conservative_compressible_not_eq module~flow->program~flow_test_conservative_compressible_not_eq program~flow_test_conservative_compressible_add~2 flow_test_conservative_compressible_add module~flow->program~flow_test_conservative_compressible_add~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Functions conservative_to_primitive_compressible primitive_to_conservative_compressible Functions public elemental function conservative_to_primitive_compressible (conservative, eos) result(primitive_) Return a primitive_compressible state transforming a given conservative_compressible state. Arguments Type Intent Optional Attributes Name type( conservative_compressible ), intent(in) :: conservative Conservative state. class( eos_object ), intent(in) :: eos Equation of state. Return Value type( primitive_compressible ) Primitive state. public elemental function primitive_to_conservative_compressible (primitive, eos) result(conservative_) Return a conservative_compressible state transforming a given primitive_compressible state. Arguments Type Intent Optional Attributes Name type( primitive_compressible ), intent(in) :: primitive Primitive state. class( eos_object ), intent(in) :: eos Equation of state. Return Value type( conservative_compressible ) Conservative state.","tags":"","loc":"module/flow_compressible_transformations.html","title":"flow_compressible_transformations – FLOw"},{"text":"Uses: iso_fortran_env flow_eos_object flow_field_object flow_conservative_object penf VecFor module~~flow_conservative_compressible~~UsesGraph module~flow_conservative_compressible flow_conservative_compressible iso_fortran_env iso_fortran_env iso_fortran_env->module~flow_conservative_compressible module~vecfor VecFor iso_fortran_env->module~vecfor module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~flow_eos_object flow_eos_object module~flow_eos_object->module~flow_conservative_compressible module~flow_conservative_object flow_conservative_object module~flow_eos_object->module~flow_conservative_object module~flow_conservative_object->module~flow_conservative_compressible module~flow_field_object flow_field_object module~flow_field_object->module~flow_conservative_compressible module~flow_field_object->module~flow_conservative_object module~penf penf module~penf->module~flow_conservative_compressible module~penf->module~flow_eos_object module~penf->module~flow_conservative_object module~penf->module~flow_field_object module~vecfor->module~flow_conservative_compressible module~vecfor->module~flow_conservative_object module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf var panmoduleflow_conservative_compressibleUsesGraph = svgPanZoom('#moduleflow_conservative_compressibleUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FLOw conservative compressible object. conservative_compressible is a class that handles compressible conservative fluid dynamic variables. Used By module~~flow_conservative_compressible~~UsedByGraph module~flow_conservative_compressible flow_conservative_compressible module~flow_compressible_transformations flow_compressible_transformations module~flow_conservative_compressible->module~flow_compressible_transformations module~flow flow module~flow_conservative_compressible->module~flow module~flow_compressible_transformations->module~flow program~flow_test_conservative_compressible_sub flow_test_conservative_compressible_sub module~flow->program~flow_test_conservative_compressible_sub program~flow_test_eos_compressible flow_test_eos_compressible module~flow->program~flow_test_eos_compressible program~flow_test_primitive_compressible_add flow_test_primitive_compressible_add module~flow->program~flow_test_primitive_compressible_add program~flow_test_primitive_compressible_assign flow_test_primitive_compressible_assign module~flow->program~flow_test_primitive_compressible_assign program~flow_test_primitive_compressible_div flow_test_primitive_compressible_div module~flow->program~flow_test_primitive_compressible_div program~flow_test_primitive_compressible_eq flow_test_primitive_compressible_eq module~flow->program~flow_test_primitive_compressible_eq program~flow_test_primitive_compressible_mul flow_test_primitive_compressible_mul module~flow->program~flow_test_primitive_compressible_mul program~flow_test_primitive_compressible_multispecie_add flow_test_primitive_compressible_multispecie_add module~flow->program~flow_test_primitive_compressible_multispecie_add program~flow_test_primitive_compressible_multispecie_assign flow_test_primitive_compressible_multispecie_assign module~flow->program~flow_test_primitive_compressible_multispecie_assign program~flow_test_primitive_compressible_multispecie_div flow_test_primitive_compressible_multispecie_div module~flow->program~flow_test_primitive_compressible_multispecie_div program~flow_test_primitive_compressible_multispecie_eq flow_test_primitive_compressible_multispecie_eq module~flow->program~flow_test_primitive_compressible_multispecie_eq program~flow_test_primitive_compressible_multispecie_mul flow_test_primitive_compressible_multispecie_mul module~flow->program~flow_test_primitive_compressible_multispecie_mul program~flow_test_primitive_compressible_multispecie_not_eq flow_test_primitive_compressible_multispecie_not_eq module~flow->program~flow_test_primitive_compressible_multispecie_not_eq program~flow_test_primitive_compressible_multispecie_add~2 flow_test_primitive_compressible_multispecie_add module~flow->program~flow_test_primitive_compressible_multispecie_add~2 program~flow_test_primitive_compressible_multispecie_sub flow_test_primitive_compressible_multispecie_sub module~flow->program~flow_test_primitive_compressible_multispecie_sub program~flow_test_primitive_compressible_not_eq flow_test_primitive_compressible_not_eq module~flow->program~flow_test_primitive_compressible_not_eq program~flow_test_primitive_compressible_add~2 flow_test_primitive_compressible_add module~flow->program~flow_test_primitive_compressible_add~2 program~flow_test_primitive_compressible_sub flow_test_primitive_compressible_sub module~flow->program~flow_test_primitive_compressible_sub program~flow_test_compressible_transformations flow_test_compressible_transformations module~flow->program~flow_test_compressible_transformations program~flow_test_conservative_compressible_add flow_test_conservative_compressible_add module~flow->program~flow_test_conservative_compressible_add program~flow_test_conservative_compressible_assign flow_test_conservative_compressible_assign module~flow->program~flow_test_conservative_compressible_assign program~flow_test_conservative_compressible_div flow_test_conservative_compressible_div module~flow->program~flow_test_conservative_compressible_div program~flow_test_conservative_compressible_eq flow_test_conservative_compressible_eq module~flow->program~flow_test_conservative_compressible_eq program~flow_test_conservative_compressible_mul flow_test_conservative_compressible_mul module~flow->program~flow_test_conservative_compressible_mul program~flow_test_conservative_compressible_not_eq flow_test_conservative_compressible_not_eq module~flow->program~flow_test_conservative_compressible_not_eq program~flow_test_conservative_compressible_add~2 flow_test_conservative_compressible_add module~flow->program~flow_test_conservative_compressible_add~2 var panmoduleflow_conservative_compressibleUsedByGraph = svgPanZoom('#moduleflow_conservative_compressibleUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Interfaces conservative_compressible Derived Types conservative_compressible Functions add array conservative_compressible_instance conservative_compressible_pointer description div div_integer div_real eq integer_mul mul mul_integer mul_real negative not_eq positive pow_integer pow_real pressure real_mul sub velocity Subroutines assign_field assign_real compute_fluxes compute_fluxes_from_primitive destroy initialize Interfaces public interface conservative_compressible Overload conservative_compressible name with its constructor. private pure function conservative_compressible_instance (density, velocity, pressure) result(instance) Return and instance of conservative_compressible . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in), optional :: density Density field. type(vector), intent(in), optional :: velocity Velocity field. real(kind=R8P), intent(in), optional :: pressure Pressure field. Return Value type( conservative_compressible ) Instance of conservative_compressible . Derived Types type, public, extends( conservative_object ) :: conservative_compressible Conservative compressible multispecie object. Components Type Visibility Attributes Name Initial real(kind=R8P), public :: density = 0._R8P Density, rho . real(kind=R8P), public :: energy = 0._R8P Energy, rho * E , rho being the density and E the specific energy. type(vector), public :: momentum Momentum, rho * v , rho being the density and v the velocity vector. Constructor Overload conservative_compressible name with its constructor. private pure function conservative_compressible_instance (density, velocity, pressure) Return and instance of conservative_compressible . Type-Bound Procedures procedure, public, pass(lhs) :: add Operator + . procedure, public, pass(self) :: array Return serialized array of field. procedure, public, pass(lhs) :: assign_field Operator = . procedure, public, pass(lhs) :: assign_real Operator field = real . generic, public :: assignment(=) => assign_field, assign_real Assignment overloading. procedure, public, pass(self) :: compute_fluxes Compute conservative fluxes. procedure, public, pass(self) :: compute_fluxes_from_primitive Compute conservative fluxes from primitives at interface. procedure, public, pass(self) :: description Return pretty-printed object description. procedure, public, pass(self) :: destroy Destroy conservative. procedure, public, pass(lhs) :: div Operator / . procedure, public, pass(lhs) :: div_integer Operator field / integer . procedure, public, pass(lhs) :: div_real Operator field / real . procedure, public, pass(lhs) :: eq Operator `=='. procedure, public, pass(self) :: initialize Initialize conservative. procedure, public, pass(rhs) :: integer_mul Operator integer * field . procedure, public, pass(lhs) :: mul Operator * . procedure, public, pass(lhs) :: mul_integer Operator field * integer . procedure, public, pass(lhs) :: mul_real Operator field * real . procedure, public, pass(self) :: negative Unary operator - field . procedure, public, pass(lhs) :: not_eq Operator `/='. generic, public :: operator(*) => mul, mul_integer, integer_mul, real_mul, mul_real Operator * overloading. generic, public :: operator(**) => pow_integer, pow_real Operator ** overloading. generic, public :: operator(+) => add, positive Operator + overloading. generic, public :: operator(-) => sub, negative Operator - overloading. generic, public :: operator(/) => div, div_integer, div_real Operator / overloading. generic, public :: operator(/=) => not_eq Operator /= overloading. generic, public :: operator(==) => eq Operator /= overloading. procedure, public, pass(self) :: positive Unary operator + field . procedure, public, pass(lhs) :: pow_integer Operator field ** integer . procedure, public, pass(lhs) :: pow_real Operator field ** real . procedure, public, pass(self) :: pressure Return pressure value. procedure, public, pass(rhs) :: real_mul Operator real * field . procedure, public, pass(lhs) :: sub Operator - . procedure, public, pass(self) :: velocity Return velocity vector. Functions private elemental function add (lhs, rhs) result(opr) Operator + . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private pure function array (self) result(array_) Return serialized array of field. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: self Conservative. Return Value real(kind=R8P),\n  allocatable, (:) Serialized array of field. private pure function conservative_compressible_instance (density, velocity, pressure) result(instance) Return and instance of conservative_compressible . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in), optional :: density Density field. type(vector), intent(in), optional :: velocity Velocity field. real(kind=R8P), intent(in), optional :: pressure Pressure field. Return Value type( conservative_compressible ) Instance of conservative_compressible . public function conservative_compressible_pointer (to, error_message) result(pointer_) Return conservative_compressible pointer associated to conservative_object or its extensions until conservative_compressible included. Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(in), target :: to Target of associate. character(len=*), intent(in), optional :: error_message Auxiliary error message. Return Value class( conservative_compressible ),\n  pointer Associated pointer. private pure function description (self, prefix) result(desc) Return a pretty-formatted object description. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: self Conservative. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. private elemental function div (lhs, rhs) result(opr) Operator / . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function div_integer (lhs, rhs) result(opr) Operator field / integer . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function div_real (lhs, rhs) result(opr) Operator field / real . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function eq (lhs, rhs) result(opr) Operator `=='. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. private elemental function integer_mul (lhs, rhs) result(opr) Operator integer * field . Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: lhs Left hand side. class( conservative_compressible ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function mul (lhs, rhs) result(opr) Operator * . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function mul_integer (lhs, rhs) result(opr) Operator field * integer . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function mul_real (lhs, rhs) result(opr) Operator field * real . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private function negative (self) result(opr) Unary operator - field . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: self conservative. Return Value class( field_object ),\n  allocatable Operator result. private elemental function not_eq (lhs, rhs) result(opr) Operator `/='. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. private function positive (self) result(opr) Unary operator + field . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: self conservative. Return Value class( field_object ),\n  allocatable Operator result. private elemental function pow_integer (lhs, rhs) result(opr) Operator field ** integer . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function pow_real (lhs, rhs) result(opr) Operator field ** real . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function pressure (self, eos) result(pressure_) Return pressure value. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: self Conservative. class( eos_object ), intent(in) :: eos Equation of state. Return Value real(kind=R8P) Pressure value. private elemental function real_mul (lhs, rhs) result(opr) Operator real * field . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs Left hand side. class( conservative_compressible ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function sub (lhs, rhs) result(opr) Operator - . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function velocity (self) result(velocity_) Return velocity vector. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: self Conservative. Return Value type(vector) Velocity vector. Subroutines private elemental subroutine assign_field (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(inout) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. private elemental subroutine assign_real (lhs, rhs) Operator field = real . Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(inout) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. private subroutine compute_fluxes (self, eos, normal, fluxes) Compute conservative fluxes. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(in) :: self Conservative. class( eos_object ), intent(in) :: eos Equation of state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(out) :: fluxes Conservative fluxes. private elemental subroutine compute_fluxes_from_primitive (self, eos, p, r, u, normal) Compute conservative fluxes from primitives at interface. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(inout) :: self Conservative. class( eos_object ), intent(in) :: eos Equation of state. real(kind=R8P), intent(in) :: p Pressure at interface. real(kind=R8P), intent(in) :: r Density at interface. real(kind=R8P), intent(in) :: u Velocity (normal component) at interface. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. private elemental subroutine destroy (self) Destroy conservative. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(inout) :: self Conservative. private subroutine initialize (self, initial_state) Initialize conservative. Arguments Type Intent Optional Attributes Name class( conservative_compressible ), intent(inout) :: self conservative. class( conservative_object ), intent(in), optional :: initial_state Initial state.","tags":"","loc":"module/flow_conservative_compressible.html","title":"flow_conservative_compressible – FLOw"},{"text":"Uses: flow_eos_object flow_field_object penf VecFor module~~flow_conservative_object~~UsesGraph module~flow_conservative_object flow_conservative_object module~penf penf module~penf->module~flow_conservative_object module~flow_eos_object flow_eos_object module~penf->module~flow_eos_object module~flow_field_object flow_field_object module~penf->module~flow_field_object module~flow_eos_object->module~flow_conservative_object module~vecfor VecFor module~vecfor->module~flow_conservative_object module~flow_field_object->module~flow_conservative_object module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_stringify penf_stringify module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~vecfor iso_fortran_env->module~penf_stringify var panmoduleflow_conservative_objectUsesGraph = svgPanZoom('#moduleflow_conservative_objectUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FLOw conservative abstract object. conservative_object is a class that handles conservative fluid dynamic variables. Used By module~~flow_conservative_object~~UsedByGraph module~flow_conservative_object flow_conservative_object module~flow_conservative_compressible flow_conservative_compressible module~flow_conservative_object->module~flow_conservative_compressible module~flow flow module~flow_conservative_object->module~flow module~flow_conservative_compressible->module~flow module~flow_compressible_transformations flow_compressible_transformations module~flow_conservative_compressible->module~flow_compressible_transformations program~flow_test_conservative_compressible_sub flow_test_conservative_compressible_sub module~flow->program~flow_test_conservative_compressible_sub program~flow_test_eos_compressible flow_test_eos_compressible module~flow->program~flow_test_eos_compressible program~flow_test_primitive_compressible_add flow_test_primitive_compressible_add module~flow->program~flow_test_primitive_compressible_add program~flow_test_primitive_compressible_assign flow_test_primitive_compressible_assign module~flow->program~flow_test_primitive_compressible_assign program~flow_test_primitive_compressible_div flow_test_primitive_compressible_div module~flow->program~flow_test_primitive_compressible_div program~flow_test_primitive_compressible_eq flow_test_primitive_compressible_eq module~flow->program~flow_test_primitive_compressible_eq program~flow_test_primitive_compressible_mul flow_test_primitive_compressible_mul module~flow->program~flow_test_primitive_compressible_mul program~flow_test_primitive_compressible_multispecie_add flow_test_primitive_compressible_multispecie_add module~flow->program~flow_test_primitive_compressible_multispecie_add program~flow_test_primitive_compressible_multispecie_assign flow_test_primitive_compressible_multispecie_assign module~flow->program~flow_test_primitive_compressible_multispecie_assign program~flow_test_primitive_compressible_multispecie_div flow_test_primitive_compressible_multispecie_div module~flow->program~flow_test_primitive_compressible_multispecie_div program~flow_test_primitive_compressible_multispecie_eq flow_test_primitive_compressible_multispecie_eq module~flow->program~flow_test_primitive_compressible_multispecie_eq program~flow_test_primitive_compressible_multispecie_mul flow_test_primitive_compressible_multispecie_mul module~flow->program~flow_test_primitive_compressible_multispecie_mul program~flow_test_primitive_compressible_multispecie_not_eq flow_test_primitive_compressible_multispecie_not_eq module~flow->program~flow_test_primitive_compressible_multispecie_not_eq program~flow_test_primitive_compressible_multispecie_add~2 flow_test_primitive_compressible_multispecie_add module~flow->program~flow_test_primitive_compressible_multispecie_add~2 program~flow_test_primitive_compressible_multispecie_sub flow_test_primitive_compressible_multispecie_sub module~flow->program~flow_test_primitive_compressible_multispecie_sub program~flow_test_primitive_compressible_not_eq flow_test_primitive_compressible_not_eq module~flow->program~flow_test_primitive_compressible_not_eq program~flow_test_primitive_compressible_add~2 flow_test_primitive_compressible_add module~flow->program~flow_test_primitive_compressible_add~2 program~flow_test_primitive_compressible_sub flow_test_primitive_compressible_sub module~flow->program~flow_test_primitive_compressible_sub program~flow_test_compressible_transformations flow_test_compressible_transformations module~flow->program~flow_test_compressible_transformations program~flow_test_conservative_compressible_add flow_test_conservative_compressible_add module~flow->program~flow_test_conservative_compressible_add program~flow_test_conservative_compressible_assign flow_test_conservative_compressible_assign module~flow->program~flow_test_conservative_compressible_assign program~flow_test_conservative_compressible_div flow_test_conservative_compressible_div module~flow->program~flow_test_conservative_compressible_div program~flow_test_conservative_compressible_eq flow_test_conservative_compressible_eq module~flow->program~flow_test_conservative_compressible_eq program~flow_test_conservative_compressible_mul flow_test_conservative_compressible_mul module~flow->program~flow_test_conservative_compressible_mul program~flow_test_conservative_compressible_not_eq flow_test_conservative_compressible_not_eq module~flow->program~flow_test_conservative_compressible_not_eq program~flow_test_conservative_compressible_add~2 flow_test_conservative_compressible_add module~flow->program~flow_test_conservative_compressible_add~2 module~flow_compressible_transformations->module~flow var panmoduleflow_conservative_objectUsedByGraph = svgPanZoom('#moduleflow_conservative_objectUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Abstract Interfaces compute_fluxes_interface destroy_interface initialize_interface pressure_interface velocity_interface Derived Types conservative_object Abstract Interfaces abstract interface Abstract interfaces of deferred methods of conservative_object . private subroutine compute_fluxes_interface (self, eos, normal, fluxes) Compute conservative fluxes. Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(in) :: self Conservative. class( eos_object ), intent(in) :: eos Equation of state. type(vector), intent(in) :: normal Normal (versor) of face where fluxes are given. class( conservative_object ), intent(out) :: fluxes Conservative fluxes. abstract interface Abstract interfaces of deferred methods of conservative_object . private elemental subroutine destroy_interface (self) Destroy conservative. Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(inout) :: self conservative. abstract interface Abstract interfaces of deferred methods of conservative_object . private subroutine initialize_interface (self, initial_state) Initialize conservative. Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(inout) :: self conservative. class( conservative_object ), intent(in), optional :: initial_state Initial state. abstract interface Abstract interfaces of deferred methods of conservative_object . private elemental function pressure_interface (self, eos) result(pressure_) Return pressure value. Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(in) :: self Conservative. class( eos_object ), intent(in) :: eos Equation of state. Return Value real(kind=R8P) Pressure value. abstract interface Abstract interfaces of deferred methods of conservative_object . private elemental function velocity_interface (self) result(velocity_) Return velocity vector. Arguments Type Intent Optional Attributes Name class( conservative_object ), intent(in) :: self Conservative. Return Value type(vector) Velocity vector. Derived Types type, public, abstract, extends( field_object ) :: conservative_object conservative object. Type-Bound Procedures procedure(symmetric_op_interface), public, pass(lhs) :: add Operator + . procedure(array_interface), public, pass(self) :: array Return serialized array of field. procedure(assign_interface), public, pass(lhs) :: assign_field Operator = . procedure(assign_real_interface), public, pass(lhs) :: assign_real Operator field = real . generic, public :: assignment(=) => assign_field, assign_real Assignment overloading. procedure(compute_fluxes_interface), public, pass(self) :: compute_fluxes Compute conservative fluxes. procedure(description_interface), public, pass(self) :: description Return pretty-printed object description. procedure(destroy_interface), public, pass(self) :: destroy Destroy conservative. procedure(symmetric_op_interface), public, pass(lhs) :: div Operator / . procedure(field_op_integer_interface), public, pass(lhs) :: div_integer Operator field / integer . procedure(field_op_real_interface), public, pass(lhs) :: div_real Operator field / real . procedure(compare_interface), public, pass(lhs) :: eq Operator `=='. procedure(initialize_interface), public, pass(self) :: initialize Initialize conservative. procedure(integer_op_field_interface), public, pass(rhs) :: integer_mul Operator integer * field . procedure(symmetric_op_interface), public, pass(lhs) :: mul Operator * . procedure(field_op_integer_interface), public, pass(lhs) :: mul_integer Operator field * integer . procedure(field_op_real_interface), public, pass(lhs) :: mul_real Operator field * real . procedure(unary_operator), public, pass(self) :: negative Unary operator - field . procedure(compare_interface), public, pass(lhs) :: not_eq Operator `/='. generic, public :: operator(*) => mul, mul_integer, integer_mul, real_mul, mul_real Operator * overloading. generic, public :: operator(**) => pow_integer, pow_real Operator ** overloading. generic, public :: operator(+) => add, positive Operator + overloading. generic, public :: operator(-) => sub, negative Operator - overloading. generic, public :: operator(/) => div, div_integer, div_real Operator / overloading. generic, public :: operator(/=) => not_eq Operator /= overloading. generic, public :: operator(==) => eq Operator /= overloading. procedure(unary_operator), public, pass(self) :: positive Unary operator + field . procedure(field_op_integer_interface), public, pass(lhs) :: pow_integer Operator field ** integer . procedure(field_op_real_interface), public, pass(lhs) :: pow_real Operator field ** real . procedure(pressure_interface), public, pass(self) :: pressure Return pressure value. procedure(real_op_field_interface), public, pass(rhs) :: real_mul Operator real * field . procedure(symmetric_op_interface), public, pass(lhs) :: sub Operator - . procedure(velocity_interface), public, pass(self) :: velocity Return velocity vector.","tags":"","loc":"module/flow_conservative_object.html","title":"flow_conservative_object – FLOw"},{"text":"Uses: flow_eos_object penf module~~flow_eos_compressible~~UsesGraph module~flow_eos_compressible flow_eos_compressible module~penf penf module~penf->module~flow_eos_compressible module~flow_eos_object flow_eos_object module~penf->module~flow_eos_object module~flow_eos_object->module~flow_eos_compressible module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_stringify penf_stringify module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify var panmoduleflow_eos_compressibleUsesGraph = svgPanZoom('#moduleflow_eos_compressibleUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FLOw EOS (Equation of State) of ideal compressible fluid object. Used By module~~flow_eos_compressible~~UsedByGraph module~flow_eos_compressible flow_eos_compressible module~flow flow module~flow_eos_compressible->module~flow program~flow_test_conservative_compressible_sub flow_test_conservative_compressible_sub module~flow->program~flow_test_conservative_compressible_sub program~flow_test_eos_compressible flow_test_eos_compressible module~flow->program~flow_test_eos_compressible program~flow_test_primitive_compressible_add flow_test_primitive_compressible_add module~flow->program~flow_test_primitive_compressible_add program~flow_test_primitive_compressible_assign flow_test_primitive_compressible_assign module~flow->program~flow_test_primitive_compressible_assign program~flow_test_primitive_compressible_div flow_test_primitive_compressible_div module~flow->program~flow_test_primitive_compressible_div program~flow_test_primitive_compressible_eq flow_test_primitive_compressible_eq module~flow->program~flow_test_primitive_compressible_eq program~flow_test_primitive_compressible_mul flow_test_primitive_compressible_mul module~flow->program~flow_test_primitive_compressible_mul program~flow_test_primitive_compressible_multispecie_add flow_test_primitive_compressible_multispecie_add module~flow->program~flow_test_primitive_compressible_multispecie_add program~flow_test_primitive_compressible_multispecie_assign flow_test_primitive_compressible_multispecie_assign module~flow->program~flow_test_primitive_compressible_multispecie_assign program~flow_test_primitive_compressible_multispecie_div flow_test_primitive_compressible_multispecie_div module~flow->program~flow_test_primitive_compressible_multispecie_div program~flow_test_primitive_compressible_multispecie_eq flow_test_primitive_compressible_multispecie_eq module~flow->program~flow_test_primitive_compressible_multispecie_eq program~flow_test_primitive_compressible_multispecie_mul flow_test_primitive_compressible_multispecie_mul module~flow->program~flow_test_primitive_compressible_multispecie_mul program~flow_test_primitive_compressible_multispecie_not_eq flow_test_primitive_compressible_multispecie_not_eq module~flow->program~flow_test_primitive_compressible_multispecie_not_eq program~flow_test_primitive_compressible_multispecie_add~2 flow_test_primitive_compressible_multispecie_add module~flow->program~flow_test_primitive_compressible_multispecie_add~2 program~flow_test_primitive_compressible_multispecie_sub flow_test_primitive_compressible_multispecie_sub module~flow->program~flow_test_primitive_compressible_multispecie_sub program~flow_test_primitive_compressible_not_eq flow_test_primitive_compressible_not_eq module~flow->program~flow_test_primitive_compressible_not_eq program~flow_test_primitive_compressible_add~2 flow_test_primitive_compressible_add module~flow->program~flow_test_primitive_compressible_add~2 program~flow_test_primitive_compressible_sub flow_test_primitive_compressible_sub module~flow->program~flow_test_primitive_compressible_sub program~flow_test_compressible_transformations flow_test_compressible_transformations module~flow->program~flow_test_compressible_transformations program~flow_test_conservative_compressible_add flow_test_conservative_compressible_add module~flow->program~flow_test_conservative_compressible_add program~flow_test_conservative_compressible_assign flow_test_conservative_compressible_assign module~flow->program~flow_test_conservative_compressible_assign program~flow_test_conservative_compressible_div flow_test_conservative_compressible_div module~flow->program~flow_test_conservative_compressible_div program~flow_test_conservative_compressible_eq flow_test_conservative_compressible_eq module~flow->program~flow_test_conservative_compressible_eq program~flow_test_conservative_compressible_mul flow_test_conservative_compressible_mul module~flow->program~flow_test_conservative_compressible_mul program~flow_test_conservative_compressible_not_eq flow_test_conservative_compressible_not_eq module~flow->program~flow_test_conservative_compressible_not_eq program~flow_test_conservative_compressible_add~2 flow_test_conservative_compressible_add module~flow->program~flow_test_conservative_compressible_add~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Interfaces eos_compressible Derived Types eos_compressible Functions R cp cv delta density description eos_compressible_instance eta g gm1 gp1 internal_energy pressure speed_of_sound temperature total_entalpy Subroutines compute_derivate eos_assign_eos Interfaces public interface eos_compressible Overload eos_compressible name with its constructor. private elemental function eos_compressible_instance (cp, cv, gam, R) result(instance) Return and instance of eos_compressible . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in), optional :: cp Specific heat at constant pressure cp value. real(kind=R8P), intent(in), optional :: cv Specific heat at constant volume cv value. real(kind=R8P), intent(in), optional :: gam Specific heats ratio gamma=cp/cv value. real(kind=R8P), intent(in), optional :: R Fluid constant R=cp-cv value. Return Value type( eos_compressible ) Instance of eos_compressible . Derived Types type, public, extends( eos_object ) :: eos_compressible Equation of state (EOS) of ideal compressible object class. Components Type Visibility Attributes Name Initial real(kind=R8P), private :: R_ = 0._R8P Fluid constant R = cp - cv . real(kind=R8P), private :: cp_ = 0._R8P Specific heat at constant pressure cp . real(kind=R8P), private :: cv_ = 0._R8P Specific heat at constant volume cv . real(kind=R8P), private :: delta_ = 0._R8P (gamma - 1) / 2 . real(kind=R8P), private :: eta_ = 0._R8P 2 * gamma / (gamma - 1) . real(kind=R8P), private :: g_ = 0._R8P Specific heats ratio gamma = cp / cv . real(kind=R8P), private :: gm1_ = 0._R8P gamma - 1 . real(kind=R8P), private :: gp1_ = 0._R8P gamma + 1 . Constructor Overload eos_compressible name with its constructor. private elemental function eos_compressible_instance (cp, cv, gam, R) Return and instance of eos_compressible . Type-Bound Procedures procedure, public, pass(self) :: R Return fluid constant R=cp-cv . generic, public :: assignment(=) => eos_assign_eos Overload = . procedure, public, pass(self) :: compute_derivate Compute derivate quantities (from cp and cv ). procedure, public, pass(self) :: cp Return specific heat at constant pressure. procedure, public, pass(self) :: cv Return specific heat at constant volume. procedure, public, pass(self) :: delta Return (gamma - 1) / 2 . procedure, public, pass(self) :: density Return density. procedure, public, pass(self) :: description Return pretty-printed object description. procedure, public, pass(lhs) :: eos_assign_eos Operator = . procedure, public, pass(self) :: eta Return 2 * gamma / (gamma - 1) . procedure, public, pass(self) :: g Return specific heats ratio gamma=cp/cv . procedure, public, pass(self) :: gm1 Return gamma - 1 . procedure, public, pass(self) :: gp1 Return gamma + 1 . procedure, public, pass(self) :: internal_energy Return specific internal energy. procedure, public, pass(self) :: pressure Return pressure. procedure, public, pass(self) :: speed_of_sound Return speed of sound. procedure, public, pass(self) :: temperature Return temperature. procedure, public, pass(self) :: total_entalpy Return total specific entalpy. Functions private elemental function R (self) result(R_) Return fluid constant R=cp-cv . Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. Return Value real(kind=R8P) Fluid constant value. private elemental function cp (self) result(cp_) Return specific heat at constant pressure. Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. Return Value real(kind=R8P) cp value. private elemental function cv (self) result(cv_) Return specific heat at constant volume. Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. Return Value real(kind=R8P) cv value. private elemental function delta (self) result(delta_) Return (gamma - 1) / 2 . Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. Return Value real(kind=R8P) (gamma - 1) / 2 value. private elemental function density (self, pressure, speed_of_sound) result(density_) Return density. Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. real(kind=R8P), intent(in) :: pressure Pressure value. real(kind=R8P), intent(in) :: speed_of_sound Speed of sound value. Return Value real(kind=R8P) Density value. private pure function description (self, prefix) result(desc) Return a pretty-formatted object description. Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. private elemental function eos_compressible_instance (cp, cv, gam, R) result(instance) Return and instance of eos_compressible . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in), optional :: cp Specific heat at constant pressure cp value. real(kind=R8P), intent(in), optional :: cv Specific heat at constant volume cv value. real(kind=R8P), intent(in), optional :: gam Specific heats ratio gamma=cp/cv value. real(kind=R8P), intent(in), optional :: R Fluid constant R=cp-cv value. Return Value type( eos_compressible ) Instance of eos_compressible . private elemental function eta (self) result(eta_) Return 2 * gamma / (gamma - 1) . Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. Return Value real(kind=R8P) 2 * gamma / (gamma - 1) value. private elemental function g (self) result(g_) Return specific heats ratio gamma=cp/cv . Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. Return Value real(kind=R8P) Specific heats ratio value. private elemental function gm1 (self) result(gm1_) Return gamma - 1 . Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. Return Value real(kind=R8P) gamma - 1 value. private elemental function gp1 (self) result(gp1_) Return gamma + 1 . Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. Return Value real(kind=R8P) gamma + 1 value. private elemental function internal_energy (self, density, pressure, temperature) result(energy_) Return specific internal energy. Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. real(kind=R8P), intent(in), optional :: density Density value. real(kind=R8P), intent(in), optional :: pressure Pressure value. real(kind=R8P), intent(in), optional :: temperature Temperature value. Return Value real(kind=R8P) Energy value. private elemental function pressure (self, density, energy, temperature) result(pressure_) Return pressure. Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. real(kind=R8P), intent(in), optional :: density Density value. real(kind=R8P), intent(in), optional :: energy Specific internal energy value. real(kind=R8P), intent(in), optional :: temperature Temperature value. Return Value real(kind=R8P) Pressure value. private elemental function speed_of_sound (self, density, pressure) result(speed_of_sound_) Return speed of sound. Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. real(kind=R8P), intent(in) :: density Density value. real(kind=R8P), intent(in) :: pressure Pressure value. Return Value real(kind=R8P) Speed of sound value. private elemental function temperature (self, density, energy, pressure) result(temperature_) Return temperature. Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. real(kind=R8P), intent(in), optional :: density Density value. real(kind=R8P), intent(in), optional :: energy Specific internal energy value. real(kind=R8P), intent(in), optional :: pressure Pressure value. Return Value real(kind=R8P) Temperature value. private elemental function total_entalpy (self, density, pressure, velocity_sq_norm) result(entalpy_) Return total specific entalpy. Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(in) :: self Equation of state. real(kind=R8P), intent(in) :: density Density value. real(kind=R8P), intent(in) :: pressure Pressure value. real(kind=R8P), intent(in) :: velocity_sq_norm Velocity vector square norm ||velocity||&#94;2 . Return Value real(kind=R8P) Total specific entalpy (per unit of mass). Subroutines private elemental subroutine compute_derivate (self) Compute derivate quantities (from cp and cv ). Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(inout) :: self Equation of state. private pure subroutine eos_assign_eos (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( eos_compressible ), intent(inout) :: lhs Left hand side. class( eos_object ), intent(in) :: rhs Right hand side.","tags":"","loc":"module/flow_eos_compressible.html","title":"flow_eos_compressible – FLOw"},{"text":"Uses: penf module~~flow_eos_object~~UsesGraph module~flow_eos_object flow_eos_object module~penf penf module~penf->module~flow_eos_object module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_stringify penf_stringify module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FLOw EOS (Equation of State) object. Used By module~~flow_eos_object~~UsedByGraph module~flow_eos_object flow_eos_object module~flow_primitive_compressible_multispecie flow_primitive_compressible_multispecie module~flow_eos_object->module~flow_primitive_compressible_multispecie module~flow flow module~flow_eos_object->module~flow module~flow_conservative_object flow_conservative_object module~flow_eos_object->module~flow_conservative_object module~flow_primitive_object flow_primitive_object module~flow_eos_object->module~flow_primitive_object module~flow_compressible_transformations flow_compressible_transformations module~flow_eos_object->module~flow_compressible_transformations module~flow_eos_compressible flow_eos_compressible module~flow_eos_object->module~flow_eos_compressible module~flow_conservative_compressible flow_conservative_compressible module~flow_eos_object->module~flow_conservative_compressible module~flow_primitive_compressible flow_primitive_compressible module~flow_eos_object->module~flow_primitive_compressible module~flow_primitive_compressible_multispecie->module~flow program~flow_test_conservative_compressible_sub flow_test_conservative_compressible_sub module~flow->program~flow_test_conservative_compressible_sub program~flow_test_eos_compressible flow_test_eos_compressible module~flow->program~flow_test_eos_compressible program~flow_test_primitive_compressible_add flow_test_primitive_compressible_add module~flow->program~flow_test_primitive_compressible_add program~flow_test_primitive_compressible_assign flow_test_primitive_compressible_assign module~flow->program~flow_test_primitive_compressible_assign program~flow_test_primitive_compressible_div flow_test_primitive_compressible_div module~flow->program~flow_test_primitive_compressible_div program~flow_test_primitive_compressible_eq flow_test_primitive_compressible_eq module~flow->program~flow_test_primitive_compressible_eq program~flow_test_primitive_compressible_mul flow_test_primitive_compressible_mul module~flow->program~flow_test_primitive_compressible_mul program~flow_test_primitive_compressible_multispecie_add flow_test_primitive_compressible_multispecie_add module~flow->program~flow_test_primitive_compressible_multispecie_add program~flow_test_primitive_compressible_multispecie_assign flow_test_primitive_compressible_multispecie_assign module~flow->program~flow_test_primitive_compressible_multispecie_assign program~flow_test_primitive_compressible_multispecie_div flow_test_primitive_compressible_multispecie_div module~flow->program~flow_test_primitive_compressible_multispecie_div program~flow_test_primitive_compressible_multispecie_eq flow_test_primitive_compressible_multispecie_eq module~flow->program~flow_test_primitive_compressible_multispecie_eq program~flow_test_primitive_compressible_multispecie_mul flow_test_primitive_compressible_multispecie_mul module~flow->program~flow_test_primitive_compressible_multispecie_mul program~flow_test_primitive_compressible_multispecie_not_eq flow_test_primitive_compressible_multispecie_not_eq module~flow->program~flow_test_primitive_compressible_multispecie_not_eq program~flow_test_primitive_compressible_multispecie_add~2 flow_test_primitive_compressible_multispecie_add module~flow->program~flow_test_primitive_compressible_multispecie_add~2 program~flow_test_primitive_compressible_multispecie_sub flow_test_primitive_compressible_multispecie_sub module~flow->program~flow_test_primitive_compressible_multispecie_sub program~flow_test_primitive_compressible_not_eq flow_test_primitive_compressible_not_eq module~flow->program~flow_test_primitive_compressible_not_eq program~flow_test_primitive_compressible_add~2 flow_test_primitive_compressible_add module~flow->program~flow_test_primitive_compressible_add~2 program~flow_test_primitive_compressible_sub flow_test_primitive_compressible_sub module~flow->program~flow_test_primitive_compressible_sub program~flow_test_compressible_transformations flow_test_compressible_transformations module~flow->program~flow_test_compressible_transformations program~flow_test_conservative_compressible_add flow_test_conservative_compressible_add module~flow->program~flow_test_conservative_compressible_add program~flow_test_conservative_compressible_assign flow_test_conservative_compressible_assign module~flow->program~flow_test_conservative_compressible_assign program~flow_test_conservative_compressible_div flow_test_conservative_compressible_div module~flow->program~flow_test_conservative_compressible_div program~flow_test_conservative_compressible_eq flow_test_conservative_compressible_eq module~flow->program~flow_test_conservative_compressible_eq program~flow_test_conservative_compressible_mul flow_test_conservative_compressible_mul module~flow->program~flow_test_conservative_compressible_mul program~flow_test_conservative_compressible_not_eq flow_test_conservative_compressible_not_eq module~flow->program~flow_test_conservative_compressible_not_eq program~flow_test_conservative_compressible_add~2 flow_test_conservative_compressible_add module~flow->program~flow_test_conservative_compressible_add~2 module~flow_conservative_object->module~flow module~flow_conservative_object->module~flow_conservative_compressible module~flow_primitive_object->module~flow_primitive_compressible_multispecie module~flow_primitive_object->module~flow module~flow_primitive_object->module~flow_primitive_compressible module~flow_compressible_transformations->module~flow module~flow_eos_compressible->module~flow module~flow_conservative_compressible->module~flow module~flow_conservative_compressible->module~flow_compressible_transformations module~flow_primitive_compressible->module~flow module~flow_primitive_compressible->module~flow_compressible_transformations var panmoduleflow_eos_objectUsedByGraph = svgPanZoom('#moduleflow_eos_objectUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Abstract Interfaces assignment_interface density_interface description_interface internal_energy_interface pressure_interface scalar_interface speed_of_sound_interface temperature_interface total_entalpy_interface Derived Types eos_object Abstract Interfaces abstract interface Abstract interfaces of deferred methods of eos_object . private pure subroutine assignment_interface (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( eos_object ), intent(inout) :: lhs Left hand side. class( eos_object ), intent(in) :: rhs Right hand side. abstract interface Abstract interfaces of deferred methods of eos_object . private elemental function density_interface (self, pressure, speed_of_sound) result(density_) Return density. Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. real(kind=R8P), intent(in) :: pressure Pressure value. real(kind=R8P), intent(in) :: speed_of_sound Speed of sound value. Return Value real(kind=R8P) Density value. abstract interface Abstract interfaces of deferred methods of eos_object . private pure function description_interface (self, prefix) result(desc) Return a pretty-formatted object description. Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. abstract interface Abstract interfaces of deferred methods of eos_object . private elemental function internal_energy_interface (self, density, pressure, temperature) result(energy_) Return specific internal energy. Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. real(kind=R8P), intent(in), optional :: density Density value. real(kind=R8P), intent(in), optional :: pressure Pressure value. real(kind=R8P), intent(in), optional :: temperature Temperature value. Return Value real(kind=R8P) Energy value. abstract interface Abstract interfaces of deferred methods of eos_object . private elemental function pressure_interface (self, density, energy, temperature) result(pressure_) Return pressure. Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. real(kind=R8P), intent(in), optional :: density Density value. real(kind=R8P), intent(in), optional :: energy Specific internal energy value. real(kind=R8P), intent(in), optional :: temperature Temperature value. Return Value real(kind=R8P) Pressure value. abstract interface Abstract interfaces of deferred methods of eos_object . private elemental function scalar_interface (self) result(scalar_) Return a scalar real value by only self data. Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. Return Value real(kind=R8P) Scalar value. abstract interface Abstract interfaces of deferred methods of eos_object . private elemental function speed_of_sound_interface (self, density, pressure) result(speed_of_sound_) Return speed of sound. Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. real(kind=R8P), intent(in) :: density Density value. real(kind=R8P), intent(in) :: pressure Pressure value. Return Value real(kind=R8P) Speed of sound value. abstract interface Abstract interfaces of deferred methods of eos_object . private elemental function temperature_interface (self, density, energy, pressure) result(temperature_) Return temperature. Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. real(kind=R8P), intent(in), optional :: density Density value. real(kind=R8P), intent(in), optional :: energy Specific internal energy value. real(kind=R8P), intent(in), optional :: pressure Pressure value. Return Value real(kind=R8P) Temperature value. abstract interface Abstract interfaces of deferred methods of eos_object . private elemental function total_entalpy_interface (self, density, pressure, velocity_sq_norm) result(entalpy_) Return total specific entalpy. Arguments Type Intent Optional Attributes Name class( eos_object ), intent(in) :: self Equation of state. real(kind=R8P), intent(in) :: density Density value. real(kind=R8P), intent(in) :: pressure Pressure value. real(kind=R8P), intent(in) :: velocity_sq_norm Velocity vector square norm ||velocity||&#94;2 . Return Value real(kind=R8P) Total specific entalpy (per unit of mass). Derived Types type, public, abstract :: eos_object Equation of State (EOS) object class. Type-Bound Procedures procedure(scalar_interface), public, pass(self) :: R Return fluid constant R=cp-cv . generic, public :: assignment(=) => eos_assign_eos Overload = . procedure(scalar_interface), public, pass(self) :: cp Return specific heat at constant pressure. procedure(scalar_interface), public, pass(self) :: cv Return specific heat at constant volume. procedure(scalar_interface), public, pass(self) :: delta Return (gamma - 1) / 2 . procedure(density_interface), public, pass(self) :: density Return density. procedure(description_interface), public, pass(self) :: description Return pretty-printed object description. procedure(assignment_interface), public, pass(lhs) :: eos_assign_eos Operator = . procedure(scalar_interface), public, pass(self) :: eta Return 2 * gamma / (gamma - 1) . procedure(scalar_interface), public, pass(self) :: g Return specific heats ratio gamma=cp/cv . procedure(scalar_interface), public, pass(self) :: gm1 Return gamma - 1 . procedure(scalar_interface), public, pass(self) :: gp1 Return gamma + 1 . procedure(internal_energy_interface), public, pass(self) :: internal_energy Return specific internal energy. procedure(pressure_interface), public, pass(self) :: pressure Return pressure. procedure(speed_of_sound_interface), public, pass(self) :: speed_of_sound Return speed of sound. procedure(temperature_interface), public, pass(self) :: temperature Return temperature. procedure(total_entalpy_interface), public, pass(self) :: total_entalpy Return total specific entalpy.","tags":"","loc":"module/flow_eos_object.html","title":"flow_eos_object – FLOw"},{"text":"Uses: penf module~~flow_field_object~~UsesGraph module~flow_field_object flow_field_object module~penf penf module~penf->module~flow_field_object module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_stringify penf_stringify module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FLOw field abstract object. Used By module~~flow_field_object~~UsedByGraph module~flow_field_object flow_field_object module~flow_primitive_compressible_multispecie flow_primitive_compressible_multispecie module~flow_field_object->module~flow_primitive_compressible_multispecie module~flow flow module~flow_field_object->module~flow module~flow_conservative_object flow_conservative_object module~flow_field_object->module~flow_conservative_object module~flow_primitive_compressible flow_primitive_compressible module~flow_field_object->module~flow_primitive_compressible module~flow_field_scalar_vectorial flow_field_scalar_vectorial module~flow_field_object->module~flow_field_scalar_vectorial module~flow_conservative_compressible flow_conservative_compressible module~flow_field_object->module~flow_conservative_compressible module~flow_primitive_object flow_primitive_object module~flow_field_object->module~flow_primitive_object module~flow_primitive_compressible_multispecie->module~flow program~flow_test_conservative_compressible_sub flow_test_conservative_compressible_sub module~flow->program~flow_test_conservative_compressible_sub program~flow_test_eos_compressible flow_test_eos_compressible module~flow->program~flow_test_eos_compressible program~flow_test_primitive_compressible_add flow_test_primitive_compressible_add module~flow->program~flow_test_primitive_compressible_add program~flow_test_primitive_compressible_assign flow_test_primitive_compressible_assign module~flow->program~flow_test_primitive_compressible_assign program~flow_test_primitive_compressible_div flow_test_primitive_compressible_div module~flow->program~flow_test_primitive_compressible_div program~flow_test_primitive_compressible_eq flow_test_primitive_compressible_eq module~flow->program~flow_test_primitive_compressible_eq program~flow_test_primitive_compressible_mul flow_test_primitive_compressible_mul module~flow->program~flow_test_primitive_compressible_mul program~flow_test_primitive_compressible_multispecie_add flow_test_primitive_compressible_multispecie_add module~flow->program~flow_test_primitive_compressible_multispecie_add program~flow_test_primitive_compressible_multispecie_assign flow_test_primitive_compressible_multispecie_assign module~flow->program~flow_test_primitive_compressible_multispecie_assign program~flow_test_primitive_compressible_multispecie_div flow_test_primitive_compressible_multispecie_div module~flow->program~flow_test_primitive_compressible_multispecie_div program~flow_test_primitive_compressible_multispecie_eq flow_test_primitive_compressible_multispecie_eq module~flow->program~flow_test_primitive_compressible_multispecie_eq program~flow_test_primitive_compressible_multispecie_mul flow_test_primitive_compressible_multispecie_mul module~flow->program~flow_test_primitive_compressible_multispecie_mul program~flow_test_primitive_compressible_multispecie_not_eq flow_test_primitive_compressible_multispecie_not_eq module~flow->program~flow_test_primitive_compressible_multispecie_not_eq program~flow_test_primitive_compressible_multispecie_add~2 flow_test_primitive_compressible_multispecie_add module~flow->program~flow_test_primitive_compressible_multispecie_add~2 program~flow_test_primitive_compressible_multispecie_sub flow_test_primitive_compressible_multispecie_sub module~flow->program~flow_test_primitive_compressible_multispecie_sub program~flow_test_primitive_compressible_not_eq flow_test_primitive_compressible_not_eq module~flow->program~flow_test_primitive_compressible_not_eq program~flow_test_primitive_compressible_add~2 flow_test_primitive_compressible_add module~flow->program~flow_test_primitive_compressible_add~2 program~flow_test_primitive_compressible_sub flow_test_primitive_compressible_sub module~flow->program~flow_test_primitive_compressible_sub program~flow_test_compressible_transformations flow_test_compressible_transformations module~flow->program~flow_test_compressible_transformations program~flow_test_conservative_compressible_add flow_test_conservative_compressible_add module~flow->program~flow_test_conservative_compressible_add program~flow_test_conservative_compressible_assign flow_test_conservative_compressible_assign module~flow->program~flow_test_conservative_compressible_assign program~flow_test_conservative_compressible_div flow_test_conservative_compressible_div module~flow->program~flow_test_conservative_compressible_div program~flow_test_conservative_compressible_eq flow_test_conservative_compressible_eq module~flow->program~flow_test_conservative_compressible_eq program~flow_test_conservative_compressible_mul flow_test_conservative_compressible_mul module~flow->program~flow_test_conservative_compressible_mul program~flow_test_conservative_compressible_not_eq flow_test_conservative_compressible_not_eq module~flow->program~flow_test_conservative_compressible_not_eq program~flow_test_conservative_compressible_add~2 flow_test_conservative_compressible_add module~flow->program~flow_test_conservative_compressible_add~2 module~flow_conservative_object->module~flow module~flow_conservative_object->module~flow_conservative_compressible module~flow_primitive_compressible->module~flow module~flow_compressible_transformations flow_compressible_transformations module~flow_primitive_compressible->module~flow_compressible_transformations module~flow_field_scalar_vectorial->module~flow module~flow_conservative_compressible->module~flow module~flow_conservative_compressible->module~flow_compressible_transformations module~flow_primitive_object->module~flow_primitive_compressible_multispecie module~flow_primitive_object->module~flow module~flow_primitive_object->module~flow_primitive_compressible module~flow_compressible_transformations->module~flow var panmoduleflow_field_objectUsedByGraph = svgPanZoom('#moduleflow_field_objectUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Abstract Interfaces array_interface assign_interface assign_real_interface compare_interface description_interface field_op_integer_interface field_op_real_interface integer_op_field_interface real_op_field_interface symmetric_op_interface unary_operator Derived Types field_object Abstract Interfaces abstract interface Abstract interfaces of deferred methods of field_object . private pure function array_interface (self) result(array_) Return serialized array of field. Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: self Field. Return Value real(kind=R8P),\n  allocatable, (:) Serialized array of field. abstract interface Abstract interfaces of deferred methods of field_object . private elemental subroutine assign_interface (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( field_object ), intent(inout) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. abstract interface Abstract interfaces of deferred methods of field_object . private elemental subroutine assign_real_interface (lhs, rhs) Operator field = real . Arguments Type Intent Optional Attributes Name class( field_object ), intent(inout) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. abstract interface Abstract interfaces of deferred methods of field_object . private elemental function compare_interface (lhs, rhs) result(opr) Operator `field.compare.field'. Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. abstract interface Abstract interfaces of deferred methods of field_object . private pure function description_interface (self, prefix) result(desc) Return a pretty-formatted object description. Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: self Field. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. abstract interface Abstract interfaces of deferred methods of field_object . private elemental function field_op_integer_interface (lhs, rhs) result(opr) Operator field.op.integer . Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. abstract interface Abstract interfaces of deferred methods of field_object . private elemental function field_op_real_interface (lhs, rhs) result(opr) Operator field.op.real . Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. abstract interface Abstract interfaces of deferred methods of field_object . private elemental function integer_op_field_interface (lhs, rhs) result(opr) Operator field.op.integer . Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. abstract interface Abstract interfaces of deferred methods of field_object . private elemental function real_op_field_interface (lhs, rhs) result(opr) Operator real.op.field . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. abstract interface Abstract interfaces of deferred methods of field_object . private elemental function symmetric_op_interface (lhs, rhs) result(opr) Operator field.op.field . Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. abstract interface Abstract interfaces of deferred methods of field_object . private function unary_operator (self) result(opr) Unary operator .op.field . Arguments Type Intent Optional Attributes Name class( field_object ), intent(in) :: self Field. Return Value class( field_object ),\n  allocatable Operator result. Derived Types type, public, abstract :: field_object Field abstract object. Type-Bound Procedures procedure(symmetric_op_interface), public, pass(lhs) :: add Operator + . procedure(array_interface), public, pass(self) :: array Return serialized array of field. procedure(assign_interface), public, pass(lhs) :: assign_field Operator = . procedure(assign_real_interface), public, pass(lhs) :: assign_real Operator field = real . generic, public :: assignment(=) => assign_field, assign_real Assignment overloading. procedure(description_interface), public, pass(self) :: description Return pretty-printed object description. procedure(symmetric_op_interface), public, pass(lhs) :: div Operator / . procedure(field_op_integer_interface), public, pass(lhs) :: div_integer Operator field / integer . procedure(field_op_real_interface), public, pass(lhs) :: div_real Operator field / real . procedure(compare_interface), public, pass(lhs) :: eq Operator `=='. procedure(integer_op_field_interface), public, pass(rhs) :: integer_mul Operator integer * field . procedure(symmetric_op_interface), public, pass(lhs) :: mul Operator * . procedure(field_op_integer_interface), public, pass(lhs) :: mul_integer Operator field * integer . procedure(field_op_real_interface), public, pass(lhs) :: mul_real Operator field * real . procedure(unary_operator), public, pass(self) :: negative Unary operator - field . procedure(compare_interface), public, pass(lhs) :: not_eq Operator `/='. generic, public :: operator(*) => mul, mul_integer, integer_mul, real_mul, mul_real Operator * overloading. generic, public :: operator(**) => pow_integer, pow_real Operator ** overloading. generic, public :: operator(+) => add, positive Operator + overloading. generic, public :: operator(-) => sub, negative Operator - overloading. generic, public :: operator(/) => div, div_integer, div_real Operator / overloading. generic, public :: operator(/=) => not_eq Operator /= overloading. generic, public :: operator(==) => eq Operator /= overloading. procedure(unary_operator), public, pass(self) :: positive Unary operator + field . procedure(field_op_integer_interface), public, pass(lhs) :: pow_integer Operator field ** integer . procedure(field_op_real_interface), public, pass(lhs) :: pow_real Operator field ** real . procedure(real_op_field_interface), public, pass(rhs) :: real_mul Operator real * field . procedure(symmetric_op_interface), public, pass(lhs) :: sub Operator - .","tags":"","loc":"module/flow_field_object.html","title":"flow_field_object – FLOw"},{"text":"Uses: flow_field_object penf VecFor module~~flow_field_scalar_vectorial~~UsesGraph module~flow_field_scalar_vectorial flow_field_scalar_vectorial module~penf penf module~penf->module~flow_field_scalar_vectorial module~flow_field_object flow_field_object module~penf->module~flow_field_object module~flow_field_object->module~flow_field_scalar_vectorial module~vecfor VecFor module~vecfor->module~flow_field_scalar_vectorial module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_stringify penf_stringify module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~vecfor iso_fortran_env->module~penf_stringify var panmoduleflow_field_scalar_vectorialUsesGraph = svgPanZoom('#moduleflow_field_scalar_vectorialUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FLOw field concrete scalar and vectorial objects. Used By module~~flow_field_scalar_vectorial~~UsedByGraph module~flow_field_scalar_vectorial flow_field_scalar_vectorial module~flow flow module~flow_field_scalar_vectorial->module~flow program~flow_test_conservative_compressible_sub flow_test_conservative_compressible_sub module~flow->program~flow_test_conservative_compressible_sub program~flow_test_eos_compressible flow_test_eos_compressible module~flow->program~flow_test_eos_compressible program~flow_test_primitive_compressible_add flow_test_primitive_compressible_add module~flow->program~flow_test_primitive_compressible_add program~flow_test_primitive_compressible_assign flow_test_primitive_compressible_assign module~flow->program~flow_test_primitive_compressible_assign program~flow_test_primitive_compressible_div flow_test_primitive_compressible_div module~flow->program~flow_test_primitive_compressible_div program~flow_test_primitive_compressible_eq flow_test_primitive_compressible_eq module~flow->program~flow_test_primitive_compressible_eq program~flow_test_primitive_compressible_mul flow_test_primitive_compressible_mul module~flow->program~flow_test_primitive_compressible_mul program~flow_test_primitive_compressible_multispecie_add flow_test_primitive_compressible_multispecie_add module~flow->program~flow_test_primitive_compressible_multispecie_add program~flow_test_primitive_compressible_multispecie_assign flow_test_primitive_compressible_multispecie_assign module~flow->program~flow_test_primitive_compressible_multispecie_assign program~flow_test_primitive_compressible_multispecie_div flow_test_primitive_compressible_multispecie_div module~flow->program~flow_test_primitive_compressible_multispecie_div program~flow_test_primitive_compressible_multispecie_eq flow_test_primitive_compressible_multispecie_eq module~flow->program~flow_test_primitive_compressible_multispecie_eq program~flow_test_primitive_compressible_multispecie_mul flow_test_primitive_compressible_multispecie_mul module~flow->program~flow_test_primitive_compressible_multispecie_mul program~flow_test_primitive_compressible_multispecie_not_eq flow_test_primitive_compressible_multispecie_not_eq module~flow->program~flow_test_primitive_compressible_multispecie_not_eq program~flow_test_primitive_compressible_multispecie_add~2 flow_test_primitive_compressible_multispecie_add module~flow->program~flow_test_primitive_compressible_multispecie_add~2 program~flow_test_primitive_compressible_multispecie_sub flow_test_primitive_compressible_multispecie_sub module~flow->program~flow_test_primitive_compressible_multispecie_sub program~flow_test_primitive_compressible_not_eq flow_test_primitive_compressible_not_eq module~flow->program~flow_test_primitive_compressible_not_eq program~flow_test_primitive_compressible_add~2 flow_test_primitive_compressible_add module~flow->program~flow_test_primitive_compressible_add~2 program~flow_test_primitive_compressible_sub flow_test_primitive_compressible_sub module~flow->program~flow_test_primitive_compressible_sub program~flow_test_compressible_transformations flow_test_compressible_transformations module~flow->program~flow_test_compressible_transformations program~flow_test_conservative_compressible_add flow_test_conservative_compressible_add module~flow->program~flow_test_conservative_compressible_add program~flow_test_conservative_compressible_assign flow_test_conservative_compressible_assign module~flow->program~flow_test_conservative_compressible_assign program~flow_test_conservative_compressible_div flow_test_conservative_compressible_div module~flow->program~flow_test_conservative_compressible_div program~flow_test_conservative_compressible_eq flow_test_conservative_compressible_eq module~flow->program~flow_test_conservative_compressible_eq program~flow_test_conservative_compressible_mul flow_test_conservative_compressible_mul module~flow->program~flow_test_conservative_compressible_mul program~flow_test_conservative_compressible_not_eq flow_test_conservative_compressible_not_eq module~flow->program~flow_test_conservative_compressible_not_eq program~flow_test_conservative_compressible_add~2 flow_test_conservative_compressible_add module~flow->program~flow_test_conservative_compressible_add~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Derived Types field_scalar field_vectorial Functions array_scalar array_vectorial description_scalar description_vectorial eq_scalar eq_vectorial integer_mul_scalar integer_mul_vectorial negative_scalar negative_vectorial not_eq_scalar not_eq_vectorial positive_scalar positive_vectorial real_mul_scalar real_mul_vectorial scalar_add_scalar scalar_div_integer scalar_div_real scalar_div_scalar scalar_mul_integer scalar_mul_object scalar_mul_real scalar_pow_integer scalar_pow_real scalar_sub_scalar vectorial_add_vectorial vectorial_div_integer vectorial_div_object vectorial_div_real vectorial_mul_integer vectorial_mul_object vectorial_mul_real vectorial_pow_integer vectorial_pow_real vectorial_sub_vectorial Subroutines assign_field_scalar assign_field_vectorial assign_real_scalar assign_real_vectorial Derived Types type, public, extends( field_object ) :: field_scalar Scalar field object. Components Type Visibility Attributes Name Initial real(kind=R8P), public :: field Scalar field. Type-Bound Procedures procedure, public, pass(lhs) :: add => scalar_add_scalar Operator + . procedure, public, pass(self) :: array => array_scalar Return serialized array of field. procedure, public, pass(lhs) :: assign_field => assign_field_scalar Operator = . procedure, public, pass(lhs) :: assign_real => assign_real_scalar Operator field = real . generic, public :: assignment(=) => assign_field, assign_real Assignment overloading. procedure, public, pass(self) :: description => description_scalar Return pretty-printed object description. procedure, public, pass(lhs) :: div => scalar_div_scalar Operator / . procedure, public, pass(lhs) :: div_integer => scalar_div_integer Operator field / integer . procedure, public, pass(lhs) :: div_real => scalar_div_real Operator field / real . procedure, public, pass(lhs) :: eq => eq_scalar Operator `=='. procedure, public, pass(rhs) :: integer_mul => integer_mul_scalar Operator integer * field . procedure, public, pass(lhs) :: mul => scalar_mul_object Operator * . procedure, public, pass(lhs) :: mul_integer => scalar_mul_integer Operator field * integer . procedure, public, pass(lhs) :: mul_real => scalar_mul_real Operator field * real . procedure, public, pass(self) :: negative => negative_scalar Unary operator - field . procedure, public, pass(lhs) :: not_eq => not_eq_scalar Operator `/='. generic, public :: operator(*) => mul, mul_integer, integer_mul, real_mul, mul_real Operator * overloading. generic, public :: operator(**) => pow_integer, pow_real Operator ** overloading. generic, public :: operator(+) => add, positive Operator + overloading. generic, public :: operator(-) => sub, negative Operator - overloading. generic, public :: operator(/) => div, div_integer, div_real Operator / overloading. generic, public :: operator(/=) => not_eq Operator /= overloading. generic, public :: operator(==) => eq Operator /= overloading. procedure, public, pass(self) :: positive => positive_scalar Unary operator + field . procedure, public, pass(lhs) :: pow_integer => scalar_pow_integer Operator field ** integer . procedure, public, pass(lhs) :: pow_real => scalar_pow_real Operator field ** real . procedure, public, pass(rhs) :: real_mul => real_mul_scalar Operator real * field . procedure, public, pass(lhs) :: sub => scalar_sub_scalar Operator - . type, public, extends( field_object ) :: field_vectorial Vectorial field object. Components Type Visibility Attributes Name Initial type(vector), public :: field Vectorial field. Type-Bound Procedures procedure, public, pass(lhs) :: add => vectorial_add_vectorial Operator + . procedure, public, pass(self) :: array => array_vectorial Return serialized array of field. procedure, public, pass(lhs) :: assign_field => assign_field_vectorial Operator = . procedure, public, pass(lhs) :: assign_real => assign_real_vectorial Operator field = real . generic, public :: assignment(=) => assign_field, assign_real Assignment overloading. procedure, public, pass(self) :: description => description_vectorial Return pretty-printed object description. procedure, public, pass(lhs) :: div => vectorial_div_object Operator / . procedure, public, pass(lhs) :: div_integer => vectorial_div_integer Operator field / integer . procedure, public, pass(lhs) :: div_real => vectorial_div_real Operator field / real . procedure, public, pass(lhs) :: eq => eq_vectorial Operator `=='. procedure, public, pass(rhs) :: integer_mul => integer_mul_vectorial Operator integer * field . procedure, public, pass(lhs) :: mul => vectorial_mul_object Operator * . procedure, public, pass(lhs) :: mul_integer => vectorial_mul_integer Operator field * integer . procedure, public, pass(lhs) :: mul_real => vectorial_mul_real Operator field * real . procedure, public, pass(self) :: negative => negative_vectorial Unary operator - field . procedure, public, pass(lhs) :: not_eq => not_eq_vectorial Operator `/='. generic, public :: operator(*) => mul, mul_integer, integer_mul, real_mul, mul_real Operator * overloading. generic, public :: operator(**) => pow_integer, pow_real Operator ** overloading. generic, public :: operator(+) => add, positive Operator + overloading. generic, public :: operator(-) => sub, negative Operator - overloading. generic, public :: operator(/) => div, div_integer, div_real Operator / overloading. generic, public :: operator(/=) => not_eq Operator /= overloading. generic, public :: operator(==) => eq Operator /= overloading. procedure, public, pass(self) :: positive => positive_vectorial Unary operator + field . procedure, public, pass(lhs) :: pow_integer => vectorial_pow_integer Operator field ** integer . procedure, public, pass(lhs) :: pow_real => vectorial_pow_real Operator field ** real . procedure, public, pass(rhs) :: real_mul => real_mul_vectorial Operator real * field . procedure, public, pass(lhs) :: sub => vectorial_sub_vectorial Operator - . Functions private pure function array_scalar (self) result(array_) Return serialized array of field. Arguments Type Intent Optional Attributes Name class( field_scalar ), intent(in) :: self Field. Return Value real(kind=R8P),\n  allocatable, (:) Serialized array of field. private pure function array_vectorial (self) result(array_) Return serialized array of field. Arguments Type Intent Optional Attributes Name class( field_vectorial ), intent(in) :: self Field. Return Value real(kind=R8P),\n  allocatable, (:) Serialized array of field. private pure function description_scalar (self, prefix) result(desc) Return a pretty-formatted object description. Arguments Type Intent Optional Attributes Name class( field_scalar ), intent(in) :: self Primitive. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. private pure function description_vectorial (self, prefix) result(desc) Return a pretty-formatted object description. Arguments Type Intent Optional Attributes Name class( field_vectorial ), intent(in) :: self Primitive. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. private elemental function eq_scalar (lhs, rhs) result(opr) Operator `=='. Arguments Type Intent Optional Attributes Name class( field_scalar ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. private elemental function eq_vectorial (lhs, rhs) result(opr) Operator `=='. Arguments Type Intent Optional Attributes Name class( field_vectorial ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. private elemental function integer_mul_scalar (lhs, rhs) result(opr) Operator integer * field . Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: lhs Left hand side. class( field_scalar ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function integer_mul_vectorial (lhs, rhs) result(opr) Operator integer * field . Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: lhs Left hand side. class( field_vectorial ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private function negative_scalar (self) result(opr) Unary operator - field . Arguments Type Intent Optional Attributes Name class( field_scalar ), intent(in) :: self Primitive. Return Value class( field_object ),\n  allocatable Operator result. private function negative_vectorial (self) result(opr) Unary operator + field . Arguments Type Intent Optional Attributes Name class( field_vectorial ), intent(in) :: self Primitive. Return Value class( field_object ),\n  allocatable Operator result. private elemental function not_eq_scalar (lhs, rhs) result(opr) Operator `/='. Arguments Type Intent Optional Attributes Name class( field_scalar ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. private elemental function not_eq_vectorial (lhs, rhs) result(opr) Operator `/='. Arguments Type Intent Optional Attributes Name class( field_vectorial ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. private function positive_scalar (self) result(opr) Unary operator + field . Arguments Type Intent Optional Attributes Name class( field_scalar ), intent(in) :: self Primitive. Return Value class( field_object ),\n  allocatable Operator result. private function positive_vectorial (self) result(opr) Unary operator + field . Arguments Type Intent Optional Attributes Name class( field_vectorial ), intent(in) :: self Primitive. Return Value class( field_object ),\n  allocatable Operator result. private elemental function real_mul_scalar (lhs, rhs) result(opr) Operator real * field . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs Left hand side. class( field_scalar ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function real_mul_vectorial (lhs, rhs) result(opr) Operator real * field . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs Left hand side. class( field_vectorial ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function scalar_add_scalar (lhs, rhs) result(opr) Operator + . Arguments Type Intent Optional Attributes Name class( field_scalar ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function scalar_div_integer (lhs, rhs) result(opr) Operator field / integer . Arguments Type Intent Optional Attributes Name class( field_scalar ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function scalar_div_real (lhs, rhs) result(opr) Operator field / real . Arguments Type Intent Optional Attributes Name class( field_scalar ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function scalar_div_scalar (lhs, rhs) result(opr) Operator / . Arguments Type Intent Optional Attributes Name class( field_scalar ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function scalar_mul_integer (lhs, rhs) result(opr) Operator field * integer . Arguments Type Intent Optional Attributes Name class( field_scalar ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function scalar_mul_object (lhs, rhs) result(opr) Operator * . Arguments Type Intent Optional Attributes Name class( field_scalar ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function scalar_mul_real (lhs, rhs) result(opr) Operator field * real . Arguments Type Intent Optional Attributes Name class( field_scalar ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function scalar_pow_integer (lhs, rhs) result(opr) Operator field ** integer . Arguments Type Intent Optional Attributes Name class( field_scalar ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function scalar_pow_real (lhs, rhs) result(opr) Operator field ** real . Arguments Type Intent Optional Attributes Name class( field_scalar ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function scalar_sub_scalar (lhs, rhs) result(opr) Operator - . Arguments Type Intent Optional Attributes Name class( field_scalar ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function vectorial_add_vectorial (lhs, rhs) result(opr) Operator + . Arguments Type Intent Optional Attributes Name class( field_vectorial ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function vectorial_div_integer (lhs, rhs) result(opr) Operator field / integer . Arguments Type Intent Optional Attributes Name class( field_vectorial ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function vectorial_div_object (lhs, rhs) result(opr) Operator / . Arguments Type Intent Optional Attributes Name class( field_vectorial ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function vectorial_div_real (lhs, rhs) result(opr) Operator field / real . Arguments Type Intent Optional Attributes Name class( field_vectorial ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function vectorial_mul_integer (lhs, rhs) result(opr) Operator field * integer . Arguments Type Intent Optional Attributes Name class( field_vectorial ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function vectorial_mul_object (lhs, rhs) result(opr) Operator * . Arguments Type Intent Optional Attributes Name class( field_vectorial ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function vectorial_mul_real (lhs, rhs) result(opr) Operator field * real . Arguments Type Intent Optional Attributes Name class( field_vectorial ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function vectorial_pow_integer (lhs, rhs) result(opr) Operator field ** integer . Arguments Type Intent Optional Attributes Name class( field_vectorial ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function vectorial_pow_real (lhs, rhs) result(opr) Operator field ** real . Arguments Type Intent Optional Attributes Name class( field_vectorial ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function vectorial_sub_vectorial (lhs, rhs) result(opr) Operator - . Arguments Type Intent Optional Attributes Name class( field_vectorial ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Subroutines private elemental subroutine assign_field_scalar (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( field_scalar ), intent(inout) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. private elemental subroutine assign_field_vectorial (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( field_vectorial ), intent(inout) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. private elemental subroutine assign_real_scalar (lhs, rhs) Operator field = real . Arguments Type Intent Optional Attributes Name class( field_scalar ), intent(inout) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. private elemental subroutine assign_real_vectorial (lhs, rhs) Operator field = real . Arguments Type Intent Optional Attributes Name class( field_vectorial ), intent(inout) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side.","tags":"","loc":"module/flow_field_scalar_vectorial.html","title":"flow_field_scalar_vectorial – FLOw"},{"text":"Uses: iso_fortran_env flow_eos_object flow_field_object flow_primitive_object penf VecFor module~~flow_primitive_compressible~~UsesGraph module~flow_primitive_compressible flow_primitive_compressible iso_fortran_env iso_fortran_env iso_fortran_env->module~flow_primitive_compressible module~vecfor VecFor iso_fortran_env->module~vecfor module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~flow_eos_object flow_eos_object module~flow_eos_object->module~flow_primitive_compressible module~flow_primitive_object flow_primitive_object module~flow_eos_object->module~flow_primitive_object module~flow_field_object flow_field_object module~flow_field_object->module~flow_primitive_compressible module~flow_field_object->module~flow_primitive_object module~penf penf module~penf->module~flow_primitive_compressible module~penf->module~flow_eos_object module~penf->module~flow_field_object module~penf->module~flow_primitive_object module~vecfor->module~flow_primitive_compressible module~vecfor->module~flow_primitive_object module~flow_primitive_object->module~flow_primitive_compressible module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf var panmoduleflow_primitive_compressibleUsesGraph = svgPanZoom('#moduleflow_primitive_compressibleUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FLOw primitive compressible object. primitive_compressible is a class that handles compressible primitive fluid dynamic variables. Used By module~~flow_primitive_compressible~~UsedByGraph module~flow_primitive_compressible flow_primitive_compressible module~flow_compressible_transformations flow_compressible_transformations module~flow_primitive_compressible->module~flow_compressible_transformations module~flow flow module~flow_primitive_compressible->module~flow module~flow_compressible_transformations->module~flow program~flow_test_conservative_compressible_sub flow_test_conservative_compressible_sub module~flow->program~flow_test_conservative_compressible_sub program~flow_test_eos_compressible flow_test_eos_compressible module~flow->program~flow_test_eos_compressible program~flow_test_primitive_compressible_add flow_test_primitive_compressible_add module~flow->program~flow_test_primitive_compressible_add program~flow_test_primitive_compressible_assign flow_test_primitive_compressible_assign module~flow->program~flow_test_primitive_compressible_assign program~flow_test_primitive_compressible_div flow_test_primitive_compressible_div module~flow->program~flow_test_primitive_compressible_div program~flow_test_primitive_compressible_eq flow_test_primitive_compressible_eq module~flow->program~flow_test_primitive_compressible_eq program~flow_test_primitive_compressible_mul flow_test_primitive_compressible_mul module~flow->program~flow_test_primitive_compressible_mul program~flow_test_primitive_compressible_multispecie_add flow_test_primitive_compressible_multispecie_add module~flow->program~flow_test_primitive_compressible_multispecie_add program~flow_test_primitive_compressible_multispecie_assign flow_test_primitive_compressible_multispecie_assign module~flow->program~flow_test_primitive_compressible_multispecie_assign program~flow_test_primitive_compressible_multispecie_div flow_test_primitive_compressible_multispecie_div module~flow->program~flow_test_primitive_compressible_multispecie_div program~flow_test_primitive_compressible_multispecie_eq flow_test_primitive_compressible_multispecie_eq module~flow->program~flow_test_primitive_compressible_multispecie_eq program~flow_test_primitive_compressible_multispecie_mul flow_test_primitive_compressible_multispecie_mul module~flow->program~flow_test_primitive_compressible_multispecie_mul program~flow_test_primitive_compressible_multispecie_not_eq flow_test_primitive_compressible_multispecie_not_eq module~flow->program~flow_test_primitive_compressible_multispecie_not_eq program~flow_test_primitive_compressible_multispecie_add~2 flow_test_primitive_compressible_multispecie_add module~flow->program~flow_test_primitive_compressible_multispecie_add~2 program~flow_test_primitive_compressible_multispecie_sub flow_test_primitive_compressible_multispecie_sub module~flow->program~flow_test_primitive_compressible_multispecie_sub program~flow_test_primitive_compressible_not_eq flow_test_primitive_compressible_not_eq module~flow->program~flow_test_primitive_compressible_not_eq program~flow_test_primitive_compressible_add~2 flow_test_primitive_compressible_add module~flow->program~flow_test_primitive_compressible_add~2 program~flow_test_primitive_compressible_sub flow_test_primitive_compressible_sub module~flow->program~flow_test_primitive_compressible_sub program~flow_test_compressible_transformations flow_test_compressible_transformations module~flow->program~flow_test_compressible_transformations program~flow_test_conservative_compressible_add flow_test_conservative_compressible_add module~flow->program~flow_test_conservative_compressible_add program~flow_test_conservative_compressible_assign flow_test_conservative_compressible_assign module~flow->program~flow_test_conservative_compressible_assign program~flow_test_conservative_compressible_div flow_test_conservative_compressible_div module~flow->program~flow_test_conservative_compressible_div program~flow_test_conservative_compressible_eq flow_test_conservative_compressible_eq module~flow->program~flow_test_conservative_compressible_eq program~flow_test_conservative_compressible_mul flow_test_conservative_compressible_mul module~flow->program~flow_test_conservative_compressible_mul program~flow_test_conservative_compressible_not_eq flow_test_conservative_compressible_not_eq module~flow->program~flow_test_conservative_compressible_not_eq program~flow_test_conservative_compressible_add~2 flow_test_conservative_compressible_add module~flow->program~flow_test_conservative_compressible_add~2 var panmoduleflow_primitive_compressibleUsedByGraph = svgPanZoom('#moduleflow_primitive_compressibleUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Interfaces primitive_compressible Derived Types primitive_compressible Functions add array description div div_integer div_real energy eq integer_mul left_eigenvectors momentum mul mul_integer mul_real negative not_eq positive pow_integer pow_real primitive_compressible_instance primitive_compressible_pointer real_mul right_eigenvectors sub Subroutines assign_field assign_real destroy initialize Interfaces public interface primitive_compressible Overload primitive_compressible name with its constructor. private pure function primitive_compressible_instance (density, velocity, pressure) result(instance) Return and instance of primitive_compressible . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in), optional :: density Density field. type(vector), intent(in), optional :: velocity Velocity field. real(kind=R8P), intent(in), optional :: pressure Pressure field. Return Value type( primitive_compressible ) Instance of primitive_compressible . Derived Types type, public, extends( primitive_object ) :: primitive_compressible Primitive compressible multispecie object. Components Type Visibility Attributes Name Initial real(kind=R8P), public :: density = 0._R8P Density, rho . real(kind=R8P), public :: pressure = 0._R8P Pressure, p . type(vector), public :: velocity Velocity, v . Constructor Overload primitive_compressible name with its constructor. private pure function primitive_compressible_instance (density, velocity, pressure) Return and instance of primitive_compressible . Type-Bound Procedures procedure, public, pass(lhs) :: add Operator + . procedure, public, pass(self) :: array Return serialized array of field. procedure, public, pass(lhs) :: assign_field Operator = . procedure, public, pass(lhs) :: assign_real Operator field = real . generic, public :: assignment(=) => assign_field, assign_real Assignment overloading. procedure, public, pass(self) :: description Return pretty-printed object description. procedure, public, pass(self) :: destroy Destroy primitive. procedure, public, pass(lhs) :: div Operator / . procedure, public, pass(lhs) :: div_integer Operator field / integer . procedure, public, pass(lhs) :: div_real Operator field / real . procedure, public, pass(self) :: energy Return energy value. procedure, public, pass(lhs) :: eq Operator `=='. procedure, public, pass(self) :: initialize Initialize primitive. procedure, public, pass(rhs) :: integer_mul Operator integer * field . procedure, public, pass(self) :: left_eigenvectors Return the left eigenvectors matrix L as dF/dP = A = R &#94; L . procedure, public, pass(self) :: momentum Return momentum vector. procedure, public, pass(lhs) :: mul Operator * . procedure, public, pass(lhs) :: mul_integer Operator field * integer . procedure, public, pass(lhs) :: mul_real Operator field * real . procedure, public, pass(self) :: negative Unary operator - field . procedure, public, pass(lhs) :: not_eq Operator `/='. generic, public :: operator(*) => mul, mul_integer, integer_mul, real_mul, mul_real Operator * overloading. generic, public :: operator(**) => pow_integer, pow_real Operator ** overloading. generic, public :: operator(+) => add, positive Operator + overloading. generic, public :: operator(-) => sub, negative Operator - overloading. generic, public :: operator(/) => div, div_integer, div_real Operator / overloading. generic, public :: operator(/=) => not_eq Operator /= overloading. generic, public :: operator(==) => eq Operator /= overloading. procedure, public, pass(self) :: positive Unary operator + field . procedure, public, pass(lhs) :: pow_integer Operator field ** integer . procedure, public, pass(lhs) :: pow_real Operator field ** real . procedure, public, pass(rhs) :: real_mul Operator real * field . procedure, public, pass(self) :: right_eigenvectors Return the right eigenvectors matrix R as dF/dP = A = R &#94; L . procedure, public, pass(lhs) :: sub Operator - . Functions private elemental function add (lhs, rhs) result(opr) Operator + . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private pure function array (self) result(array_) Return serialized array of field. Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. Return Value real(kind=R8P),\n  allocatable, (:) Serialized array of field. private pure function description (self, prefix) result(desc) Return a pretty-formatted object description. Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. private elemental function div (lhs, rhs) result(opr) Operator / . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function div_integer (lhs, rhs) result(opr) Operator field / integer . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function div_real (lhs, rhs) result(opr) Operator field / real . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function energy (self, eos) result(energy_) Return energy value. Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. class( eos_object ), intent(in) :: eos Equation of state. Return Value real(kind=R8P) Energy value. private elemental function eq (lhs, rhs) result(opr) Operator `=='. Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. private elemental function integer_mul (lhs, rhs) result(opr) Operator integer * field . Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: lhs Left hand side. class( primitive_compressible ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private pure function left_eigenvectors (self, eos) result(eig) Return the left eigenvectors matrix L as dF/dP = A = R &#94; L . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. class( eos_object ), intent(in) :: eos Equation of state. Return Value real(kind=R8P)\n  (1:3,1:3) Eigenvectors. private elemental function momentum (self) result(momentum_) Return momentum vector. Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. Return Value type(vector) Momentum vector. private elemental function mul (lhs, rhs) result(opr) Operator * . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function mul_integer (lhs, rhs) result(opr) Operator field * integer . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function mul_real (lhs, rhs) result(opr) Operator field * real . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private function negative (self) result(opr) Unary operator - field . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. Return Value class( field_object ),\n  allocatable Operator result. private elemental function not_eq (lhs, rhs) result(opr) Operator `/='. Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. private function positive (self) result(opr) Unary operator + field . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. Return Value class( field_object ),\n  allocatable Operator result. private elemental function pow_integer (lhs, rhs) result(opr) Operator field ** integer . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function pow_real (lhs, rhs) result(opr) Operator field ** real . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private pure function primitive_compressible_instance (density, velocity, pressure) result(instance) Return and instance of primitive_compressible . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in), optional :: density Density field. type(vector), intent(in), optional :: velocity Velocity field. real(kind=R8P), intent(in), optional :: pressure Pressure field. Return Value type( primitive_compressible ) Instance of primitive_compressible . public function primitive_compressible_pointer (to, error_message) result(pointer_) Return primitive_compressible pointer associated to primitive_object or its extensions until primitive_compressible included. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in), target :: to Target of associate. character(len=*), intent(in), optional :: error_message Auxiliary error message. Return Value class( primitive_compressible ),\n  pointer Associated pointer. private elemental function real_mul (lhs, rhs) result(opr) Operator real * field . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs Left hand side. class( primitive_compressible ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private pure function right_eigenvectors (self, eos) result(eig) Return the right eigenvectors matrix R as dF/dP = A = R &#94; L . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: self Primitive. class( eos_object ), intent(in) :: eos Equation of state. Return Value real(kind=R8P)\n  (1:3,1:3) Eigenvectors. private elemental function sub (lhs, rhs) result(opr) Operator - . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Subroutines private elemental subroutine assign_field (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(inout) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. private elemental subroutine assign_real (lhs, rhs) Operator field = real . Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(inout) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. private elemental subroutine destroy (self) Destroy primitive. Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(inout) :: self Primitive. private subroutine initialize (self, initial_state) Initialize primitive. Arguments Type Intent Optional Attributes Name class( primitive_compressible ), intent(inout) :: self Primitive. class( primitive_object ), intent(in), optional :: initial_state Initial state.","tags":"","loc":"module/flow_primitive_compressible.html","title":"flow_primitive_compressible – FLOw"},{"text":"Uses: flow_eos_object flow_field_object flow_primitive_object penf VecFor module~~flow_primitive_compressible_multispecie~~UsesGraph module~flow_primitive_compressible_multispecie flow_primitive_compressible_multispecie module~penf penf module~penf->module~flow_primitive_compressible_multispecie module~flow_eos_object flow_eos_object module~penf->module~flow_eos_object module~flow_primitive_object flow_primitive_object module~penf->module~flow_primitive_object module~flow_field_object flow_field_object module~penf->module~flow_field_object module~vecfor VecFor module~vecfor->module~flow_primitive_compressible_multispecie module~vecfor->module~flow_primitive_object module~flow_eos_object->module~flow_primitive_compressible_multispecie module~flow_eos_object->module~flow_primitive_object module~flow_primitive_object->module~flow_primitive_compressible_multispecie module~flow_field_object->module~flow_primitive_compressible_multispecie module~flow_field_object->module~flow_primitive_object module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_stringify penf_stringify module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~vecfor iso_fortran_env->module~penf_stringify var panmoduleflow_primitive_compressible_multispecieUsesGraph = svgPanZoom('#moduleflow_primitive_compressible_multispecieUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FLOw primitive compressible mutlispecie object. primitive_compressible_multispecie is a class that handles compressible multispecie primitive fluid dynamic variables. Used By module~~flow_primitive_compressible_multispecie~~UsedByGraph module~flow_primitive_compressible_multispecie flow_primitive_compressible_multispecie module~flow flow module~flow_primitive_compressible_multispecie->module~flow program~flow_test_conservative_compressible_sub flow_test_conservative_compressible_sub module~flow->program~flow_test_conservative_compressible_sub program~flow_test_eos_compressible flow_test_eos_compressible module~flow->program~flow_test_eos_compressible program~flow_test_primitive_compressible_add flow_test_primitive_compressible_add module~flow->program~flow_test_primitive_compressible_add program~flow_test_primitive_compressible_assign flow_test_primitive_compressible_assign module~flow->program~flow_test_primitive_compressible_assign program~flow_test_primitive_compressible_div flow_test_primitive_compressible_div module~flow->program~flow_test_primitive_compressible_div program~flow_test_primitive_compressible_eq flow_test_primitive_compressible_eq module~flow->program~flow_test_primitive_compressible_eq program~flow_test_primitive_compressible_mul flow_test_primitive_compressible_mul module~flow->program~flow_test_primitive_compressible_mul program~flow_test_primitive_compressible_multispecie_add flow_test_primitive_compressible_multispecie_add module~flow->program~flow_test_primitive_compressible_multispecie_add program~flow_test_primitive_compressible_multispecie_assign flow_test_primitive_compressible_multispecie_assign module~flow->program~flow_test_primitive_compressible_multispecie_assign program~flow_test_primitive_compressible_multispecie_div flow_test_primitive_compressible_multispecie_div module~flow->program~flow_test_primitive_compressible_multispecie_div program~flow_test_primitive_compressible_multispecie_eq flow_test_primitive_compressible_multispecie_eq module~flow->program~flow_test_primitive_compressible_multispecie_eq program~flow_test_primitive_compressible_multispecie_mul flow_test_primitive_compressible_multispecie_mul module~flow->program~flow_test_primitive_compressible_multispecie_mul program~flow_test_primitive_compressible_multispecie_not_eq flow_test_primitive_compressible_multispecie_not_eq module~flow->program~flow_test_primitive_compressible_multispecie_not_eq program~flow_test_primitive_compressible_multispecie_add~2 flow_test_primitive_compressible_multispecie_add module~flow->program~flow_test_primitive_compressible_multispecie_add~2 program~flow_test_primitive_compressible_multispecie_sub flow_test_primitive_compressible_multispecie_sub module~flow->program~flow_test_primitive_compressible_multispecie_sub program~flow_test_primitive_compressible_not_eq flow_test_primitive_compressible_not_eq module~flow->program~flow_test_primitive_compressible_not_eq program~flow_test_primitive_compressible_add~2 flow_test_primitive_compressible_add module~flow->program~flow_test_primitive_compressible_add~2 program~flow_test_primitive_compressible_sub flow_test_primitive_compressible_sub module~flow->program~flow_test_primitive_compressible_sub program~flow_test_compressible_transformations flow_test_compressible_transformations module~flow->program~flow_test_compressible_transformations program~flow_test_conservative_compressible_add flow_test_conservative_compressible_add module~flow->program~flow_test_conservative_compressible_add program~flow_test_conservative_compressible_assign flow_test_conservative_compressible_assign module~flow->program~flow_test_conservative_compressible_assign program~flow_test_conservative_compressible_div flow_test_conservative_compressible_div module~flow->program~flow_test_conservative_compressible_div program~flow_test_conservative_compressible_eq flow_test_conservative_compressible_eq module~flow->program~flow_test_conservative_compressible_eq program~flow_test_conservative_compressible_mul flow_test_conservative_compressible_mul module~flow->program~flow_test_conservative_compressible_mul program~flow_test_conservative_compressible_not_eq flow_test_conservative_compressible_not_eq module~flow->program~flow_test_conservative_compressible_not_eq program~flow_test_conservative_compressible_add~2 flow_test_conservative_compressible_add module~flow->program~flow_test_conservative_compressible_add~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Interfaces primitive_compressible_multispecie Derived Types primitive_compressible_multispecie Functions add array compatible description div div_integer div_real energy eq integer_mul momentum mul mul_integer mul_real negative not_eq positive pow_integer pow_real primitive_compressible_multispecie_instance real_mul sub Subroutines assign_field assign_real destroy initialize Interfaces public interface primitive_compressible_multispecie Overload primitive_compressible_multispecie name with its constructor. private pure function primitive_compressible_multispecie_instance (density, velocity, pressure, partial_densities) result(instance) Return and instance of primitive_compressible_multispecie . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in), optional :: density Density field. type(vector), intent(in), optional :: velocity Velocity field. real(kind=R8P), intent(in), optional :: pressure Pressure field. real(kind=R8P), intent(in), optional :: partial_densities (:) Partial densities field. Return Value type( primitive_compressible_multispecie ) Instance of primitive_compressible_multispecie . Derived Types type, public, extends( primitive_object ) :: primitive_compressible_multispecie Primitive compressible multispecie object. Components Type Visibility Attributes Name Initial real(kind=R8P), public :: density = 0._R8P Density, rho . real(kind=R8P), public, allocatable :: partial_densities (:) Partial densities rho(s), rho = sum(rho(s)) . real(kind=R8P), public :: pressure = 0._R8P Pressure, p . type(vector), public :: velocity Velocity, v . Constructor Overload primitive_compressible_multispecie name with its constructor. private pure function primitive_compressible_multispecie_instance (density, velocity, pressure, partial_densities) Return and instance of primitive_compressible_multispecie . Type-Bound Procedures procedure, public, pass(lhs) :: add Operator + . procedure, public, pass(self) :: array Return serialized array of field. procedure, public, pass(lhs) :: assign_field Operator = . procedure, public, pass(lhs) :: assign_real Operator field = real . generic, public :: assignment(=) => assign_field, assign_real Assignment overloading. procedure, public, pass(lhs) :: compatible Operator .compatible. . procedure, public, pass(self) :: description Return pretty-printed object description. procedure, public, pass(self) :: destroy Destroy primitive. procedure, public, pass(lhs) :: div Operator / . procedure, public, pass(lhs) :: div_integer Operator field / integer . procedure, public, pass(lhs) :: div_real Operator field / real . procedure, public, pass(self) :: energy Return energy value. procedure, public, pass(lhs) :: eq Operator `=='. procedure, public, pass(self) :: initialize Initialize primitive. procedure, public, pass(rhs) :: integer_mul Operator integer * field . procedure, public, pass(self) :: momentum Return momentum vector. procedure, public, pass(lhs) :: mul Operator * . procedure, public, pass(lhs) :: mul_integer Operator field * integer . procedure, public, pass(lhs) :: mul_real Operator field * real . procedure, public, pass(self) :: negative Unary operator - field . procedure, public, pass(lhs) :: not_eq Operator `/='. generic, public :: operator(*) => mul, mul_integer, integer_mul, real_mul, mul_real Operator * overloading. generic, public :: operator(**) => pow_integer, pow_real Operator ** overloading. generic, public :: operator(+) => add, positive Operator + overloading. generic, public :: operator(-) => sub, negative Operator - overloading. generic, public :: operator(.compatible.) => compatible Operator .compatible. overloading. generic, public :: operator(/) => div, div_integer, div_real Operator / overloading. generic, public :: operator(/=) => not_eq Operator /= overloading. generic, public :: operator(==) => eq Operator /= overloading. procedure, public, pass(self) :: positive Unary operator + field . procedure, public, pass(lhs) :: pow_integer Operator field ** integer . procedure, public, pass(lhs) :: pow_real Operator field ** real . procedure, public, pass(rhs) :: real_mul Operator real * field . procedure, public, pass(lhs) :: sub Operator - . Functions private elemental function add (lhs, rhs) result(opr) Operator + . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private pure function array (self) result(array_) Return serialized array of field. Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: self Primitive. Return Value real(kind=R8P),\n  allocatable, (:) Serialized array of field. private elemental function compatible (lhs, rhs) result(opr) Operator .compatible. . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. type( primitive_compressible_multispecie ), intent(in) :: rhs Right hand side. Return Value logical Operator result. private pure function description (self, prefix) result(desc) Return a pretty-formatted object description. Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: self Primitive. character(len=*), intent(in), optional :: prefix Prefixing string. Return Value character(len=:),\n  allocatable Description. private elemental function div (lhs, rhs) result(opr) Operator / . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function div_integer (lhs, rhs) result(opr) Operator field / integer . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function div_real (lhs, rhs) result(opr) Operator field / real . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function energy (self, eos) result(energy_) Return energy value. Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: self Primitive. class( eos_object ), intent(in) :: eos Equation of state. Return Value real(kind=R8P) Energy value. private elemental function eq (lhs, rhs) result(opr) Operator `=='. Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. private elemental function integer_mul (lhs, rhs) result(opr) Operator integer * field . Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: lhs Left hand side. class( primitive_compressible_multispecie ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function momentum (self) result(momentum_) Return momentum vector. Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: self Primitive. Return Value type(vector) Momentum vector. private elemental function mul (lhs, rhs) result(opr) Operator * . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function mul_integer (lhs, rhs) result(opr) Operator field * integer . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function mul_real (lhs, rhs) result(opr) Operator field * real . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private function negative (self) result(operator_result) Unary operator - field . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: self Primitive. Return Value class( field_object ),\n  allocatable Operator result. private elemental function not_eq (lhs, rhs) result(opr) Operator `/='. Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value logical Operator result. private function positive (self) result(opr) Unary operator + field . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: self Primitive. Return Value class( field_object ),\n  allocatable Operator result. private elemental function pow_integer (lhs, rhs) result(opr) Operator field ** integer . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. integer(kind=I4P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function pow_real (lhs, rhs) result(opr) Operator field ** real . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private pure function primitive_compressible_multispecie_instance (density, velocity, pressure, partial_densities) result(instance) Return and instance of primitive_compressible_multispecie . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in), optional :: density Density field. type(vector), intent(in), optional :: velocity Velocity field. real(kind=R8P), intent(in), optional :: pressure Pressure field. real(kind=R8P), intent(in), optional :: partial_densities (:) Partial densities field. Return Value type( primitive_compressible_multispecie ) Instance of primitive_compressible_multispecie . private elemental function real_mul (lhs, rhs) result(opr) Operator real * field . Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: lhs Left hand side. class( primitive_compressible_multispecie ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. private elemental function sub (lhs, rhs) result(opr) Operator - . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(in) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. Return Value class( field_object ),\n  allocatable Operator result. Subroutines private elemental subroutine assign_field (lhs, rhs) Operator = . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(inout) :: lhs Left hand side. class( field_object ), intent(in) :: rhs Right hand side. private elemental subroutine assign_real (lhs, rhs) Operator field = real . Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(inout) :: lhs Left hand side. real(kind=R8P), intent(in) :: rhs Right hand side. private elemental subroutine destroy (self) Destroy primitive. Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(inout) :: self Primitive. private subroutine initialize (self, initial_state) Initialize primitive. Arguments Type Intent Optional Attributes Name class( primitive_compressible_multispecie ), intent(inout) :: self Primitive. class( primitive_object ), intent(in), optional :: initial_state Initial state.","tags":"","loc":"module/flow_primitive_compressible_multispecie.html","title":"flow_primitive_compressible_multispecie – FLOw"},{"text":"Uses: flow_eos_object flow_field_object penf VecFor module~~flow_primitive_object~~UsesGraph module~flow_primitive_object flow_primitive_object module~penf penf module~penf->module~flow_primitive_object module~flow_eos_object flow_eos_object module~penf->module~flow_eos_object module~flow_field_object flow_field_object module~penf->module~flow_field_object module~flow_eos_object->module~flow_primitive_object module~vecfor VecFor module~vecfor->module~flow_primitive_object module~flow_field_object->module~flow_primitive_object module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_stringify penf_stringify module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~vecfor iso_fortran_env->module~penf_stringify var panmoduleflow_primitive_objectUsesGraph = svgPanZoom('#moduleflow_primitive_objectUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FLOw primitive abstract object. primitive_object is a class that handles primitive fluid dynamic variables. Used By module~~flow_primitive_object~~UsedByGraph module~flow_primitive_object flow_primitive_object module~flow_primitive_compressible_multispecie flow_primitive_compressible_multispecie module~flow_primitive_object->module~flow_primitive_compressible_multispecie module~flow_primitive_compressible flow_primitive_compressible module~flow_primitive_object->module~flow_primitive_compressible module~flow flow module~flow_primitive_object->module~flow module~flow_primitive_compressible_multispecie->module~flow module~flow_primitive_compressible->module~flow module~flow_compressible_transformations flow_compressible_transformations module~flow_primitive_compressible->module~flow_compressible_transformations program~flow_test_conservative_compressible_sub flow_test_conservative_compressible_sub module~flow->program~flow_test_conservative_compressible_sub program~flow_test_eos_compressible flow_test_eos_compressible module~flow->program~flow_test_eos_compressible program~flow_test_primitive_compressible_add flow_test_primitive_compressible_add module~flow->program~flow_test_primitive_compressible_add program~flow_test_primitive_compressible_assign flow_test_primitive_compressible_assign module~flow->program~flow_test_primitive_compressible_assign program~flow_test_primitive_compressible_div flow_test_primitive_compressible_div module~flow->program~flow_test_primitive_compressible_div program~flow_test_primitive_compressible_eq flow_test_primitive_compressible_eq module~flow->program~flow_test_primitive_compressible_eq program~flow_test_primitive_compressible_mul flow_test_primitive_compressible_mul module~flow->program~flow_test_primitive_compressible_mul program~flow_test_primitive_compressible_multispecie_add flow_test_primitive_compressible_multispecie_add module~flow->program~flow_test_primitive_compressible_multispecie_add program~flow_test_primitive_compressible_multispecie_assign flow_test_primitive_compressible_multispecie_assign module~flow->program~flow_test_primitive_compressible_multispecie_assign program~flow_test_primitive_compressible_multispecie_div flow_test_primitive_compressible_multispecie_div module~flow->program~flow_test_primitive_compressible_multispecie_div program~flow_test_primitive_compressible_multispecie_eq flow_test_primitive_compressible_multispecie_eq module~flow->program~flow_test_primitive_compressible_multispecie_eq program~flow_test_primitive_compressible_multispecie_mul flow_test_primitive_compressible_multispecie_mul module~flow->program~flow_test_primitive_compressible_multispecie_mul program~flow_test_primitive_compressible_multispecie_not_eq flow_test_primitive_compressible_multispecie_not_eq module~flow->program~flow_test_primitive_compressible_multispecie_not_eq program~flow_test_primitive_compressible_multispecie_add~2 flow_test_primitive_compressible_multispecie_add module~flow->program~flow_test_primitive_compressible_multispecie_add~2 program~flow_test_primitive_compressible_multispecie_sub flow_test_primitive_compressible_multispecie_sub module~flow->program~flow_test_primitive_compressible_multispecie_sub program~flow_test_primitive_compressible_not_eq flow_test_primitive_compressible_not_eq module~flow->program~flow_test_primitive_compressible_not_eq program~flow_test_primitive_compressible_add~2 flow_test_primitive_compressible_add module~flow->program~flow_test_primitive_compressible_add~2 program~flow_test_primitive_compressible_sub flow_test_primitive_compressible_sub module~flow->program~flow_test_primitive_compressible_sub program~flow_test_compressible_transformations flow_test_compressible_transformations module~flow->program~flow_test_compressible_transformations program~flow_test_conservative_compressible_add flow_test_conservative_compressible_add module~flow->program~flow_test_conservative_compressible_add program~flow_test_conservative_compressible_assign flow_test_conservative_compressible_assign module~flow->program~flow_test_conservative_compressible_assign program~flow_test_conservative_compressible_div flow_test_conservative_compressible_div module~flow->program~flow_test_conservative_compressible_div program~flow_test_conservative_compressible_eq flow_test_conservative_compressible_eq module~flow->program~flow_test_conservative_compressible_eq program~flow_test_conservative_compressible_mul flow_test_conservative_compressible_mul module~flow->program~flow_test_conservative_compressible_mul program~flow_test_conservative_compressible_not_eq flow_test_conservative_compressible_not_eq module~flow->program~flow_test_conservative_compressible_not_eq program~flow_test_conservative_compressible_add~2 flow_test_conservative_compressible_add module~flow->program~flow_test_conservative_compressible_add~2 module~flow_compressible_transformations->module~flow var panmoduleflow_primitive_objectUsedByGraph = svgPanZoom('#moduleflow_primitive_objectUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Abstract Interfaces destroy_interface energy_interface initialize_interface momentum_interface Derived Types primitive_object Abstract Interfaces abstract interface Abstract interfaces of deferred methods of primitive_object . private elemental subroutine destroy_interface (self) Destroy primitive. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(inout) :: self Primitive. abstract interface Abstract interfaces of deferred methods of primitive_object . private elemental function energy_interface (self, eos) result(energy_) Return energy value. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: self Primitive. class( eos_object ), intent(in) :: eos Equation of state. Return Value real(kind=R8P) Energy value. abstract interface Abstract interfaces of deferred methods of primitive_object . private subroutine initialize_interface (self, initial_state) Initialize primitive. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(inout) :: self Primitive. class( primitive_object ), intent(in), optional :: initial_state Initial state. abstract interface Abstract interfaces of deferred methods of primitive_object . private elemental function momentum_interface (self) result(momentum_) Return momentum vector. Arguments Type Intent Optional Attributes Name class( primitive_object ), intent(in) :: self Primitive. Return Value type(vector) Momentum vector. Derived Types type, public, abstract, extends( field_object ) :: primitive_object Primitive object. Type-Bound Procedures procedure(symmetric_op_interface), public, pass(lhs) :: add Operator + . procedure(array_interface), public, pass(self) :: array Return serialized array of field. procedure(assign_interface), public, pass(lhs) :: assign_field Operator = . procedure(assign_real_interface), public, pass(lhs) :: assign_real Operator field = real . generic, public :: assignment(=) => assign_field, assign_real Assignment overloading. procedure(description_interface), public, pass(self) :: description Return pretty-printed object description. procedure(destroy_interface), public, pass(self) :: destroy Destroy primitive. procedure(symmetric_op_interface), public, pass(lhs) :: div Operator / . procedure(field_op_integer_interface), public, pass(lhs) :: div_integer Operator field / integer . procedure(field_op_real_interface), public, pass(lhs) :: div_real Operator field / real . procedure(energy_interface), public, pass(self) :: energy Return energy value. procedure(compare_interface), public, pass(lhs) :: eq Operator `=='. procedure(initialize_interface), public, pass(self) :: initialize Initialize primitive. procedure(integer_op_field_interface), public, pass(rhs) :: integer_mul Operator integer * field . procedure(momentum_interface), public, pass(self) :: momentum Return momentum vector. procedure(symmetric_op_interface), public, pass(lhs) :: mul Operator * . procedure(field_op_integer_interface), public, pass(lhs) :: mul_integer Operator field * integer . procedure(field_op_real_interface), public, pass(lhs) :: mul_real Operator field * real . procedure(unary_operator), public, pass(self) :: negative Unary operator - field . procedure(compare_interface), public, pass(lhs) :: not_eq Operator `/='. generic, public :: operator(*) => mul, mul_integer, integer_mul, real_mul, mul_real Operator * overloading. generic, public :: operator(**) => pow_integer, pow_real Operator ** overloading. generic, public :: operator(+) => add, positive Operator + overloading. generic, public :: operator(-) => sub, negative Operator - overloading. generic, public :: operator(/) => div, div_integer, div_real Operator / overloading. generic, public :: operator(/=) => not_eq Operator /= overloading. generic, public :: operator(==) => eq Operator /= overloading. procedure(unary_operator), public, pass(self) :: positive Unary operator + field . procedure(field_op_integer_interface), public, pass(lhs) :: pow_integer Operator field ** integer . procedure(field_op_real_interface), public, pass(lhs) :: pow_real Operator field ** real . procedure(real_op_field_interface), public, pass(rhs) :: real_mul Operator real * field . procedure(symmetric_op_interface), public, pass(lhs) :: sub Operator - .","tags":"","loc":"module/flow_primitive_object.html","title":"flow_primitive_object – FLOw"},{"text":"Uses: penf_global_parameters_variables penf_b_size penf_stringify module~~penf~~UsesGraph module~penf penf module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_stringify penf_stringify module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Portability Environment for Fortran poor people. Used By module~~penf~~UsedByGraph module~penf penf program~flow_test_conservative_compressible_sub flow_test_conservative_compressible_sub module~penf->program~flow_test_conservative_compressible_sub program~flow_test_eos_compressible flow_test_eos_compressible module~penf->program~flow_test_eos_compressible program~flow_test_primitive_compressible_add flow_test_primitive_compressible_add module~penf->program~flow_test_primitive_compressible_add program~flow_test_primitive_compressible_multispecie_eq flow_test_primitive_compressible_multispecie_eq module~penf->program~flow_test_primitive_compressible_multispecie_eq program~flow_test_primitive_compressible_assign flow_test_primitive_compressible_assign module~penf->program~flow_test_primitive_compressible_assign module~flow_eos_compressible flow_eos_compressible module~penf->module~flow_eos_compressible program~flow_test_primitive_compressible_eq flow_test_primitive_compressible_eq module~penf->program~flow_test_primitive_compressible_eq module~flow_conservative_compressible flow_conservative_compressible module~penf->module~flow_conservative_compressible module~flow_primitive_compressible flow_primitive_compressible module~penf->module~flow_primitive_compressible program~flow_test_primitive_compressible_multispecie_add flow_test_primitive_compressible_multispecie_add module~penf->program~flow_test_primitive_compressible_multispecie_add module~flow_eos_object flow_eos_object module~penf->module~flow_eos_object program~flow_test_primitive_compressible_multispecie_div flow_test_primitive_compressible_multispecie_div module~penf->program~flow_test_primitive_compressible_multispecie_div module~flow_field_object flow_field_object module~penf->module~flow_field_object program~flow_test_primitive_compressible_mul flow_test_primitive_compressible_mul module~penf->program~flow_test_primitive_compressible_mul program~flow_test_primitive_compressible_multispecie_mul flow_test_primitive_compressible_multispecie_mul module~penf->program~flow_test_primitive_compressible_multispecie_mul program~flow_test_primitive_compressible_multispecie_not_eq flow_test_primitive_compressible_multispecie_not_eq module~penf->program~flow_test_primitive_compressible_multispecie_not_eq program~flow_test_primitive_compressible_multispecie_add~2 flow_test_primitive_compressible_multispecie_add module~penf->program~flow_test_primitive_compressible_multispecie_add~2 program~flow_test_primitive_compressible_multispecie_sub flow_test_primitive_compressible_multispecie_sub module~penf->program~flow_test_primitive_compressible_multispecie_sub program~flow_test_primitive_compressible_not_eq flow_test_primitive_compressible_not_eq module~penf->program~flow_test_primitive_compressible_not_eq program~flow_test_primitive_compressible_add~2 flow_test_primitive_compressible_add module~penf->program~flow_test_primitive_compressible_add~2 program~flow_test_primitive_compressible_sub flow_test_primitive_compressible_sub module~penf->program~flow_test_primitive_compressible_sub module~flow_conservative_object flow_conservative_object module~penf->module~flow_conservative_object program~flow_test_compressible_transformations flow_test_compressible_transformations module~penf->program~flow_test_compressible_transformations module~flow_field_scalar_vectorial flow_field_scalar_vectorial module~penf->module~flow_field_scalar_vectorial module~flow_primitive_object flow_primitive_object module~penf->module~flow_primitive_object program~flow_test_primitive_compressible_multispecie_assign flow_test_primitive_compressible_multispecie_assign module~penf->program~flow_test_primitive_compressible_multispecie_assign module~flow_primitive_compressible_multispecie flow_primitive_compressible_multispecie module~penf->module~flow_primitive_compressible_multispecie program~flow_test_conservative_compressible_add flow_test_conservative_compressible_add module~penf->program~flow_test_conservative_compressible_add module~flow_compressible_transformations flow_compressible_transformations module~penf->module~flow_compressible_transformations program~flow_test_conservative_compressible_assign flow_test_conservative_compressible_assign module~penf->program~flow_test_conservative_compressible_assign program~flow_test_conservative_compressible_div flow_test_conservative_compressible_div module~penf->program~flow_test_conservative_compressible_div program~flow_test_conservative_compressible_eq flow_test_conservative_compressible_eq module~penf->program~flow_test_conservative_compressible_eq program~flow_test_conservative_compressible_mul flow_test_conservative_compressible_mul module~penf->program~flow_test_conservative_compressible_mul program~flow_test_conservative_compressible_not_eq flow_test_conservative_compressible_not_eq module~penf->program~flow_test_conservative_compressible_not_eq program~flow_test_conservative_compressible_add~2 flow_test_conservative_compressible_add module~penf->program~flow_test_conservative_compressible_add~2 program~flow_test_primitive_compressible_div flow_test_primitive_compressible_div module~penf->program~flow_test_primitive_compressible_div module~flow flow module~flow_eos_compressible->module~flow module~flow_conservative_compressible->module~flow_compressible_transformations module~flow_conservative_compressible->module~flow module~flow_primitive_compressible->module~flow_compressible_transformations module~flow_primitive_compressible->module~flow module~flow_eos_object->module~flow_eos_compressible module~flow_eos_object->module~flow_conservative_compressible module~flow_eos_object->module~flow_primitive_compressible module~flow_eos_object->module~flow_conservative_object module~flow_eos_object->module~flow_primitive_object module~flow_eos_object->module~flow_primitive_compressible_multispecie module~flow_eos_object->module~flow_compressible_transformations module~flow_eos_object->module~flow module~flow_field_object->module~flow_conservative_compressible module~flow_field_object->module~flow_primitive_compressible module~flow_field_object->module~flow_conservative_object module~flow_field_object->module~flow_field_scalar_vectorial module~flow_field_object->module~flow_primitive_object module~flow_field_object->module~flow_primitive_compressible_multispecie module~flow_field_object->module~flow module~flow_conservative_object->module~flow_conservative_compressible module~flow_conservative_object->module~flow module~flow_field_scalar_vectorial->module~flow module~flow_primitive_object->module~flow_primitive_compressible module~flow_primitive_object->module~flow_primitive_compressible_multispecie module~flow_primitive_object->module~flow module~flow_primitive_compressible_multispecie->module~flow module~flow_compressible_transformations->module~flow module~flow->program~flow_test_conservative_compressible_sub module~flow->program~flow_test_eos_compressible module~flow->program~flow_test_primitive_compressible_add module~flow->program~flow_test_primitive_compressible_multispecie_eq module~flow->program~flow_test_primitive_compressible_assign module~flow->program~flow_test_primitive_compressible_eq module~flow->program~flow_test_primitive_compressible_multispecie_add module~flow->program~flow_test_primitive_compressible_multispecie_div module~flow->program~flow_test_primitive_compressible_mul module~flow->program~flow_test_primitive_compressible_multispecie_mul module~flow->program~flow_test_primitive_compressible_multispecie_not_eq module~flow->program~flow_test_primitive_compressible_multispecie_add~2 module~flow->program~flow_test_primitive_compressible_multispecie_sub module~flow->program~flow_test_primitive_compressible_not_eq module~flow->program~flow_test_primitive_compressible_add~2 module~flow->program~flow_test_primitive_compressible_sub module~flow->program~flow_test_compressible_transformations module~flow->program~flow_test_primitive_compressible_multispecie_assign module~flow->program~flow_test_conservative_compressible_add module~flow->program~flow_test_conservative_compressible_assign module~flow->program~flow_test_conservative_compressible_div module~flow->program~flow_test_conservative_compressible_eq module~flow->program~flow_test_conservative_compressible_mul module~flow->program~flow_test_conservative_compressible_not_eq module~flow->program~flow_test_conservative_compressible_add~2 module~flow->program~flow_test_primitive_compressible_div var panmodulepenfUsedByGraph = svgPanZoom('#modulepenfUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Interfaces bit_size digit Functions digit_I1 digit_I2 digit_I4 digit_I8 Subroutines check_endian penf_init penf_print Interfaces public interface bit_size Overloading of the intrinsic bit_size function for computing the number of bits of (also) real and character variables. public interface digit Compute the number of digits in decimal base of the input integer. private elemental function digit_I8 (n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. private elemental function digit_I4 (n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. private elemental function digit_I2 (n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. private elemental function digit_I1 (n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Functions private elemental function digit_I1 (n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. private elemental function digit_I2 (n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. private elemental function digit_I4 (n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. private elemental function digit_I8 (n) result(digit) Compute the number of digits in decimal base of the input integer. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Input integer. Return Value integer(kind=I4P) Number of digits. Subroutines public subroutine check_endian () Check the type of bit ordering (big or little endian) of the running architecture. Arguments None public subroutine penf_init () Initialize PENF's variables that are not initialized into the definition specification. Arguments None public subroutine penf_print (unit, pref, iostat, iomsg) Print to the specified unit the PENF's environment data. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: unit Logic unit. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message.","tags":"","loc":"module/penf.html","title":"penf – FLOw"},{"text":"Uses: penf_global_parameters_variables module~~penf_b_size~~UsesGraph module~penf_b_size penf_b_size module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf_b_size Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. PENF bit/byte size functions. Used By module~~penf_b_size~~UsedByGraph module~penf_b_size penf_b_size module~penf penf module~penf_b_size->module~penf module~penf_stringify penf_stringify module~penf_b_size->module~penf_stringify program~flow_test_conservative_compressible_sub flow_test_conservative_compressible_sub module~penf->program~flow_test_conservative_compressible_sub program~flow_test_eos_compressible flow_test_eos_compressible module~penf->program~flow_test_eos_compressible program~flow_test_primitive_compressible_add flow_test_primitive_compressible_add module~penf->program~flow_test_primitive_compressible_add program~flow_test_primitive_compressible_multispecie_eq flow_test_primitive_compressible_multispecie_eq module~penf->program~flow_test_primitive_compressible_multispecie_eq program~flow_test_primitive_compressible_assign flow_test_primitive_compressible_assign module~penf->program~flow_test_primitive_compressible_assign module~flow_eos_compressible flow_eos_compressible module~penf->module~flow_eos_compressible program~flow_test_primitive_compressible_eq flow_test_primitive_compressible_eq module~penf->program~flow_test_primitive_compressible_eq module~flow_conservative_compressible flow_conservative_compressible module~penf->module~flow_conservative_compressible module~flow_primitive_compressible flow_primitive_compressible module~penf->module~flow_primitive_compressible program~flow_test_primitive_compressible_multispecie_add flow_test_primitive_compressible_multispecie_add module~penf->program~flow_test_primitive_compressible_multispecie_add module~flow_eos_object flow_eos_object module~penf->module~flow_eos_object program~flow_test_primitive_compressible_multispecie_div flow_test_primitive_compressible_multispecie_div module~penf->program~flow_test_primitive_compressible_multispecie_div module~flow_field_object flow_field_object module~penf->module~flow_field_object program~flow_test_primitive_compressible_mul flow_test_primitive_compressible_mul module~penf->program~flow_test_primitive_compressible_mul program~flow_test_primitive_compressible_multispecie_mul flow_test_primitive_compressible_multispecie_mul module~penf->program~flow_test_primitive_compressible_multispecie_mul program~flow_test_primitive_compressible_multispecie_not_eq flow_test_primitive_compressible_multispecie_not_eq module~penf->program~flow_test_primitive_compressible_multispecie_not_eq program~flow_test_primitive_compressible_multispecie_add~2 flow_test_primitive_compressible_multispecie_add module~penf->program~flow_test_primitive_compressible_multispecie_add~2 program~flow_test_primitive_compressible_multispecie_sub flow_test_primitive_compressible_multispecie_sub module~penf->program~flow_test_primitive_compressible_multispecie_sub program~flow_test_primitive_compressible_not_eq flow_test_primitive_compressible_not_eq module~penf->program~flow_test_primitive_compressible_not_eq program~flow_test_primitive_compressible_add~2 flow_test_primitive_compressible_add module~penf->program~flow_test_primitive_compressible_add~2 program~flow_test_primitive_compressible_sub flow_test_primitive_compressible_sub module~penf->program~flow_test_primitive_compressible_sub module~flow_conservative_object flow_conservative_object module~penf->module~flow_conservative_object program~flow_test_compressible_transformations flow_test_compressible_transformations module~penf->program~flow_test_compressible_transformations module~flow_field_scalar_vectorial flow_field_scalar_vectorial module~penf->module~flow_field_scalar_vectorial module~flow_primitive_object flow_primitive_object module~penf->module~flow_primitive_object program~flow_test_primitive_compressible_multispecie_assign flow_test_primitive_compressible_multispecie_assign module~penf->program~flow_test_primitive_compressible_multispecie_assign module~flow_primitive_compressible_multispecie flow_primitive_compressible_multispecie module~penf->module~flow_primitive_compressible_multispecie program~flow_test_conservative_compressible_add flow_test_conservative_compressible_add module~penf->program~flow_test_conservative_compressible_add module~flow_compressible_transformations flow_compressible_transformations module~penf->module~flow_compressible_transformations program~flow_test_conservative_compressible_assign flow_test_conservative_compressible_assign module~penf->program~flow_test_conservative_compressible_assign program~flow_test_conservative_compressible_div flow_test_conservative_compressible_div module~penf->program~flow_test_conservative_compressible_div program~flow_test_conservative_compressible_eq flow_test_conservative_compressible_eq module~penf->program~flow_test_conservative_compressible_eq program~flow_test_conservative_compressible_mul flow_test_conservative_compressible_mul module~penf->program~flow_test_conservative_compressible_mul program~flow_test_conservative_compressible_not_eq flow_test_conservative_compressible_not_eq module~penf->program~flow_test_conservative_compressible_not_eq program~flow_test_conservative_compressible_add~2 flow_test_conservative_compressible_add module~penf->program~flow_test_conservative_compressible_add~2 program~flow_test_primitive_compressible_div flow_test_primitive_compressible_div module~penf->program~flow_test_primitive_compressible_div module~penf_stringify->module~penf module~flow flow module~flow_eos_compressible->module~flow module~flow_conservative_compressible->module~flow_compressible_transformations module~flow_conservative_compressible->module~flow module~flow_primitive_compressible->module~flow_compressible_transformations module~flow_primitive_compressible->module~flow module~flow_eos_object->module~flow_eos_compressible module~flow_eos_object->module~flow_conservative_compressible module~flow_eos_object->module~flow_primitive_compressible module~flow_eos_object->module~flow_conservative_object module~flow_eos_object->module~flow_primitive_object module~flow_eos_object->module~flow_primitive_compressible_multispecie module~flow_eos_object->module~flow_compressible_transformations module~flow_eos_object->module~flow module~flow_field_object->module~flow_conservative_compressible module~flow_field_object->module~flow_primitive_compressible module~flow_field_object->module~flow_conservative_object module~flow_field_object->module~flow_field_scalar_vectorial module~flow_field_object->module~flow_primitive_object module~flow_field_object->module~flow_primitive_compressible_multispecie module~flow_field_object->module~flow module~flow_conservative_object->module~flow_conservative_compressible module~flow_conservative_object->module~flow module~flow_field_scalar_vectorial->module~flow module~flow_primitive_object->module~flow_primitive_compressible module~flow_primitive_object->module~flow_primitive_compressible_multispecie module~flow_primitive_object->module~flow module~flow_primitive_compressible_multispecie->module~flow module~flow_compressible_transformations->module~flow module~flow->program~flow_test_conservative_compressible_sub module~flow->program~flow_test_eos_compressible module~flow->program~flow_test_primitive_compressible_add module~flow->program~flow_test_primitive_compressible_multispecie_eq module~flow->program~flow_test_primitive_compressible_assign module~flow->program~flow_test_primitive_compressible_eq module~flow->program~flow_test_primitive_compressible_multispecie_add module~flow->program~flow_test_primitive_compressible_multispecie_div module~flow->program~flow_test_primitive_compressible_mul module~flow->program~flow_test_primitive_compressible_multispecie_mul module~flow->program~flow_test_primitive_compressible_multispecie_not_eq module~flow->program~flow_test_primitive_compressible_multispecie_add~2 module~flow->program~flow_test_primitive_compressible_multispecie_sub module~flow->program~flow_test_primitive_compressible_not_eq module~flow->program~flow_test_primitive_compressible_add~2 module~flow->program~flow_test_primitive_compressible_sub module~flow->program~flow_test_compressible_transformations module~flow->program~flow_test_primitive_compressible_multispecie_assign module~flow->program~flow_test_conservative_compressible_add module~flow->program~flow_test_conservative_compressible_assign module~flow->program~flow_test_conservative_compressible_div module~flow->program~flow_test_conservative_compressible_eq module~flow->program~flow_test_conservative_compressible_mul module~flow->program~flow_test_conservative_compressible_not_eq module~flow->program~flow_test_conservative_compressible_add~2 module~flow->program~flow_test_primitive_compressible_div var panmodulepenf_b_sizeUsedByGraph = svgPanZoom('#modulepenf_b_sizeUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Interfaces bit_size byte_size Functions bit_size_R16P bit_size_R4P bit_size_R8P bit_size_chr byte_size_I1P byte_size_I2P byte_size_I4P byte_size_I8P byte_size_R16P byte_size_R4P byte_size_R8P byte_size_chr Interfaces public interface bit_size Overloading of the intrinsic bit_size function for computing the number of bits of (also) real and character variables. private elemental function bit_size_R8P (i) result(bits) Compute the number of bits of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. private elemental function bit_size_R4P (i) result(bits) Compute the number of bits of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. private elemental function bit_size_chr (i) result(bits) Compute the number of bits of a character variable. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bits must be computed. Return Value integer(kind=I4P) Number of bits of c. public interface byte_size Compute the number of bytes of a variable. private elemental function byte_size_I8P (i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. private elemental function byte_size_I4P (i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. private elemental function byte_size_I2P (i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. private elemental function byte_size_I1P (i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. private elemental function byte_size_R8P (i) result(bytes) Compute the number of bytes of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. private elemental function byte_size_R4P (i) result(bytes) Compute the number of bytes of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. private elemental function byte_size_chr (i) result(bytes) Compute the number of bytes of a character variable. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bytes must be computed. Return Value integer(kind=I4P) Number of bytes of c. Functions private elemental function bit_size_R16P (i) result(bits) Compute the number of bits of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I2P) Number of bits of r. private elemental function bit_size_R4P (i) result(bits) Compute the number of bits of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. private elemental function bit_size_R8P (i) result(bits) Compute the number of bits of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bits must be computed. Return Value integer(kind=I1P) Number of bits of r. private elemental function bit_size_chr (i) result(bits) Compute the number of bits of a character variable. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bits must be computed. Return Value integer(kind=I4P) Number of bits of c. private elemental function byte_size_I1P (i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. private elemental function byte_size_I2P (i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. private elemental function byte_size_I4P (i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. private elemental function byte_size_I8P (i) result(bytes) Compute the number of bytes of an integer variable. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: i Integer variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of i. private elemental function byte_size_R16P (i) result(bytes) Compute the number of bytes of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. private elemental function byte_size_R4P (i) result(bytes) Compute the number of bytes of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. private elemental function byte_size_R8P (i) result(bytes) Compute the number of bytes of a real variable. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: i Real variable whose number of bytes must be computed. Return Value integer(kind=I1P) Number of bytes of r. private elemental function byte_size_chr (i) result(bytes) Compute the number of bytes of a character variable. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: i Character variable whose number of bytes must be computed. Return Value integer(kind=I4P) Number of bytes of c.","tags":"","loc":"module/penf_b_size.html","title":"penf_b_size – FLOw"},{"text":"PENF global (exposed) parameters and variables. Note All module defined entities are public. Used By module~~penf_global_parameters_variables~~UsedByGraph module~penf_global_parameters_variables penf_global_parameters_variables module~penf penf module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_stringify penf_stringify module~penf_global_parameters_variables->module~penf_stringify program~flow_test_conservative_compressible_sub flow_test_conservative_compressible_sub module~penf->program~flow_test_conservative_compressible_sub program~flow_test_eos_compressible flow_test_eos_compressible module~penf->program~flow_test_eos_compressible program~flow_test_primitive_compressible_add flow_test_primitive_compressible_add module~penf->program~flow_test_primitive_compressible_add program~flow_test_primitive_compressible_multispecie_eq flow_test_primitive_compressible_multispecie_eq module~penf->program~flow_test_primitive_compressible_multispecie_eq program~flow_test_primitive_compressible_assign flow_test_primitive_compressible_assign module~penf->program~flow_test_primitive_compressible_assign module~flow_eos_compressible flow_eos_compressible module~penf->module~flow_eos_compressible program~flow_test_primitive_compressible_eq flow_test_primitive_compressible_eq module~penf->program~flow_test_primitive_compressible_eq module~flow_conservative_compressible flow_conservative_compressible module~penf->module~flow_conservative_compressible module~flow_primitive_compressible flow_primitive_compressible module~penf->module~flow_primitive_compressible program~flow_test_primitive_compressible_multispecie_add flow_test_primitive_compressible_multispecie_add module~penf->program~flow_test_primitive_compressible_multispecie_add module~flow_eos_object flow_eos_object module~penf->module~flow_eos_object program~flow_test_primitive_compressible_multispecie_div flow_test_primitive_compressible_multispecie_div module~penf->program~flow_test_primitive_compressible_multispecie_div module~flow_field_object flow_field_object module~penf->module~flow_field_object program~flow_test_primitive_compressible_mul flow_test_primitive_compressible_mul module~penf->program~flow_test_primitive_compressible_mul program~flow_test_primitive_compressible_multispecie_mul flow_test_primitive_compressible_multispecie_mul module~penf->program~flow_test_primitive_compressible_multispecie_mul program~flow_test_primitive_compressible_multispecie_not_eq flow_test_primitive_compressible_multispecie_not_eq module~penf->program~flow_test_primitive_compressible_multispecie_not_eq program~flow_test_primitive_compressible_multispecie_add~2 flow_test_primitive_compressible_multispecie_add module~penf->program~flow_test_primitive_compressible_multispecie_add~2 program~flow_test_primitive_compressible_multispecie_sub flow_test_primitive_compressible_multispecie_sub module~penf->program~flow_test_primitive_compressible_multispecie_sub program~flow_test_primitive_compressible_not_eq flow_test_primitive_compressible_not_eq module~penf->program~flow_test_primitive_compressible_not_eq program~flow_test_primitive_compressible_add~2 flow_test_primitive_compressible_add module~penf->program~flow_test_primitive_compressible_add~2 program~flow_test_primitive_compressible_sub flow_test_primitive_compressible_sub module~penf->program~flow_test_primitive_compressible_sub module~flow_conservative_object flow_conservative_object module~penf->module~flow_conservative_object program~flow_test_compressible_transformations flow_test_compressible_transformations module~penf->program~flow_test_compressible_transformations module~flow_field_scalar_vectorial flow_field_scalar_vectorial module~penf->module~flow_field_scalar_vectorial module~flow_primitive_object flow_primitive_object module~penf->module~flow_primitive_object program~flow_test_primitive_compressible_multispecie_assign flow_test_primitive_compressible_multispecie_assign module~penf->program~flow_test_primitive_compressible_multispecie_assign module~flow_primitive_compressible_multispecie flow_primitive_compressible_multispecie module~penf->module~flow_primitive_compressible_multispecie program~flow_test_conservative_compressible_add flow_test_conservative_compressible_add module~penf->program~flow_test_conservative_compressible_add module~flow_compressible_transformations flow_compressible_transformations module~penf->module~flow_compressible_transformations program~flow_test_conservative_compressible_assign flow_test_conservative_compressible_assign module~penf->program~flow_test_conservative_compressible_assign program~flow_test_conservative_compressible_div flow_test_conservative_compressible_div module~penf->program~flow_test_conservative_compressible_div program~flow_test_conservative_compressible_eq flow_test_conservative_compressible_eq module~penf->program~flow_test_conservative_compressible_eq program~flow_test_conservative_compressible_mul flow_test_conservative_compressible_mul module~penf->program~flow_test_conservative_compressible_mul program~flow_test_conservative_compressible_not_eq flow_test_conservative_compressible_not_eq module~penf->program~flow_test_conservative_compressible_not_eq program~flow_test_conservative_compressible_add~2 flow_test_conservative_compressible_add module~penf->program~flow_test_conservative_compressible_add~2 program~flow_test_primitive_compressible_div flow_test_primitive_compressible_div module~penf->program~flow_test_primitive_compressible_div module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf module~flow flow module~flow_eos_compressible->module~flow module~flow_conservative_compressible->module~flow_compressible_transformations module~flow_conservative_compressible->module~flow module~flow_primitive_compressible->module~flow_compressible_transformations module~flow_primitive_compressible->module~flow module~flow_eos_object->module~flow_eos_compressible module~flow_eos_object->module~flow_conservative_compressible module~flow_eos_object->module~flow_primitive_compressible module~flow_eos_object->module~flow_conservative_object module~flow_eos_object->module~flow_primitive_object module~flow_eos_object->module~flow_primitive_compressible_multispecie module~flow_eos_object->module~flow_compressible_transformations module~flow_eos_object->module~flow module~flow_field_object->module~flow_conservative_compressible module~flow_field_object->module~flow_primitive_compressible module~flow_field_object->module~flow_conservative_object module~flow_field_object->module~flow_field_scalar_vectorial module~flow_field_object->module~flow_primitive_object module~flow_field_object->module~flow_primitive_compressible_multispecie module~flow_field_object->module~flow module~flow_conservative_object->module~flow_conservative_compressible module~flow_conservative_object->module~flow module~flow_field_scalar_vectorial->module~flow module~flow_primitive_object->module~flow_primitive_compressible module~flow_primitive_object->module~flow_primitive_compressible_multispecie module~flow_primitive_object->module~flow module~flow_primitive_compressible_multispecie->module~flow module~flow_compressible_transformations->module~flow module~flow->program~flow_test_conservative_compressible_sub module~flow->program~flow_test_eos_compressible module~flow->program~flow_test_primitive_compressible_add module~flow->program~flow_test_primitive_compressible_multispecie_eq module~flow->program~flow_test_primitive_compressible_assign module~flow->program~flow_test_primitive_compressible_eq module~flow->program~flow_test_primitive_compressible_multispecie_add module~flow->program~flow_test_primitive_compressible_multispecie_div module~flow->program~flow_test_primitive_compressible_mul module~flow->program~flow_test_primitive_compressible_multispecie_mul module~flow->program~flow_test_primitive_compressible_multispecie_not_eq module~flow->program~flow_test_primitive_compressible_multispecie_add~2 module~flow->program~flow_test_primitive_compressible_multispecie_sub module~flow->program~flow_test_primitive_compressible_not_eq module~flow->program~flow_test_primitive_compressible_add~2 module~flow->program~flow_test_primitive_compressible_sub module~flow->program~flow_test_compressible_transformations module~flow->program~flow_test_primitive_compressible_multispecie_assign module~flow->program~flow_test_conservative_compressible_add module~flow->program~flow_test_conservative_compressible_assign module~flow->program~flow_test_conservative_compressible_div module~flow->program~flow_test_conservative_compressible_eq module~flow->program~flow_test_conservative_compressible_mul module~flow->program~flow_test_conservative_compressible_not_eq module~flow->program~flow_test_conservative_compressible_add~2 module~flow->program~flow_test_primitive_compressible_div var panmodulepenf_global_parameters_variablesUsedByGraph = svgPanZoom('#modulepenf_global_parameters_variablesUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables BII1P BII2P BII4P BII8P BII_P BIR16P BIR4P BIR8P BIR_P BYI1P BYI2P BYI4P BYI8P BYI_P BYR16P BYR4P BYR8P BYR_P DI1P DI2P DI4P DI8P DI_P DR16P DR4P DR8P DR_P FI1P FI1PZP FI2P FI2PZP FI4P FI4PZP FI8P FI8PZP FI_P FI_PZP FR16P FR4P FR8P FR_P I1P I2P I4P I8P INTEGER_FORMATS_LIST INTEGER_KINDS_LIST I_P MaxI1P MaxI2P MaxI4P MaxI8P MaxI_P MaxR16P MaxR4P MaxR8P MaxR_P MinI1P MinI2P MinI4P MinI8P MinI_P MinR16P MinR4P MinR8P MinR_P R16P R4P R8P REAL_FORMATS_LIST REAL_KINDS_LIST R_P Zero ZeroR16 ZeroR4 ZeroR8 endian endianB endianL is_initialized smallR16P smallR4P smallR8P smallR_P Variables Type Visibility Attributes Name Initial integer(kind=I1P), public, parameter :: BII1P = bit_size(MaxI1P) Number of bits of kind=I1P integer. integer(kind=I2P), public, parameter :: BII2P = bit_size(MaxI2P) Number of bits of kind=I2P integer. integer(kind=I4P), public, parameter :: BII4P = bit_size(MaxI4P) Number of bits of kind=I4P integer. integer(kind=I8P), public, parameter :: BII8P = bit_size(MaxI8P) Number of bits of kind=I8P integer. integer(kind=I_P), public, parameter :: BII_P = bit_size(MaxI_P) Number of bits of kind=I_P integer. integer(kind=I2P), public :: BIR16P Number of bits of kind=R16P real. integer(kind=I1P), public :: BIR4P Number of bits of kind=R4P real. integer(kind=I1P), public :: BIR8P Number of bits of kind=R8P real. integer(kind=I1P), public :: BIR_P Number of bits of kind=R_P real. integer(kind=I1P), public, parameter :: BYI1P = bit_size(MaxI1P)/8_I1P Number of bytes of kind=I1P integer. integer(kind=I2P), public, parameter :: BYI2P = bit_size(MaxI2P)/8_I2P Number of bytes of kind=I2P integer. integer(kind=I4P), public, parameter :: BYI4P = bit_size(MaxI4P)/8_I4P Number of bytes of kind=I4P integer. integer(kind=I8P), public, parameter :: BYI8P = bit_size(MaxI8P)/8_I8P Number of bytes of kind=I8P integer. integer(kind=I_P), public, parameter :: BYI_P = bit_size(MaxI_P)/8_I_P Number of bytes of kind=I_P integer. integer(kind=I2P), public :: BYR16P Number of bytes of kind=R16P real. integer(kind=I1P), public :: BYR4P Number of bytes of kind=R4P real. integer(kind=I1P), public :: BYR8P Number of bytes of kind=R8P real. integer(kind=I1P), public :: BYR_P Number of bytes of kind=R_P real. integer, public, parameter :: DI1P = 4 Number of digits of output format I1P. integer, public, parameter :: DI2P = 6 Number of digits of output format I2P. integer, public, parameter :: DI4P = 11 Number of digits of output format I4P. integer, public, parameter :: DI8P = 20 Number of digits of output format I8P. integer, public, parameter :: DI_P = DI4P Number of digits of output format I_P. integer, public, parameter :: DR16P = 23 Number of digits of output format FR16P. integer, public, parameter :: DR4P = 13 Number of digits of output format FR4P. integer, public, parameter :: DR8P = 23 Number of digits of output format FR8P. integer, public, parameter :: DR_P = DR8P Number of digits of output format FR_P. character(len=*), public, parameter :: FI1P = '(I4)' Output format for kind=I1P integer. character(len=*), public, parameter :: FI1PZP = '(I4.3)' Output format for kind=I1P integer with zero prefixing. character(len=*), public, parameter :: FI2P = '(I6)' Output format for kind=I2P integer. character(len=*), public, parameter :: FI2PZP = '(I6.5)' Output format for kind=I2P integer with zero prefixing. character(len=*), public, parameter :: FI4P = '(I11)' Output format for kind=I4P integer. character(len=*), public, parameter :: FI4PZP = '(I11.10)' Output format for kind=I4P integer with zero prefixing. character(len=*), public, parameter :: FI8P = '(I20)' Output format for kind=I8P integer. character(len=*), public, parameter :: FI8PZP = '(I20.19)' Output format for kind=I8P integer with zero prefixing. character(len=*), public, parameter :: FI_P = FI4P Output format for kind=I_P integer. character(len=*), public, parameter :: FI_PZP = FI4PZP Output format for kind=I_P integer with zero prefixing. character(len=*), public, parameter :: FR16P = '(E23.15E3)' Output format for kind=R16P real. character(len=*), public, parameter :: FR4P = '(E13.6E2)' Output format for kind=R4P real. character(len=*), public, parameter :: FR8P = '(E23.15E3)' Output format for kind=R8P real. character(len=*), public, parameter :: FR_P = FR8P Output format for kind=R_P real. integer, public, parameter :: I1P = selected_int_kind(2) Range [-2&#94;{7} ,+2&#94;{7}  - 1], 3  digits plus sign; 8  bits. integer, public, parameter :: I2P = selected_int_kind(4) Range [-2&#94;{15},+2&#94;{15} - 1], 5  digits plus sign; 16 bits. integer, public, parameter :: I4P = selected_int_kind(9) Range [-2&#94;{31},+2&#94;{31} - 1], 10 digits plus sign; 32 bits. integer, public, parameter :: I8P = selected_int_kind(18) Range [-2&#94;{63},+2&#94;{63} - 1], 19 digits plus sign; 64 bits. character(len=*), public, parameter :: INTEGER_FORMATS_LIST (1:5) = [FI8P, FI4P, FI2P//' ', FI1P//' ', FI_P] List of integer formats. integer, public, parameter :: INTEGER_KINDS_LIST (1:5) = [I8P, I4P, I2P, I1P, I_P] List of integer kinds. integer, public, parameter :: I_P = I4P Default integer precision. integer(kind=I1P), public, parameter :: MaxI1P = huge(1_I1P) Maximum value of kind=I1P integer. integer(kind=I2P), public, parameter :: MaxI2P = huge(1_I2P) Maximum value of kind=I2P integer. integer(kind=I4P), public, parameter :: MaxI4P = huge(1_I4P) Maximum value of kind=I4P integer. integer(kind=I8P), public, parameter :: MaxI8P = huge(1_I8P) Maximum value of kind=I8P integer. integer(kind=I_P), public, parameter :: MaxI_P = MaxI4P Maximum value of kind=I_P integer. real(kind=R16P), public, parameter :: MaxR16P = huge(1._R16P) Maximum value of kind=R16P real. real(kind=R4P), public, parameter :: MaxR4P = huge(1._R4P) Maximum value of kind=R4P real. real(kind=R8P), public, parameter :: MaxR8P = huge(1._R8P) Maximum value of kind=R8P real. real(kind=R_P), public, parameter :: MaxR_P = MaxR8P Maximum value of kind=R_P real. integer(kind=I1P), public, parameter :: MinI1P = -huge(1_I1P) Minimum value of kind=I1P integer. integer(kind=I2P), public, parameter :: MinI2P = -huge(1_I2P) Minimum value of kind=I2P integer. integer(kind=I4P), public, parameter :: MinI4P = -huge(1_I4P) Minimum value of kind=I4P integer. integer(kind=I8P), public, parameter :: MinI8P = -huge(1_I8P) Minimum value of kind=I8P integer. integer(kind=I_P), public, parameter :: MinI_P = MinI4P Minimum value of kind=I_P integer. real(kind=R16P), public, parameter :: MinR16P = -huge(1._R16P) Minimum value of kind=R16P real. real(kind=R4P), public, parameter :: MinR4P = -huge(1._R4P) Minimum value of kind=R4P real. real(kind=R8P), public, parameter :: MinR8P = -huge(1._R8P) Minimum value of kind=R8P real. real(kind=R_P), public, parameter :: MinR_P = MinR8P Minimum value of kind=R_P real. integer, public, parameter :: R16P = selected_real_kind(15, 307) Defined as R8P; 64 bits. integer, public, parameter :: R4P = selected_real_kind(6, 37) 6  digits, range [10&#94;{-37}  , 10&#94;{+37}   - 1]; 32 bits. integer, public, parameter :: R8P = selected_real_kind(15, 307) 15 digits, range [10&#94;{-307} , 10&#94;{+307}  - 1]; 64 bits. character(len=*), public, parameter :: REAL_FORMATS_LIST (1:4) = [FR16P, FR8P, FR4P//' ', FR_P] List of real formats. integer, public, parameter :: REAL_KINDS_LIST (1:4) = [R16P, R8P, R4P, R_P] List of real kinds. integer, public, parameter :: R_P = R8P Default real precision. real(kind=R_P), public, parameter :: Zero = ZeroR8 Smallest representable difference of kind=R_P real. real(kind=R16P), public, parameter :: ZeroR16 = nearest(1._R16P, 1._R16P)-nearest(1._R16P, -1._R16P) Smallest representable difference of kind=R16P real. real(kind=R4P), public, parameter :: ZeroR4 = nearest(1._R4P, 1._R4P)-nearest(1._R4P, -1._R4P) Smallest representable difference of kind=R4P real. real(kind=R8P), public, parameter :: ZeroR8 = nearest(1._R8P, 1._R8P)-nearest(1._R8P, -1._R8P) Smallest representable difference of kind=R8P real. integer, public :: endian = endianL Bit ordering: Little endian (endianL), or Big endian (endianB). integer, public, parameter :: endianB = 0 Big endian parameter. integer, public, parameter :: endianL = 1 Little endian parameter. logical, public :: is_initialized = .false. Check the initialization of some variables that must be initialized. real(kind=R16P), public, parameter :: smallR16P = tiny(1._R16P) Smallest representable value of kind=R16P real. real(kind=R4P), public, parameter :: smallR4P = tiny(1._R4P) Smallest representable value of kind=R4P real. real(kind=R8P), public, parameter :: smallR8P = tiny(1._R8P) Smallest representable value of kind=R8P real. real(kind=R_P), public, parameter :: smallR_P = smallR8P Smallest representable value of kind=R_P real.","tags":"","loc":"module/penf_global_parameters_variables.html","title":"penf_global_parameters_variables – FLOw"},{"text":"Uses: iso_fortran_env penf_b_size penf_global_parameters_variables module~~penf_stringify~~UsesGraph module~penf_stringify penf_stringify iso_fortran_env iso_fortran_env iso_fortran_env->module~penf_stringify module~penf_b_size penf_b_size module~penf_b_size->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf_stringify module~penf_global_parameters_variables->module~penf_b_size Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. PENF string-to-number (and viceversa) facility. Used By module~~penf_stringify~~UsedByGraph module~penf_stringify penf_stringify module~penf penf module~penf_stringify->module~penf program~flow_test_conservative_compressible_sub flow_test_conservative_compressible_sub module~penf->program~flow_test_conservative_compressible_sub program~flow_test_eos_compressible flow_test_eos_compressible module~penf->program~flow_test_eos_compressible program~flow_test_primitive_compressible_add flow_test_primitive_compressible_add module~penf->program~flow_test_primitive_compressible_add program~flow_test_primitive_compressible_multispecie_eq flow_test_primitive_compressible_multispecie_eq module~penf->program~flow_test_primitive_compressible_multispecie_eq program~flow_test_primitive_compressible_assign flow_test_primitive_compressible_assign module~penf->program~flow_test_primitive_compressible_assign module~flow_eos_compressible flow_eos_compressible module~penf->module~flow_eos_compressible program~flow_test_primitive_compressible_eq flow_test_primitive_compressible_eq module~penf->program~flow_test_primitive_compressible_eq module~flow_conservative_compressible flow_conservative_compressible module~penf->module~flow_conservative_compressible module~flow_primitive_compressible flow_primitive_compressible module~penf->module~flow_primitive_compressible program~flow_test_primitive_compressible_multispecie_add flow_test_primitive_compressible_multispecie_add module~penf->program~flow_test_primitive_compressible_multispecie_add module~flow_eos_object flow_eos_object module~penf->module~flow_eos_object program~flow_test_primitive_compressible_multispecie_div flow_test_primitive_compressible_multispecie_div module~penf->program~flow_test_primitive_compressible_multispecie_div module~flow_field_object flow_field_object module~penf->module~flow_field_object program~flow_test_primitive_compressible_mul flow_test_primitive_compressible_mul module~penf->program~flow_test_primitive_compressible_mul program~flow_test_primitive_compressible_multispecie_mul flow_test_primitive_compressible_multispecie_mul module~penf->program~flow_test_primitive_compressible_multispecie_mul program~flow_test_primitive_compressible_multispecie_not_eq flow_test_primitive_compressible_multispecie_not_eq module~penf->program~flow_test_primitive_compressible_multispecie_not_eq program~flow_test_primitive_compressible_multispecie_add~2 flow_test_primitive_compressible_multispecie_add module~penf->program~flow_test_primitive_compressible_multispecie_add~2 program~flow_test_primitive_compressible_multispecie_sub flow_test_primitive_compressible_multispecie_sub module~penf->program~flow_test_primitive_compressible_multispecie_sub program~flow_test_primitive_compressible_not_eq flow_test_primitive_compressible_not_eq module~penf->program~flow_test_primitive_compressible_not_eq program~flow_test_primitive_compressible_add~2 flow_test_primitive_compressible_add module~penf->program~flow_test_primitive_compressible_add~2 program~flow_test_primitive_compressible_sub flow_test_primitive_compressible_sub module~penf->program~flow_test_primitive_compressible_sub module~flow_conservative_object flow_conservative_object module~penf->module~flow_conservative_object program~flow_test_compressible_transformations flow_test_compressible_transformations module~penf->program~flow_test_compressible_transformations module~flow_field_scalar_vectorial flow_field_scalar_vectorial module~penf->module~flow_field_scalar_vectorial module~flow_primitive_object flow_primitive_object module~penf->module~flow_primitive_object program~flow_test_primitive_compressible_multispecie_assign flow_test_primitive_compressible_multispecie_assign module~penf->program~flow_test_primitive_compressible_multispecie_assign module~flow_primitive_compressible_multispecie flow_primitive_compressible_multispecie module~penf->module~flow_primitive_compressible_multispecie program~flow_test_conservative_compressible_add flow_test_conservative_compressible_add module~penf->program~flow_test_conservative_compressible_add module~flow_compressible_transformations flow_compressible_transformations module~penf->module~flow_compressible_transformations program~flow_test_conservative_compressible_assign flow_test_conservative_compressible_assign module~penf->program~flow_test_conservative_compressible_assign program~flow_test_conservative_compressible_div flow_test_conservative_compressible_div module~penf->program~flow_test_conservative_compressible_div program~flow_test_conservative_compressible_eq flow_test_conservative_compressible_eq module~penf->program~flow_test_conservative_compressible_eq program~flow_test_conservative_compressible_mul flow_test_conservative_compressible_mul module~penf->program~flow_test_conservative_compressible_mul program~flow_test_conservative_compressible_not_eq flow_test_conservative_compressible_not_eq module~penf->program~flow_test_conservative_compressible_not_eq program~flow_test_conservative_compressible_add~2 flow_test_conservative_compressible_add module~penf->program~flow_test_conservative_compressible_add~2 program~flow_test_primitive_compressible_div flow_test_primitive_compressible_div module~penf->program~flow_test_primitive_compressible_div module~flow flow module~flow_eos_compressible->module~flow module~flow_conservative_compressible->module~flow_compressible_transformations module~flow_conservative_compressible->module~flow module~flow_primitive_compressible->module~flow_compressible_transformations module~flow_primitive_compressible->module~flow module~flow_eos_object->module~flow_eos_compressible module~flow_eos_object->module~flow_conservative_compressible module~flow_eos_object->module~flow_primitive_compressible module~flow_eos_object->module~flow_conservative_object module~flow_eos_object->module~flow_primitive_object module~flow_eos_object->module~flow_primitive_compressible_multispecie module~flow_eos_object->module~flow_compressible_transformations module~flow_eos_object->module~flow module~flow_field_object->module~flow_conservative_compressible module~flow_field_object->module~flow_primitive_compressible module~flow_field_object->module~flow_conservative_object module~flow_field_object->module~flow_field_scalar_vectorial module~flow_field_object->module~flow_primitive_object module~flow_field_object->module~flow_primitive_compressible_multispecie module~flow_field_object->module~flow module~flow_conservative_object->module~flow_conservative_compressible module~flow_conservative_object->module~flow module~flow_field_scalar_vectorial->module~flow module~flow_primitive_object->module~flow_primitive_compressible module~flow_primitive_object->module~flow_primitive_compressible_multispecie module~flow_primitive_object->module~flow module~flow_primitive_compressible_multispecie->module~flow module~flow_compressible_transformations->module~flow module~flow->program~flow_test_conservative_compressible_sub module~flow->program~flow_test_eos_compressible module~flow->program~flow_test_primitive_compressible_add module~flow->program~flow_test_primitive_compressible_multispecie_eq module~flow->program~flow_test_primitive_compressible_assign module~flow->program~flow_test_primitive_compressible_eq module~flow->program~flow_test_primitive_compressible_multispecie_add module~flow->program~flow_test_primitive_compressible_multispecie_div module~flow->program~flow_test_primitive_compressible_mul module~flow->program~flow_test_primitive_compressible_multispecie_mul module~flow->program~flow_test_primitive_compressible_multispecie_not_eq module~flow->program~flow_test_primitive_compressible_multispecie_add~2 module~flow->program~flow_test_primitive_compressible_multispecie_sub module~flow->program~flow_test_primitive_compressible_not_eq module~flow->program~flow_test_primitive_compressible_add~2 module~flow->program~flow_test_primitive_compressible_sub module~flow->program~flow_test_compressible_transformations module~flow->program~flow_test_primitive_compressible_multispecie_assign module~flow->program~flow_test_conservative_compressible_add module~flow->program~flow_test_conservative_compressible_assign module~flow->program~flow_test_conservative_compressible_div module~flow->program~flow_test_conservative_compressible_eq module~flow->program~flow_test_conservative_compressible_mul module~flow->program~flow_test_conservative_compressible_not_eq module~flow->program~flow_test_conservative_compressible_add~2 module~flow->program~flow_test_primitive_compressible_div var panmodulepenf_stringifyUsedByGraph = svgPanZoom('#modulepenf_stringifyUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Interfaces bcton bstr cton str strz Functions bctoi_I1P bctoi_I2P bctoi_I4P bctoi_I8P bctor_R16P bctor_R4P bctor_R8P bstr_I1P bstr_I2P bstr_I4P bstr_I8P bstr_R16P bstr_R4P bstr_R8P ctoi_I1P ctoi_I2P ctoi_I4P ctoi_I8P ctor_R16P ctor_R4P ctor_R8P str_I1P str_I2P str_I4P str_I8P str_R16P str_R4P str_R8P str_a_I1P str_a_I2P str_a_I4P str_a_I8P str_a_R16P str_a_R4P str_a_R8P str_bol strf_I1P strf_I2P strf_I4P strf_I8P strf_R16P strf_R4P strf_R8P strz_I1P strz_I2P strz_I4P strz_I8P Subroutines compact_real_string Interfaces public interface bcton Convert bit-string to number (real and integer, bit-string to number type casting). private elemental function bctor_R8P (bstr, knd) result(n) Convert bit-string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R8P), intent(in) :: knd Number kind. Return Value real(kind=R8P) Number returned. private elemental function bctor_R4P (bstr, knd) result(n) Convert bit-string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R4P), intent(in) :: knd Number kind. Return Value real(kind=R4P) Number returned. private elemental function bctoi_I8P (bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. Return Value integer(kind=I8P) Number returned. private elemental function bctoi_I4P (bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. Return Value integer(kind=I4P) Number returned. private elemental function bctoi_I2P (bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. Return Value integer(kind=I2P) Number returned. private elemental function bctoi_I1P (bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. Return Value integer(kind=I1P) Number returned. public interface bstr Convert number (real and integer) to bit-string (number to bit-string type casting). private elemental function bstr_R8P (n) result(bstr) Convert real to string of bits. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. private elemental function bstr_R4P (n) result(bstr) Convert real to string of bits. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. private elemental function bstr_I8P (n) result(bstr) Convert integer to string of bits. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. private elemental function bstr_I4P (n) result(bstr) Convert integer to string of bits. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. private elemental function bstr_I2P (n) result(bstr) Convert integer to string of bits. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Real to be converted. Return Value character(len=16) Returned bit-string containing input number. private elemental function bstr_I1P (n) result(bstr) Convert integer to string of bits. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Real to be converted. Return Value character(len=8) Returned bit-string containing input number. public interface cton Convert string to number (real and integer, string to number type casting). private function ctor_R8P (str, knd, pref, error) result(n) Convert string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R8P) Number returned. private function ctor_R4P (str, knd, pref, error) result(n) Convert string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R4P) Number returned. private function ctoi_I8P (str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I8P) Number returned. private function ctoi_I4P (str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I4P) Number returned. private function ctoi_I2P (str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I2P) Number returned. private function ctoi_I1P (str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I1P) Number returned. public interface str Convert number (real and integer) to string (number to string type casting). private elemental function strf_R8P (fm, n) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=DR8P) Returned string containing input number. private elemental function str_R8P (n, no_sign, compact) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=DR8P) Returned string containing input number. private elemental function strf_R4P (fm, n) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=DR4P) Returned string containing input number. private elemental function str_R4P (n, no_sign, compact) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=DR4P) Returned string containing input number. private elemental function strf_I8P (fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number. private elemental function str_I8P (n, no_sign) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. private elemental function strf_I4P (fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number. private elemental function str_I4P (n, no_sign) result(str) Converting integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. private elemental function strf_I2P (fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number. private elemental function str_I2P (n, no_sign) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. private elemental function strf_I1P (fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number. private elemental function str_I1P (n, no_sign) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. private elemental function str_bol (n) result(str) Convert logical to string. Arguments Type Intent Optional Attributes Name logical, intent(in) :: n Logical to be converted. Return Value character(len=1) Returned string containing input number plus padding zeros. private pure function str_a_R8P (n, no_sign, separator, delimiters, compact) result(str) Convert real array to string. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_R4P (n, no_sign, separator, delimiters, compact) result(str) Convert real array to string. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_I8P (n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_I4P (n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_I2P (n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_I1P (n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. public interface strz Convert integer, to string, prefixing with the right number of zeros (integer to string type casting with zero padding). private elemental function strz_I8P (n, nz_pad) result(str) Converting integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. private elemental function strz_I4P (n, nz_pad) result(str) Convert integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. private elemental function strz_I2P (n, nz_pad) result(str) Convert integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. private elemental function strz_I1P (n, nz_pad) result(str) Convert integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. Functions private elemental function bctoi_I1P (bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. Return Value integer(kind=I1P) Number returned. private elemental function bctoi_I2P (bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. Return Value integer(kind=I2P) Number returned. private elemental function bctoi_I4P (bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. Return Value integer(kind=I4P) Number returned. private elemental function bctoi_I8P (bstr, knd) result(n) Convert bit-string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. Return Value integer(kind=I8P) Number returned. private elemental function bctor_R16P (bstr, knd) result(n) Convert bit-string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R16P), intent(in) :: knd Number kind. Return Value real(kind=R16P) Number returned. private elemental function bctor_R4P (bstr, knd) result(n) Convert bit-string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R4P), intent(in) :: knd Number kind. Return Value real(kind=R4P) Number returned. private elemental function bctor_R8P (bstr, knd) result(n) Convert bit-string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: bstr String containing input number. real(kind=R8P), intent(in) :: knd Number kind. Return Value real(kind=R8P) Number returned. private elemental function bstr_I1P (n) result(bstr) Convert integer to string of bits. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Real to be converted. Return Value character(len=8) Returned bit-string containing input number. private elemental function bstr_I2P (n) result(bstr) Convert integer to string of bits. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Real to be converted. Return Value character(len=16) Returned bit-string containing input number. private elemental function bstr_I4P (n) result(bstr) Convert integer to string of bits. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. private elemental function bstr_I8P (n) result(bstr) Convert integer to string of bits. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. private elemental function bstr_R16P (n) result(bstr) Convert real to string of bits. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n Real to be converted. Return Value character(len=128) Returned bit-string containing input number. private elemental function bstr_R4P (n) result(bstr) Convert real to string of bits. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=32) Returned bit-string containing input number. private elemental function bstr_R8P (n) result(bstr) Convert real to string of bits. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=64) Returned bit-string containing input number. private function ctoi_I1P (str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I1P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I1P) Number returned. private function ctoi_I2P (str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I2P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I2P) Number returned. private function ctoi_I4P (str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I4P) Number returned. private function ctoi_I8P (str, knd, pref, error) result(n) Convert string to integer. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. integer(kind=I8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value integer(kind=I8P) Number returned. private function ctor_R16P (str, knd, pref, error) result(n) Convert string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R16P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R16P) Number returned. private function ctor_R4P (str, knd, pref, error) result(n) Convert string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R4P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R4P) Number returned. private function ctor_R8P (str, knd, pref, error) result(n) Convert string to real. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: str String containing input number. real(kind=R8P), intent(in) :: knd Number kind. character(len=*), intent(in), optional :: pref Prefixing string. integer(kind=I4P), intent(out), optional :: error Error trapping flag: 0 no errors, >0 error occurs. Return Value real(kind=R8P) Number returned. private elemental function str_I1P (n, no_sign) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. private elemental function str_I2P (n, no_sign) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. private elemental function str_I4P (n, no_sign) result(str) Converting integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. private elemental function str_I8P (n, no_sign) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. private elemental function str_R16P (n, no_sign, compact) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=DR16P) Returned string containing input number. private elemental function str_R4P (n, no_sign, compact) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=DR4P) Returned string containing input number. private elemental function str_R8P (n, no_sign, compact) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n Real to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=DR8P) Returned string containing input number. private pure function str_a_I1P (n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_I2P (n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_I4P (n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_I8P (n, no_sign, separator, delimiters) result(str) Convert integer array to string. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n (:) Integer array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_R16P (n, no_sign, separator, delimiters, compact) result(str) Converting real array to string. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator (1) Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_R4P (n, no_sign, separator, delimiters, compact) result(str) Convert real array to string. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=:),\n  allocatable Returned string containing input number. private pure function str_a_R8P (n, no_sign, separator, delimiters, compact) result(str) Convert real array to string. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: n (:) Real array to be converted. logical, intent(in), optional :: no_sign Flag for leaving out the sign. character(len=1), intent(in), optional :: separator Eventual separator of array values. character(len=*), intent(in), optional :: delimiters (1:2) Eventual delimiters of array values. logical, intent(in), optional :: compact Flag for compacting string encoding. Return Value character(len=:),\n  allocatable Returned string containing input number. private elemental function str_bol (n) result(str) Convert logical to string. Arguments Type Intent Optional Attributes Name logical, intent(in) :: n Logical to be converted. Return Value character(len=1) Returned string containing input number plus padding zeros. private elemental function strf_I1P (fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I1P), intent(in) :: n Integer to be converted. Return Value character(len=DI1P) Returned string containing input number. private elemental function strf_I2P (fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I2P), intent(in) :: n Integer to be converted. Return Value character(len=DI2P) Returned string containing input number. private elemental function strf_I4P (fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I4P), intent(in) :: n Integer to be converted. Return Value character(len=DI4P) Returned string containing input number. private elemental function strf_I8P (fm, n) result(str) Convert integer to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. integer(kind=I8P), intent(in) :: n Integer to be converted. Return Value character(len=DI8P) Returned string containing input number. private elemental function strf_R16P (fm, n) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R16P), intent(in) :: n Real to be converted. Return Value character(len=DR16P) Returned string containing input number. private elemental function strf_R4P (fm, n) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R4P), intent(in) :: n Real to be converted. Return Value character(len=DR4P) Returned string containing input number. private elemental function strf_R8P (fm, n) result(str) Convert real to string. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: fm Format different from the standard for the kind. real(kind=R8P), intent(in) :: n Real to be converted. Return Value character(len=DR8P) Returned string containing input number. private elemental function strz_I1P (n, nz_pad) result(str) Convert integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI1P) Returned string containing input number plus padding zeros. private elemental function strz_I2P (n, nz_pad) result(str) Convert integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI2P) Returned string containing input number plus padding zeros. private elemental function strz_I4P (n, nz_pad) result(str) Convert integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI4P) Returned string containing input number plus padding zeros. private elemental function strz_I8P (n, nz_pad) result(str) Converting integer to string, prefixing with the right number of zeros. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: n Integer to be converted. integer(kind=I4P), intent(in), optional :: nz_pad Number of zeros padding. Return Value character(len=DI8P) Returned string containing input number plus padding zeros. Subroutines private pure subroutine compact_real_string (string) Author Izaak Beekman Date 02/24/2015 Compact a string representing a real number, so that the same value is displayed with fewer characters. Arguments Type Intent Optional Attributes Name character(len=*), intent(inout) :: string string representation of a real number.","tags":"","loc":"module/penf_stringify.html","title":"penf_stringify – FLOw"},{"text":"Uses: iso_fortran_env module~~vecfor~~UsesGraph module~vecfor VecFor iso_fortran_env iso_fortran_env iso_fortran_env->module~vecfor Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Module definition of class Vector. This derived type is useful for manipulating vectors in 3D space. The components of the vectors are reals with\n parametrized kind as defined by the library module. The components are defined in a three-dimensional cartesian frame of\n reference.\n All the vectorial math procedures (cross, dot products, parallel…) assume a three-dimensional cartesian frame of reference.\n The operators of assignment ( = ), multiplication ( * ), division ( / ), sum ( + ) and subtraction ( - ) have been overloaded.\n Furthermore the dot and cross products have been defined.\n Therefore this module provides a far-complete algebra based on Vector derived type. Used By module~~vecfor~~UsedByGraph module~vecfor VecFor program~flow_test_conservative_compressible_sub flow_test_conservative_compressible_sub module~vecfor->program~flow_test_conservative_compressible_sub program~flow_test_primitive_compressible_add flow_test_primitive_compressible_add module~vecfor->program~flow_test_primitive_compressible_add program~flow_test_primitive_compressible_assign flow_test_primitive_compressible_assign module~vecfor->program~flow_test_primitive_compressible_assign program~flow_test_primitive_compressible_div flow_test_primitive_compressible_div module~vecfor->program~flow_test_primitive_compressible_div module~flow_conservative_compressible flow_conservative_compressible module~vecfor->module~flow_conservative_compressible program~flow_test_primitive_compressible_eq flow_test_primitive_compressible_eq module~vecfor->program~flow_test_primitive_compressible_eq program~flow_test_primitive_compressible_mul flow_test_primitive_compressible_mul module~vecfor->program~flow_test_primitive_compressible_mul program~flow_test_primitive_compressible_multispecie_add flow_test_primitive_compressible_multispecie_add module~vecfor->program~flow_test_primitive_compressible_multispecie_add program~flow_test_primitive_compressible_multispecie_assign flow_test_primitive_compressible_multispecie_assign module~vecfor->program~flow_test_primitive_compressible_multispecie_assign program~flow_test_primitive_compressible_multispecie_div flow_test_primitive_compressible_multispecie_div module~vecfor->program~flow_test_primitive_compressible_multispecie_div program~flow_test_primitive_compressible_multispecie_eq flow_test_primitive_compressible_multispecie_eq module~vecfor->program~flow_test_primitive_compressible_multispecie_eq module~flow_primitive_compressible flow_primitive_compressible module~vecfor->module~flow_primitive_compressible program~flow_test_primitive_compressible_multispecie_mul flow_test_primitive_compressible_multispecie_mul module~vecfor->program~flow_test_primitive_compressible_multispecie_mul program~flow_test_primitive_compressible_multispecie_not_eq flow_test_primitive_compressible_multispecie_not_eq module~vecfor->program~flow_test_primitive_compressible_multispecie_not_eq program~flow_test_primitive_compressible_multispecie_add~2 flow_test_primitive_compressible_multispecie_add module~vecfor->program~flow_test_primitive_compressible_multispecie_add~2 program~flow_test_primitive_compressible_multispecie_sub flow_test_primitive_compressible_multispecie_sub module~vecfor->program~flow_test_primitive_compressible_multispecie_sub program~flow_test_primitive_compressible_not_eq flow_test_primitive_compressible_not_eq module~vecfor->program~flow_test_primitive_compressible_not_eq program~flow_test_primitive_compressible_add~2 flow_test_primitive_compressible_add module~vecfor->program~flow_test_primitive_compressible_add~2 program~flow_test_primitive_compressible_sub flow_test_primitive_compressible_sub module~vecfor->program~flow_test_primitive_compressible_sub module~flow_conservative_object flow_conservative_object module~vecfor->module~flow_conservative_object module~flow_field_scalar_vectorial flow_field_scalar_vectorial module~vecfor->module~flow_field_scalar_vectorial module~flow_primitive_object flow_primitive_object module~vecfor->module~flow_primitive_object module~flow_primitive_compressible_multispecie flow_primitive_compressible_multispecie module~vecfor->module~flow_primitive_compressible_multispecie program~flow_test_conservative_compressible_add flow_test_conservative_compressible_add module~vecfor->program~flow_test_conservative_compressible_add module~flow_compressible_transformations flow_compressible_transformations module~vecfor->module~flow_compressible_transformations program~flow_test_conservative_compressible_assign flow_test_conservative_compressible_assign module~vecfor->program~flow_test_conservative_compressible_assign program~flow_test_conservative_compressible_div flow_test_conservative_compressible_div module~vecfor->program~flow_test_conservative_compressible_div program~flow_test_conservative_compressible_eq flow_test_conservative_compressible_eq module~vecfor->program~flow_test_conservative_compressible_eq program~flow_test_conservative_compressible_mul flow_test_conservative_compressible_mul module~vecfor->program~flow_test_conservative_compressible_mul program~flow_test_conservative_compressible_not_eq flow_test_conservative_compressible_not_eq module~vecfor->program~flow_test_conservative_compressible_not_eq program~flow_test_conservative_compressible_add~2 flow_test_conservative_compressible_add module~vecfor->program~flow_test_conservative_compressible_add~2 module~flow_conservative_compressible->module~flow_compressible_transformations module~flow flow module~flow_conservative_compressible->module~flow module~flow_primitive_compressible->module~flow_compressible_transformations module~flow_primitive_compressible->module~flow module~flow_conservative_object->module~flow_conservative_compressible module~flow_conservative_object->module~flow module~flow_field_scalar_vectorial->module~flow module~flow_primitive_object->module~flow_primitive_compressible module~flow_primitive_object->module~flow_primitive_compressible_multispecie module~flow_primitive_object->module~flow module~flow_primitive_compressible_multispecie->module~flow module~flow_compressible_transformations->module~flow module~flow->program~flow_test_conservative_compressible_sub module~flow->program~flow_test_primitive_compressible_add module~flow->program~flow_test_primitive_compressible_assign module~flow->program~flow_test_primitive_compressible_div module~flow->program~flow_test_primitive_compressible_eq module~flow->program~flow_test_primitive_compressible_mul module~flow->program~flow_test_primitive_compressible_multispecie_add module~flow->program~flow_test_primitive_compressible_multispecie_assign module~flow->program~flow_test_primitive_compressible_multispecie_div module~flow->program~flow_test_primitive_compressible_multispecie_eq module~flow->program~flow_test_primitive_compressible_multispecie_mul module~flow->program~flow_test_primitive_compressible_multispecie_not_eq module~flow->program~flow_test_primitive_compressible_multispecie_add~2 module~flow->program~flow_test_primitive_compressible_multispecie_sub module~flow->program~flow_test_primitive_compressible_not_eq module~flow->program~flow_test_primitive_compressible_add~2 module~flow->program~flow_test_primitive_compressible_sub module~flow->program~flow_test_conservative_compressible_add module~flow->program~flow_test_conservative_compressible_assign module~flow->program~flow_test_conservative_compressible_div module~flow->program~flow_test_conservative_compressible_eq module~flow->program~flow_test_conservative_compressible_mul module~flow->program~flow_test_conservative_compressible_not_eq module~flow->program~flow_test_conservative_compressible_add~2 program~flow_test_eos_compressible flow_test_eos_compressible module~flow->program~flow_test_eos_compressible program~flow_test_compressible_transformations flow_test_compressible_transformations module~flow->program~flow_test_compressible_transformations var panmodulevecforUsedByGraph = svgPanZoom('#modulevecforUsedByGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Variables DR8P FR8P I1P I2P I4P I8P R16P R4P R8P ex ey ez smallR8P Derived Types Vector Vector_Ptr Functions I1P_eq_self I1P_great_eq_self I1P_great_self I1P_low_eq_self I1P_low_self I1P_not_eq_self I2P_eq_self I2P_great_eq_self I2P_great_self I2P_low_eq_self I2P_low_self I2P_not_eq_self I4P_eq_self I4P_great_eq_self I4P_great_self I4P_low_eq_self I4P_low_self I4P_not_eq_self I8P_eq_self I8P_great_eq_self I8P_great_self I8P_low_eq_self I8P_low_self I8P_not_eq_self R16P_eq_self R16P_great_eq_self R16P_great_self R16P_low_eq_self R16P_low_self R16P_not_eq_self R4P_eq_self R4P_great_eq_self R4P_great_self R4P_low_eq_self R4P_low_self R4P_not_eq_self R8P_eq_self R8P_great_eq_self R8P_great_self R8P_low_eq_self R8P_low_self R8P_not_eq_self ScalI1P_mul_self ScalI1P_sub_self ScalI1P_sum_self ScalI2P_mul_self ScalI2P_sub_self ScalI2P_sum_self ScalI4P_mul_self ScalI4P_sub_self ScalI4P_sum_self ScalI8P_mul_self ScalI8P_sub_self ScalI8P_sum_self ScalR16P_mul_self ScalR16P_sub_self ScalR16P_sum_self ScalR4P_mul_self ScalR4P_sub_self ScalR4P_sum_self ScalR8P_mul_self ScalR8P_sub_self ScalR8P_sum_self crossproduct dotproduct face_normal3 face_normal4 iolen_vector_self negative_self normL2 normL2_self normalize normalized_self orthogonal parallel positive_self self_div_ScalI1P self_div_ScalI2P self_div_ScalI4P self_div_ScalI8P self_div_ScalR16P self_div_ScalR4P self_div_ScalR8P self_div_self self_eq_I1P self_eq_I2P self_eq_I4P self_eq_I8P self_eq_R16P self_eq_R4P self_eq_R8P self_eq_self self_great_I1P self_great_I2P self_great_I4P self_great_I8P self_great_R16P self_great_R4P self_great_R8P self_great_eq_I1P self_great_eq_I2P self_great_eq_I4P self_great_eq_I8P self_great_eq_R16P self_great_eq_R4P self_great_eq_R8P self_great_eq_self self_great_self self_low_I1P self_low_I2P self_low_I4P self_low_I8P self_low_R16P self_low_R4P self_low_R8P self_low_eq_I1P self_low_eq_I2P self_low_eq_I4P self_low_eq_I8P self_low_eq_R16P self_low_eq_R4P self_low_eq_R8P self_low_eq_self self_low_self self_mul_ScalI1P self_mul_ScalI2P self_mul_ScalI4P self_mul_ScalI8P self_mul_ScalR16P self_mul_ScalR4P self_mul_ScalR8P self_mul_self self_not_eq_I1P self_not_eq_I2P self_not_eq_I4P self_not_eq_I8P self_not_eq_R16P self_not_eq_R4P self_not_eq_R8P self_not_eq_self self_sub_ScalI1P self_sub_ScalI2P self_sub_ScalI4P self_sub_ScalI8P self_sub_ScalR16P self_sub_ScalR4P self_sub_ScalR8P self_sub_self self_sum_ScalI1P self_sum_ScalI2P self_sum_ScalI4P self_sum_ScalI8P self_sum_ScalR16P self_sum_ScalR4P self_sum_ScalR8P self_sum_self sq_norm sq_norm_self Subroutines assign_ScalI1P assign_ScalI2P assign_ScalI4P assign_ScalI8P assign_ScalR16P assign_ScalR4P assign_ScalR8P assign_self face_normal3_self face_normal4_self init_vector_self load_vector_self normalize_self print_vector_self save_vector_self set_vector_self Variables Type Visibility Attributes Name Initial integer, private, parameter :: DR8P = 23 Number of digits of output format FR8P. character(len=10), private, parameter :: FR8P = '(E23.15E3)' Output format for kind=R8P variable. integer, private, parameter :: I1P = selected_int_kind(2) Range [-2&#94;{7} ,+2&#94;{7}  - 1], 3  digits plus sign; 8  bits. integer, private, parameter :: I2P = selected_int_kind(4) Range [-2&#94;{15},+2&#94;{15} - 1], 5  digits plus sign; 16 bits. integer, private, parameter :: I4P = selected_int_kind(9) Range [-2&#94;{31},+2&#94;{31} - 1], 10 digits plus sign; 32 bits. integer, private, parameter :: I8P = selected_int_kind(18) Range [-2&#94;{63},+2&#94;{63} - 1], 19 digits plus sign; 64 bits. integer, private, parameter :: R16P = selected_real_kind(15, 307) Defined as R8P; 64 bits. integer, private, parameter :: R4P = selected_real_kind(6, 37) 6   digits, range [10&#94;{-37}  , 10&#94;{+37}   - 1]; 32 bits. integer, private, parameter :: R8P = selected_real_kind(15, 307) 15  digits, range [10&#94;{-307} , 10&#94;{+307}  - 1]; 64 bits. type( Vector ), public, parameter :: ex = Vector(1._R8P, 0._R8P, 0._R8P) X direction versor. type( Vector ), public, parameter :: ey = Vector(0._R8P, 1._R8P, 0._R8P) Y direction versor. type( Vector ), public, parameter :: ez = Vector(0._R8P, 0._R8P, 1._R8P) Z direction versor. real(kind=R8P), private, parameter :: smallR8P = tiny(1._R8P) Smallest (module) representable value of kind=R8P variable. Derived Types type, public :: Vector Vector class. Components Type Visibility Attributes Name Initial real(kind=R8P), public :: x = 0._R8P Cartesian component in x direction. real(kind=R8P), public :: y = 0._R8P Cartesian component in y direction. real(kind=R8P), public :: z = 0._R8P Cartesian component in z direction. Type-Bound Procedures procedure, private, pass(self ) :: I1P_eq_self procedure, private, pass(self ) :: I1P_great_eq_self procedure, private, pass(self ) :: I1P_great_self procedure, private, pass(self ) :: I1P_low_eq_self procedure, private, pass(self ) :: I1P_low_self procedure, private, pass(self ) :: I1P_not_eq_self procedure, private, pass(self ) :: I2P_eq_self procedure, private, pass(self ) :: I2P_great_eq_self procedure, private, pass(self ) :: I2P_great_self procedure, private, pass(self ) :: I2P_low_eq_self procedure, private, pass(self ) :: I2P_low_self procedure, private, pass(self ) :: I2P_not_eq_self procedure, private, pass(self ) :: I4P_eq_self procedure, private, pass(self ) :: I4P_great_eq_self procedure, private, pass(self ) :: I4P_great_self procedure, private, pass(self ) :: I4P_low_eq_self procedure, private, pass(self ) :: I4P_low_self procedure, private, pass(self ) :: I4P_not_eq_self procedure, private, pass(self ) :: I8P_eq_self procedure, private, pass(self ) :: I8P_great_eq_self procedure, private, pass(self ) :: I8P_great_self procedure, private, pass(self ) :: I8P_low_eq_self procedure, private, pass(self ) :: I8P_low_self procedure, private, pass(self ) :: I8P_not_eq_self procedure, private, pass(self ) :: R4P_eq_self procedure, private, pass(self ) :: R4P_great_eq_self procedure, private, pass(self ) :: R4P_great_self procedure, private, pass(self ) :: R4P_low_eq_self procedure, private, pass(self ) :: R4P_low_self procedure, private, pass(self ) :: R4P_not_eq_self procedure, private, pass(self ) :: R8P_eq_self procedure, private, pass(self ) :: R8P_great_eq_self procedure, private, pass(self ) :: R8P_great_self procedure, private, pass(self ) :: R8P_low_eq_self procedure, private, pass(self ) :: R8P_low_self procedure, private, pass(self ) :: R8P_not_eq_self procedure, private, pass(self ) :: ScalI1P_mul_self procedure, private, pass(self ) :: ScalI1P_sub_self procedure, private, pass(self ) :: ScalI1P_sum_self procedure, private, pass(self ) :: ScalI2P_mul_self procedure, private, pass(self ) :: ScalI2P_sub_self procedure, private, pass(self ) :: ScalI2P_sum_self procedure, private, pass(self ) :: ScalI4P_mul_self procedure, private, pass(self ) :: ScalI4P_sub_self procedure, private, pass(self ) :: ScalI4P_sum_self procedure, private, pass(self ) :: ScalI8P_mul_self procedure, private, pass(self ) :: ScalI8P_sub_self procedure, private, pass(self ) :: ScalI8P_sum_self procedure, private, pass(self ) :: ScalR4P_mul_self procedure, private, pass(self ) :: ScalR4P_sub_self procedure, private, pass(self ) :: ScalR4P_sum_self procedure, private, pass(self ) :: ScalR8P_mul_self procedure, private, pass(self ) :: ScalR8P_sub_self procedure, private, pass(self ) :: ScalR8P_sum_self procedure, private, pass(self ) :: assign_ScalI1P procedure, private, pass(self ) :: assign_ScalI2P procedure, private, pass(self ) :: assign_ScalI4P procedure, private, pass(self ) :: assign_ScalI8P procedure, private, pass(self ) :: assign_ScalR4P procedure, private, pass(self ) :: assign_ScalR8P procedure, private, pass(self1) :: assign_self generic, public :: assignment(=) => assign_self, assign_ScalR8P, assign_ScalR4P, assign_ScalI8P, assign_ScalI4P, assign_ScalI2P, assign_ScalI1P procedure, private, pass(vec1) :: crossproduct procedure, private, pass(vec1) :: dotproduct procedure, public :: face_normal3 => face_normal3_self procedure, public :: face_normal4 => face_normal4_self procedure, public :: init => init_vector_self procedure, public :: iolen => iolen_vector_self procedure, public :: load => load_vector_self procedure, private, pass(self ) :: negative_self procedure, public :: normL2 => normL2_self procedure, public :: normalize => normalize_self procedure, public :: normalized => normalized_self generic, public :: operator(*) => self_mul_self, ScalR8P_mul_self, self_mul_ScalR8P, ScalR4P_mul_self, self_mul_ScalR4P, ScalI8P_mul_self, self_mul_ScalI8P, ScalI4P_mul_self, self_mul_ScalI4P, ScalI2P_mul_self, self_mul_ScalI2P, ScalI1P_mul_self, self_mul_ScalI1P generic, public :: operator(+) => positive_self, self_sum_self, ScalR8P_sum_self, self_sum_ScalR8P, ScalR4P_sum_self, self_sum_ScalR4P, ScalI8P_sum_self, self_sum_ScalI8P, ScalI4P_sum_self, self_sum_ScalI4P, ScalI2P_sum_self, self_sum_ScalI2P, ScalI1P_sum_self, self_sum_ScalI1P generic, public :: operator(-) => negative_self, self_sub_self, ScalR8P_sub_self, self_sub_ScalR8P, ScalR4P_sub_self, self_sub_ScalR4P, ScalI8P_sub_self, self_sub_ScalI8P, ScalI4P_sub_self, self_sub_ScalI4P, ScalI2P_sub_self, self_sub_ScalI2P, ScalI1P_sub_self, self_sub_ScalI1P generic, public :: operator(.cross.) => crossproduct generic, public :: operator(.dot.) => dotproduct generic, public :: operator(.ortho.) => orthogonal generic, public :: operator(.paral.) => parallel generic, public :: operator(/) => self_div_self, self_div_ScalR8P, self_div_ScalR4P, self_div_ScalI8P, self_div_ScalI4P, self_div_ScalI2P, self_div_ScalI1P generic, public :: operator(/=) => self_not_eq_self, R8P_not_eq_self, self_not_eq_R8P, R4P_not_eq_self, self_not_eq_R4P, I8P_not_eq_self, self_not_eq_I8P, I4P_not_eq_self, self_not_eq_I4P, I2P_not_eq_self, self_not_eq_I2P, I1P_not_eq_self, self_not_eq_I1P generic, public :: operator(<) => self_low_self, R8P_low_self, self_low_R8P, R4P_low_self, self_low_R4P, I8P_low_self, self_low_I8P, I4P_low_self, self_low_I4P, I2P_low_self, self_low_I2P, I1P_low_self, self_low_I1P generic, public :: operator(<=) => self_low_eq_self, R8P_low_eq_self, self_low_eq_R8P, R4P_low_eq_self, self_low_eq_R4P, I8P_low_eq_self, self_low_eq_I8P, I4P_low_eq_self, self_low_eq_I4P, I2P_low_eq_self, self_low_eq_I2P, I1P_low_eq_self, self_low_eq_I1P generic, public :: operator(==) => self_eq_self, R8P_eq_self, self_eq_R8P, R4P_eq_self, self_eq_R4P, I8P_eq_self, self_eq_I8P, I4P_eq_self, self_eq_I4P, I2P_eq_self, self_eq_I2P, I1P_eq_self, self_eq_I1P generic, public :: operator(>) => self_great_self, R8P_great_self, self_great_R8P, R4P_great_self, self_great_R4P, I8P_great_self, self_great_I8P, I4P_great_self, self_great_I4P, I2P_great_self, self_great_I2P, I1P_great_self, self_great_I1P generic, public :: operator(>=) => self_great_eq_self, R8P_great_eq_self, self_great_eq_R8P, R4P_great_eq_self, self_great_eq_R4P, I8P_great_eq_self, self_great_eq_I8P, I4P_great_eq_self, self_great_eq_I4P, I2P_great_eq_self, self_great_eq_I2P, I1P_great_eq_self, self_great_eq_I1P procedure, private, pass(vec1) :: orthogonal procedure, private, pass(vec1) :: parallel procedure, private, pass(self ) :: positive_self procedure, public :: print => print_vector_self procedure, public :: save => save_vector_self procedure, private, pass(self ) :: self_div_ScalI1P procedure, private, pass(self ) :: self_div_ScalI2P procedure, private, pass(self ) :: self_div_ScalI4P procedure, private, pass(self ) :: self_div_ScalI8P procedure, private, pass(self ) :: self_div_ScalR4P procedure, private, pass(self ) :: self_div_ScalR8P procedure, private, pass(self1) :: self_div_self procedure, private, pass(self ) :: self_eq_I1P procedure, private, pass(self ) :: self_eq_I2P procedure, private, pass(self ) :: self_eq_I4P procedure, private, pass(self ) :: self_eq_I8P procedure, private, pass(self ) :: self_eq_R4P procedure, private, pass(self ) :: self_eq_R8P procedure, private, pass(self1) :: self_eq_self procedure, private, pass(self ) :: self_great_I1P procedure, private, pass(self ) :: self_great_I2P procedure, private, pass(self ) :: self_great_I4P procedure, private, pass(self ) :: self_great_I8P procedure, private, pass(self ) :: self_great_R4P procedure, private, pass(self ) :: self_great_R8P procedure, private, pass(self ) :: self_great_eq_I1P procedure, private, pass(self ) :: self_great_eq_I2P procedure, private, pass(self ) :: self_great_eq_I4P procedure, private, pass(self ) :: self_great_eq_I8P procedure, private, pass(self ) :: self_great_eq_R4P procedure, private, pass(self ) :: self_great_eq_R8P procedure, private, pass(self1) :: self_great_eq_self procedure, private, pass(self1) :: self_great_self procedure, private, pass(self ) :: self_low_I1P procedure, private, pass(self ) :: self_low_I2P procedure, private, pass(self ) :: self_low_I4P procedure, private, pass(self ) :: self_low_I8P procedure, private, pass(self ) :: self_low_R4P procedure, private, pass(self ) :: self_low_R8P procedure, private, pass(self ) :: self_low_eq_I1P procedure, private, pass(self ) :: self_low_eq_I2P procedure, private, pass(self ) :: self_low_eq_I4P procedure, private, pass(self ) :: self_low_eq_I8P procedure, private, pass(self ) :: self_low_eq_R4P procedure, private, pass(self ) :: self_low_eq_R8P procedure, private, pass(self1) :: self_low_eq_self procedure, private, pass(self1) :: self_low_self procedure, private, pass(self ) :: self_mul_ScalI1P procedure, private, pass(self ) :: self_mul_ScalI2P procedure, private, pass(self ) :: self_mul_ScalI4P procedure, private, pass(self ) :: self_mul_ScalI8P procedure, private, pass(self ) :: self_mul_ScalR4P procedure, private, pass(self ) :: self_mul_ScalR8P procedure, private, pass(self1) :: self_mul_self procedure, private, pass(self ) :: self_not_eq_I1P procedure, private, pass(self ) :: self_not_eq_I2P procedure, private, pass(self ) :: self_not_eq_I4P procedure, private, pass(self ) :: self_not_eq_I8P procedure, private, pass(self ) :: self_not_eq_R4P procedure, private, pass(self ) :: self_not_eq_R8P procedure, private, pass(self1) :: self_not_eq_self procedure, private, pass(self ) :: self_sub_ScalI1P procedure, private, pass(self ) :: self_sub_ScalI2P procedure, private, pass(self ) :: self_sub_ScalI4P procedure, private, pass(self ) :: self_sub_ScalI8P procedure, private, pass(self ) :: self_sub_ScalR4P procedure, private, pass(self ) :: self_sub_ScalR8P procedure, private, pass(self1) :: self_sub_self procedure, private, pass(self ) :: self_sum_ScalI1P procedure, private, pass(self ) :: self_sum_ScalI2P procedure, private, pass(self ) :: self_sum_ScalI4P procedure, private, pass(self ) :: self_sum_ScalI8P procedure, private, pass(self ) :: self_sum_ScalR4P procedure, private, pass(self ) :: self_sum_ScalR8P procedure, private, pass(self1) :: self_sum_self procedure, public :: set => set_vector_self procedure, public :: sq_norm => sq_norm_self type, public :: Vector_Ptr Pointer of Vector for creating array of pointers of Vector. Components Type Visibility Attributes Name Initial type( Vector ), public, pointer :: p => null() Functions private elemental function I1P_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function I1P_great_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function I1P_great_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function I1P_low_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function I1P_low_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function I1P_not_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function I2P_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function I2P_great_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function I2P_great_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function I2P_low_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function I2P_low_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function I2P_not_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function I4P_eq_self (scal, self) result(compare) @brief Procedure returns .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function I4P_great_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function I4P_great_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function I4P_low_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function I4P_low_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function I4P_not_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function I8P_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function I8P_great_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function I8P_great_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function I8P_low_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function I8P_low_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function I8P_not_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function R16P_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function R16P_great_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function R16P_great_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function R16P_low_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function R16P_low_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function R16P_not_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function R4P_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function R4P_great_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function R4P_great_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function R4P_low_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function R4P_low_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function R4P_not_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function R8P_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function R8P_great_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function R8P_great_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function R8P_low_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function R8P_low_self (scal, self) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function R8P_not_eq_self (scal, self) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value logical private elemental function ScalI1P_mul_self (scal, self) result(mul) Multiply scalar (integer I1P) for self. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function ScalI1P_sub_self (scal, self) result(sub) Subtract scalar (integer I1P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function ScalI1P_sum_self (scal, self) result(summ) Sum scalar (integer I1P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I1P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function ScalI2P_mul_self (scal, self) result(mul) Multiply scalar (integer I2P) for self. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function ScalI2P_sub_self (scal, self) result(sub) Subtract scalar (integer I2P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function ScalI2P_sum_self (scal, self) result(summ) Sum scalar (integer I2P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I2P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function ScalI4P_mul_self (scal, self) result(mul) Multiply scalar (integer I4P) for self. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function ScalI4P_sub_self (scal, self) result(sub) Subtract scalar (integer I4P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function ScalI4P_sum_self (scal, self) result(summ) Sum scalar (integer I4P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function ScalI8P_mul_self (scal, self) result(mul) Multiply scalar (integer I8P) for self. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function ScalI8P_sub_self (scal, self) result(sub) Subtract scalar (integer I8P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function ScalI8P_sum_self (scal, self) result(summ) Sum scalar (integer I8P) and self. Arguments Type Intent Optional Attributes Name integer(kind=I8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function ScalR16P_mul_self (scal, self) result(mul) Multiply scalar (real R16P) for self. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function ScalR16P_sub_self (scal, self) result(sub) Subtract scalar (real R16P) and self. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function ScalR16P_sum_self (scal, self) result(summ) Sum scalar (real R16P) and self. Arguments Type Intent Optional Attributes Name real(kind=R16P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function ScalR4P_mul_self (scal, self) result(mul) Multiply scalar (real R4P) for self. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function ScalR4P_sub_self (scal, self) result(sub) Subtract scalar (real R4P) and self. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function ScalR4P_sum_self (scal, self) result(summ) Sum scalar (real R4P) and self. Arguments Type Intent Optional Attributes Name real(kind=R4P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function ScalR8P_mul_self (scal, self) result(mul) Multiply scalar (real R8P) for self. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function ScalR8P_sub_self (scal, self) result(sub) Subtract scalar (real R8P) and self. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function ScalR8P_sum_self (scal, self) result(summ) Sum scalar (real R8P) and self. Arguments Type Intent Optional Attributes Name real(kind=R8P), intent(in) :: scal class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function crossproduct (vec1, vec2) result(cross) Compute the cross product of 2 vectors. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: vec1 First vector. type( Vector ), intent(in) :: vec2 Second vector. Return Value type( Vector ) Cross product vector. private elemental function dotproduct (vec1, vec2) result(dot) Compute the scalar (dot) product of 2 vectors. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: vec1 First vector. type( Vector ), intent(in) :: vec2 Second vector. Return Value real(kind=R8P) Dot product. public elemental function face_normal3 (pt1, pt2, pt3, norm) result(fnormal) Calculate the normal of the face defined by the 3 points vector pt1, pt2 and pt3. Arguments Type Intent Optional Attributes Name type( Vector ), intent(in) :: pt1 First face point. type( Vector ), intent(in) :: pt2 Second face point. type( Vector ), intent(in) :: pt3 Third face point. character(len=1), intent(in), optional :: norm If 'norm' is passed as argument the normal is normalized. Return Value type( Vector ) Face normal. public elemental function face_normal4 (pt1, pt2, pt3, pt4, norm) result(fnormal) Calculate the normal of the face defined by 4 points vector pt1, pt2, pt3 and pt4. Arguments Type Intent Optional Attributes Name type( Vector ), intent(in) :: pt1 First face point. type( Vector ), intent(in) :: pt2 Second face point. type( Vector ), intent(in) :: pt3 Third face point. type( Vector ), intent(in) :: pt4 Fourth face point. character(len=1), intent(in), optional :: norm If 'norm' is passed as argument the normal is normalized. Return Value type( Vector ) Face normal. private function iolen_vector_self (vec) result(iolen) Compute IO length. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: vec Vector. Return Value integer(kind=I4P) IO length. private elemental function negative_self (self) result(neg) Applay unary - to a self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self Return Value type( Vector ) public elemental function normL2 (vec) result(norm) Compute the norm L2 of a vector. Arguments Type Intent Optional Attributes Name type( Vector ), intent(in) :: vec Vector. Return Value real(kind=R8P) Norm L2. private elemental function normL2_self (vec) result(norm) Compute the norm L2 of a vector. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: vec Vector. Return Value real(kind=R8P) Norm L2. public elemental function normalize (vec) result(norm) Normalize a vector. Arguments Type Intent Optional Attributes Name type( Vector ), intent(in) :: vec Vector to be normalized. Return Value type( Vector ) Vector normalized. private elemental function normalized_self (vec) result(norm) Get a normalized copy of a vector. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: vec Vector to be normalized. Return Value type( Vector ) Normalized copy. private elemental function orthogonal (vec1, vec2) result(ortho) Compute the component of vec1 orthogonal to vec2. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: vec1 First vector. type( Vector ), intent(in) :: vec2 Second vector. Return Value type( Vector ) Component of of vec1 orthogonal to vec2. private elemental function parallel (vec1, vec2) result(paral) Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: vec1 Compute the component of vec1 parallel to vec2.\n First vector. type( Vector ), intent(in) :: vec2 Second vector. Return Value type( Vector ) Component of of vec1 parallel to vec2. private elemental function positive_self (self) result(pos) Applay unary + to a self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self Return Value type( Vector ) private elemental function self_div_ScalI1P (self, scal) result(div) Divide self for scalar (integer I1P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value type( Vector ) private elemental function self_div_ScalI2P (self, scal) result(div) Divide self for scalar (integer I2P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value type( Vector ) private elemental function self_div_ScalI4P (self, scal) result(div) Divide self for scalar (integer I4P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value type( Vector ) private elemental function self_div_ScalI8P (self, scal) result(div) Divide self for scalar (integer I8P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value type( Vector ) private elemental function self_div_ScalR16P (self, scal) result(div) Divide self for scalar (real R16P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R16P), intent(in) :: scal Return Value type( Vector ) private elemental function self_div_ScalR4P (self, scal) result(div) Divide self for scalar (real R4P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value type( Vector ) private elemental function self_div_ScalR8P (self, scal) result(div) Divide self for scalar (real R8P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value type( Vector ) private elemental function self_div_self (self1, self2) result(div) Divide self for self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 type( Vector ), intent(in) :: self2 Return Value type( Vector ) private elemental function self_eq_I1P (self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value logical private elemental function self_eq_I2P (self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value logical private elemental function self_eq_I4P (self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value logical private elemental function self_eq_I8P (self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value logical private elemental function self_eq_R16P (self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R16P), intent(in) :: scal Return Value logical private elemental function self_eq_R4P (self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value logical private elemental function self_eq_R8P (self, scal) result(compare) Return .true. if the normL2 of the self is = with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value logical private elemental function self_eq_self (self1, self2) result(compare) Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 Return .true. if the normL2 of the self1 is = with respect the normL2 of self2 and the directions of\n self1 and self2 are the same, .false. otherwise. type( Vector ), intent(in) :: self2 Return Value logical private elemental function self_great_I1P (self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value logical private elemental function self_great_I2P (self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value logical private elemental function self_great_I4P (self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value logical private elemental function self_great_I8P (self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value logical private elemental function self_great_R16P (self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R16P), intent(in) :: scal Return Value logical private elemental function self_great_R4P (self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value logical private elemental function self_great_R8P (self, scal) result(compare) Return .true. if the normL2 of the self1 is > with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value logical private elemental function self_great_eq_I1P (self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value logical private elemental function self_great_eq_I2P (self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value logical private elemental function self_great_eq_I4P (self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value logical private elemental function self_great_eq_I8P (self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value logical private elemental function self_great_eq_R16P (self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R16P), intent(in) :: scal Return Value logical private elemental function self_great_eq_R4P (self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value logical private elemental function self_great_eq_R8P (self, scal) result(compare) Return .true. if the normL2 of the self1 is >= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value logical private elemental function self_great_eq_self (self1, self2) result(compare) Return .true. if the normL2 of the self1 is >= with respect the normL2 of self2, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 type( Vector ), intent(in) :: self2 Return Value logical private elemental function self_great_self (self1, self2) result(compare) Return .true. if the normL2 of the self1 is > with respect the normL2 of self2, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 type( Vector ), intent(in) :: self2 Return Value logical private elemental function self_low_I1P (self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value logical private elemental function self_low_I2P (self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value logical private elemental function self_low_I4P (self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value logical private elemental function self_low_I8P (self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value logical private elemental function self_low_R16P (self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R16P), intent(in) :: scal Return Value logical private elemental function self_low_R4P (self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value logical private elemental function self_low_R8P (self, scal) result(compare) Return .true. if the normL2 of the self1 is < with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value logical private elemental function self_low_eq_I1P (self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value logical private elemental function self_low_eq_I2P (self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value logical private elemental function self_low_eq_I4P (self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value logical private elemental function self_low_eq_I8P (self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value logical private elemental function self_low_eq_R16P (self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R16P), intent(in) :: scal Return Value logical private elemental function self_low_eq_R4P (self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value logical private elemental function self_low_eq_R8P (self, scal) result(compare) Return .true. if the normL2 of the self1 is <= with respect the  value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value logical private elemental function self_low_eq_self (self1, self2) result(compare) Return .true. if the normL2 of the self1 is <= with respect the normL2 of self2, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 type( Vector ), intent(in) :: self2 Return Value logical private elemental function self_low_self (self1, self2) result(compare) Return .true. if the normL2 of the self1 is < with respect the normL2 of self2, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 type( Vector ), intent(in) :: self2 Return Value logical private elemental function self_mul_ScalI1P (self, scal) result(mul) Multiply self for scalar (integer I1P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value type( Vector ) private elemental function self_mul_ScalI2P (self, scal) result(mul) Multiply self for scalar (integer I2P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value type( Vector ) private elemental function self_mul_ScalI4P (self, scal) result(mul) Multiply self for scalar (integer I4P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value type( Vector ) private elemental function self_mul_ScalI8P (self, scal) result(mul) Multiply self for scalar (integer I8P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value type( Vector ) private elemental function self_mul_ScalR16P (self, scal) result(mul) Multiply self for scalar (real R16P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R16P), intent(in) :: scal Return Value type( Vector ) private elemental function self_mul_ScalR4P (self, scal) result(mul) Multiply self for scalar (real R4P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value type( Vector ) private elemental function self_mul_ScalR8P (self, scal) result(mul) Multiply self for scalar (real R8P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value type( Vector ) private elemental function self_mul_self (self1, self2) result(mul) Multiply (by components) two selfs. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 type( Vector ), intent(in) :: self2 Return Value type( Vector ) private elemental function self_not_eq_I1P (self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value logical private elemental function self_not_eq_I2P (self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value logical private elemental function self_not_eq_I4P (self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value logical private elemental function self_not_eq_I8P (self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value logical private elemental function self_not_eq_R16P (self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R16P), intent(in) :: scal Return Value logical private elemental function self_not_eq_R4P (self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value logical private elemental function self_not_eq_R8P (self, scal) result(compare) Return .true. if the normL2 of the self is /= with respect the value of scalar scal, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value logical private elemental function self_not_eq_self (self1, self2) result(compare) Return .true. if the normL2 of the self1 is /= with respect the normL2 of self2 or if the directions of self1\n and self2 are different, .false. otherwise. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 First selftor. type( Vector ), intent(in) :: self2 Second selftor. Return Value logical The result of the comparison. private elemental function self_sub_ScalI1P (self, scal) result(sub) Subtract self and scalar (integer I1P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value type( Vector ) private elemental function self_sub_ScalI2P (self, scal) result(sub) Subtract self and scalar (integer I2P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value type( Vector ) private elemental function self_sub_ScalI4P (self, scal) result(sub) Subtract self and scalar (integer I4P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value type( Vector ) private elemental function self_sub_ScalI8P (self, scal) result(sub) Subtract self and scalar (integer I8P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value type( Vector ) private elemental function self_sub_ScalR16P (self, scal) result(sub) Subtract self and scalar (real R16P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R16P), intent(in) :: scal Return Value type( Vector ) private elemental function self_sub_ScalR4P (self, scal) result(sub) Subtract self and scalar (real R4P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value type( Vector ) private elemental function self_sub_ScalR8P (self, scal) result(sub) Subtract self and scalar (real R8P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value type( Vector ) private elemental function self_sub_self (self1, self2) result(sub) Subtract self and self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 type( Vector ), intent(in) :: self2 Return Value type( Vector ) private elemental function self_sum_ScalI1P (self, scal) result(summ) Sum self and scalar (integer I1P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I1P), intent(in) :: scal Return Value type( Vector ) private elemental function self_sum_ScalI2P (self, scal) result(summ) Sum self and scalar (integer I2P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I2P), intent(in) :: scal Return Value type( Vector ) private elemental function self_sum_ScalI4P (self, scal) result(summ) Sum self and scalar (integer I4P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I4P), intent(in) :: scal Return Value type( Vector ) private elemental function self_sum_ScalI8P (self, scal) result(summ) Sum self and scalar (integer I8P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self integer(kind=I8P), intent(in) :: scal Return Value type( Vector ) private elemental function self_sum_ScalR16P (self, scal) result(summ) Sum self and scalar (real R16P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R16P), intent(in) :: scal Return Value type( Vector ) private elemental function self_sum_ScalR4P (self, scal) result(summ) Sum self and scalar (real R4P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R4P), intent(in) :: scal Return Value type( Vector ) private elemental function self_sum_ScalR8P (self, scal) result(summ) Sum self and scalar (real R8P). Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self real(kind=R8P), intent(in) :: scal Return Value type( Vector ) private elemental function self_sum_self (self1, self2) result(summ) Sum self and self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: self1 type( Vector ), intent(in) :: self2 Return Value type( Vector ) public elemental function sq_norm (vec) result(sq) Compute the square of the norm of a vector. Arguments Type Intent Optional Attributes Name type( Vector ), intent(in) :: vec Vector. Return Value real(kind=R8P) Square of the Norm. private elemental function sq_norm_self (vec) result(sq) Compute the square of the norm of a vector. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: vec Vector. Return Value real(kind=R8P) Square of the Norm. Subroutines private elemental subroutine assign_ScalI1P (self, scal) Assignment between a scalar (integer I1P) and self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: self integer(kind=I1P), intent(in) :: scal private elemental subroutine assign_ScalI2P (self, scal) Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: self Assignment between a scalar (integer I2P) and self. integer(kind=I2P), intent(in) :: scal private elemental subroutine assign_ScalI4P (self, scal) Assignment between a scalar (integer I4P) and self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: self integer(kind=I4P), intent(in) :: scal private elemental subroutine assign_ScalI8P (self, scal) Assignment between a scalar (integer I8P) and self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: self integer(kind=I8P), intent(in) :: scal private elemental subroutine assign_ScalR16P (self, scal) Assignment between a scalar (real R16P) and self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: self real(kind=R16P), intent(in) :: scal private elemental subroutine assign_ScalR4P (self, scal) Assignment between a scalar (real R4P) and self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: self real(kind=R4P), intent(in) :: scal private elemental subroutine assign_ScalR8P (self, scal) Assignment between a scalar (real R8P) and self. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: self real(kind=R8P), intent(in) :: scal private pure subroutine assign_self (self1, self2) Assignment between two selfs. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: self1 class( Vector ), intent(in) :: self2 private elemental subroutine face_normal3_self (fnormal, pt1, pt2, pt3, norm) Calculate the normal of the face defined by the 3 points vector pt1, pt2 and pt3. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: fnormal Face normal. type( Vector ), intent(in) :: pt1 First face point. type( Vector ), intent(in) :: pt2 Second face point. type( Vector ), intent(in) :: pt3 Third face point. character(len=1), intent(in), optional :: norm If 'norm' is passed as argument the normal is normalized. private elemental subroutine face_normal4_self (fnormal, pt1, pt2, pt3, pt4, norm) Calculate the normal of the face defined by 4 points vector pt1, pt2, pt3 and pt4. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: fnormal Face normal. type( Vector ), intent(in) :: pt1 First face point. type( Vector ), intent(in) :: pt2 Second face point. type( Vector ), intent(in) :: pt3 Third face point. type( Vector ), intent(in) :: pt4 Fourth face point. character(len=1), intent(in), optional :: norm If 'norm' is passed as argument the normal is normalized. private elemental subroutine init_vector_self (vec) Initialize components of Vector variable. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: vec Vector. private subroutine load_vector_self (vec, unit, pos, iostat, iomsg) Load Vector data. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: vec Vector data. integer(kind=I4P), intent(in) :: unit Logic unit. integer(kind=I8P), intent(in), optional :: pos Position specifier. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message. private elemental subroutine normalize_self (vec) Normalize a vector. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: vec Vector to be normalized. private subroutine print_vector_self (vec, unit, pref, iostat, iomsg) Print in a pretty ascii format the components of type Vector. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: vec Vector. integer(kind=I4P), intent(in), optional :: unit Logic unit. character(len=*), intent(in), optional :: pref Prefixing string for outputs. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message. private subroutine save_vector_self (vec, unit, pos, iostat, iomsg) Save Vector data. Arguments Type Intent Optional Attributes Name class( Vector ), intent(in) :: vec Vector data. integer(kind=I4P), intent(in) :: unit Logic unit. integer(kind=I8P), intent(in), optional :: pos Position specifier. integer(kind=I4P), intent(out), optional :: iostat IO error. character(len=*), intent(out), optional :: iomsg IO error message. private elemental subroutine set_vector_self (vec, x, y, z) Set components of Vector variable. Arguments Type Intent Optional Attributes Name class( Vector ), intent(inout) :: vec Vector. real(kind=R8P), intent(in), optional :: x Cartesian component in x direction. real(kind=R8P), intent(in), optional :: y Cartesian component in y direction. real(kind=R8P), intent(in), optional :: z Cartesian component in z direction.","tags":"","loc":"module/vecfor.html","title":"VecFor – FLOw"},{"text":"Uses: flow penf program~~flow_test_compressible_transformations~~UsesGraph program~flow_test_compressible_transformations flow_test_compressible_transformations module~flow flow module~flow->program~flow_test_compressible_transformations module~penf penf module~penf->program~flow_test_compressible_transformations module~flow_primitive_compressible_multispecie flow_primitive_compressible_multispecie module~penf->module~flow_primitive_compressible_multispecie module~flow_eos_object flow_eos_object module~penf->module~flow_eos_object module~flow_field_scalar_vectorial flow_field_scalar_vectorial module~penf->module~flow_field_scalar_vectorial module~flow_field_object flow_field_object module~penf->module~flow_field_object module~flow_conservative_object flow_conservative_object module~penf->module~flow_conservative_object module~flow_compressible_transformations flow_compressible_transformations module~penf->module~flow_compressible_transformations module~flow_eos_compressible flow_eos_compressible module~penf->module~flow_eos_compressible module~flow_conservative_compressible flow_conservative_compressible module~penf->module~flow_conservative_compressible module~flow_primitive_compressible flow_primitive_compressible module~penf->module~flow_primitive_compressible module~flow_primitive_object flow_primitive_object module~penf->module~flow_primitive_object module~flow_primitive_compressible_multispecie->module~flow module~flow_eos_object->module~flow module~flow_eos_object->module~flow_primitive_compressible_multispecie module~flow_eos_object->module~flow_conservative_object module~flow_eos_object->module~flow_compressible_transformations module~flow_eos_object->module~flow_eos_compressible module~flow_eos_object->module~flow_conservative_compressible module~flow_eos_object->module~flow_primitive_compressible module~flow_eos_object->module~flow_primitive_object module~flow_field_scalar_vectorial->module~flow module~flow_field_object->module~flow module~flow_field_object->module~flow_primitive_compressible_multispecie module~flow_field_object->module~flow_field_scalar_vectorial module~flow_field_object->module~flow_conservative_object module~flow_field_object->module~flow_conservative_compressible module~flow_field_object->module~flow_primitive_compressible module~flow_field_object->module~flow_primitive_object module~flow_conservative_object->module~flow module~flow_conservative_object->module~flow_conservative_compressible module~flow_compressible_transformations->module~flow module~flow_eos_compressible->module~flow module~flow_conservative_compressible->module~flow module~flow_conservative_compressible->module~flow_compressible_transformations module~flow_primitive_compressible->module~flow module~flow_primitive_compressible->module~flow_compressible_transformations module~flow_primitive_object->module~flow module~flow_primitive_object->module~flow_primitive_compressible_multispecie module~flow_primitive_object->module~flow_primitive_compressible module~vecfor VecFor module~vecfor->module~flow_primitive_compressible_multispecie module~vecfor->module~flow_field_scalar_vectorial module~vecfor->module~flow_conservative_object module~vecfor->module~flow_compressible_transformations module~vecfor->module~flow_conservative_compressible module~vecfor->module~flow_primitive_compressible module~vecfor->module~flow_primitive_object iso_fortran_env iso_fortran_env iso_fortran_env->module~flow_conservative_compressible iso_fortran_env->module~flow_primitive_compressible iso_fortran_env->module~vecfor module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf var panprogramflow_test_compressible_transformationsUsesGraph = svgPanZoom('#programflow_test_compressible_transformationsUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FLOw test. Calls program~~flow_test_compressible_transformations~~CallsGraph program~flow_test_compressible_transformations flow_test_compressible_transformations proc~conservative_to_primitive_compressible conservative_to_primitive_compressible program~flow_test_compressible_transformations->proc~conservative_to_primitive_compressible proc~primitive_to_conservative_compressible primitive_to_conservative_compressible program~flow_test_compressible_transformations->proc~primitive_to_conservative_compressible Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Variables are_tests_passed eos p u Source Code flow_test_compressible_transformations Variables Type Attributes Name Initial logical :: are_tests_passed (2) List of passed tests. type( eos_compressible ) :: eos An equation of state. type( primitive_compressible ) :: p A primitive compressible instance. type( conservative_compressible ) :: u A conservative compressible instance. Source Code program flow_test_compressible_transformations !< FLOw test. use flow , only : eos_compressible , conservative_compressible , primitive_compressible , & conservative_to_primitive_compressible , primitive_to_conservative_compressible use penf , only : R8P , ZeroR8 implicit none type ( eos_compressible ) :: eos !< An equation of state. type ( primitive_compressible ) :: p !< A primitive compressible instance. type ( conservative_compressible ) :: u !< A conservative compressible instance. logical :: are_tests_passed ( 2 ) !< List of passed tests. are_tests_passed = . false . eos = eos_compressible ( cp = 104 0.004_R8P , cv = 74 2.86_R8P ) u = conservative_compressible ( density = 1._R8P , energy = 2.5_R8P ) p = conservative_to_primitive_compressible ( conservative = u , eos = eos ) are_tests_passed ( 1 ) = ( p % density >= 1._R8P - ZeroR8 ). and .( p % density <= 1._R8P + ZeroR8 ). and . & ( p % velocity >= 0._R8P - ZeroR8 ). and .( p % velocity <= 0._R8P + ZeroR8 ). and . & ( p % pressure >= 1._R8P - ZeroR8 ). and .( p % pressure <= 1._R8P + ZeroR8 ) print \"(A,L1)\" , 'u to p, is done right? ' , are_tests_passed ( 1 ) p = primitive_compressible ( density = 1._R8P , pressure = 1._R8P ) u = primitive_to_conservative_compressible ( primitive = p , eos = eos ) are_tests_passed ( 2 ) = ( u % density >= 1._R8P - ZeroR8 ). and .( u % density <= 1._R8P + ZeroR8 ). and . & ( u % momentum >= 0._R8P - ZeroR8 ). and .( u % momentum <= 0._R8P + ZeroR8 ). and . & ( u % energy >= 2.5_R8P - ZeroR8 ). and .( u % energy <= 2.5_R8P + ZeroR8 ) print \"(A,L1)\" , 'p to u, is done right? ' , are_tests_passed ( 2 ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( are_tests_passed ) endprogram flow_test_compressible_transformations","tags":"","loc":"program/flow_test_compressible_transformations.html","title":"flow_test_compressible_transformations – FLOw"},{"text":"Uses: flow penf VecFor program~~flow_test_conservative_compressible_add~~UsesGraph program~flow_test_conservative_compressible_add flow_test_conservative_compressible_add module~flow flow module~flow->program~flow_test_conservative_compressible_add module~vecfor VecFor module~vecfor->program~flow_test_conservative_compressible_add module~flow_primitive_compressible_multispecie flow_primitive_compressible_multispecie module~vecfor->module~flow_primitive_compressible_multispecie module~flow_field_scalar_vectorial flow_field_scalar_vectorial module~vecfor->module~flow_field_scalar_vectorial module~flow_conservative_object flow_conservative_object module~vecfor->module~flow_conservative_object module~flow_compressible_transformations flow_compressible_transformations module~vecfor->module~flow_compressible_transformations module~flow_conservative_compressible flow_conservative_compressible module~vecfor->module~flow_conservative_compressible module~flow_primitive_compressible flow_primitive_compressible module~vecfor->module~flow_primitive_compressible module~flow_primitive_object flow_primitive_object module~vecfor->module~flow_primitive_object module~penf penf module~penf->program~flow_test_conservative_compressible_add module~penf->module~flow_primitive_compressible_multispecie module~flow_eos_object flow_eos_object module~penf->module~flow_eos_object module~penf->module~flow_field_scalar_vectorial module~flow_field_object flow_field_object module~penf->module~flow_field_object module~penf->module~flow_conservative_object module~penf->module~flow_compressible_transformations module~flow_eos_compressible flow_eos_compressible module~penf->module~flow_eos_compressible module~penf->module~flow_conservative_compressible module~penf->module~flow_primitive_compressible module~penf->module~flow_primitive_object module~flow_primitive_compressible_multispecie->module~flow module~flow_eos_object->module~flow module~flow_eos_object->module~flow_primitive_compressible_multispecie module~flow_eos_object->module~flow_conservative_object module~flow_eos_object->module~flow_compressible_transformations module~flow_eos_object->module~flow_eos_compressible module~flow_eos_object->module~flow_conservative_compressible module~flow_eos_object->module~flow_primitive_compressible module~flow_eos_object->module~flow_primitive_object module~flow_field_scalar_vectorial->module~flow module~flow_field_object->module~flow module~flow_field_object->module~flow_primitive_compressible_multispecie module~flow_field_object->module~flow_field_scalar_vectorial module~flow_field_object->module~flow_conservative_object module~flow_field_object->module~flow_conservative_compressible module~flow_field_object->module~flow_primitive_compressible module~flow_field_object->module~flow_primitive_object module~flow_conservative_object->module~flow module~flow_conservative_object->module~flow_conservative_compressible module~flow_compressible_transformations->module~flow module~flow_eos_compressible->module~flow module~flow_conservative_compressible->module~flow module~flow_conservative_compressible->module~flow_compressible_transformations module~flow_primitive_compressible->module~flow module~flow_primitive_compressible->module~flow_compressible_transformations module~flow_primitive_object->module~flow module~flow_primitive_object->module~flow_primitive_compressible_multispecie module~flow_primitive_object->module~flow_primitive_compressible iso_fortran_env iso_fortran_env iso_fortran_env->module~vecfor iso_fortran_env->module~flow_conservative_compressible iso_fortran_env->module~flow_primitive_compressible module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf var panprogramflow_test_conservative_compressible_addUsesGraph = svgPanZoom('#programflow_test_conservative_compressible_addUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FLOw test. Variables conservative1 conservative2 conservative3 momentum test_passed Source Code flow_test_conservative_compressible_add Variables Type Attributes Name Initial type( conservative_compressible ) :: conservative1 A conservative object. type( conservative_compressible ) :: conservative2 A conservative object. type( conservative_compressible ) :: conservative3 A conservative object. type(vector) :: momentum A vector object. logical :: test_passed (2) List of passed tests. Source Code program flow_test_conservative_compressible_add !< FLOw test. use flow , only : conservative_compressible use penf , only : R8P use vecfor , only : vector implicit none type ( conservative_compressible ) :: conservative1 !< A conservative object. type ( conservative_compressible ) :: conservative2 !< A conservative object. type ( conservative_compressible ) :: conservative3 !< A conservative object. type ( vector ) :: momentum !< A vector object. logical :: test_passed ( 2 ) !< List of passed tests. test_passed = . false . momentum = 1._R8P conservative1 = conservative_compressible ( density = 0.125_R8P , momentum = momentum , energy = 1._R8P ) momentum = 2._R8P conservative2 = conservative_compressible ( density = 1._R8P , momentum = momentum , energy = 1._R8P ) conservative3 = conservative1 + conservative2 test_passed ( 1 ) = conservative3 == ( conservative1 + conservative2 ) print \"(A,F6.3)\" , 'density  => 0.125  + 1   = ' , conservative3 % density print \"(A,3(F6.3,1X))\" , 'momentum => 1      + 2   = ' , conservative3 % momentum print \"(A,F6.3)\" , 'energy   => 1      + 1   = ' , conservative3 % energy momentum = - 1._R8P conservative1 = conservative_compressible ( density = 0.125_R8P , momentum = momentum , energy = 1._R8P ) conservative2 = + conservative1 test_passed ( 2 ) = conservative2 == conservative1 print \"(A,F6.3)\" , 'density  => + (0.125) = ' , conservative2 % density print \"(A,3(F6.3,1X))\" , 'momentum => + (-1)    = ' , conservative2 % momentum print \"(A,F6.3)\" , 'energy   => + (1)     = ' , conservative2 % energy print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram flow_test_conservative_compressible_add","tags":"","loc":"program/flow_test_conservative_compressible_add.html","title":"flow_test_conservative_compressible_add – FLOw"},{"text":"Uses: flow penf VecFor program~~flow_test_conservative_compressible_assign~~UsesGraph program~flow_test_conservative_compressible_assign flow_test_conservative_compressible_assign module~flow flow module~flow->program~flow_test_conservative_compressible_assign module~vecfor VecFor module~vecfor->program~flow_test_conservative_compressible_assign module~flow_primitive_compressible_multispecie flow_primitive_compressible_multispecie module~vecfor->module~flow_primitive_compressible_multispecie module~flow_field_scalar_vectorial flow_field_scalar_vectorial module~vecfor->module~flow_field_scalar_vectorial module~flow_conservative_object flow_conservative_object module~vecfor->module~flow_conservative_object module~flow_compressible_transformations flow_compressible_transformations module~vecfor->module~flow_compressible_transformations module~flow_conservative_compressible flow_conservative_compressible module~vecfor->module~flow_conservative_compressible module~flow_primitive_compressible flow_primitive_compressible module~vecfor->module~flow_primitive_compressible module~flow_primitive_object flow_primitive_object module~vecfor->module~flow_primitive_object module~penf penf module~penf->program~flow_test_conservative_compressible_assign module~penf->module~flow_primitive_compressible_multispecie module~flow_eos_object flow_eos_object module~penf->module~flow_eos_object module~penf->module~flow_field_scalar_vectorial module~flow_field_object flow_field_object module~penf->module~flow_field_object module~penf->module~flow_conservative_object module~penf->module~flow_compressible_transformations module~flow_eos_compressible flow_eos_compressible module~penf->module~flow_eos_compressible module~penf->module~flow_conservative_compressible module~penf->module~flow_primitive_compressible module~penf->module~flow_primitive_object module~flow_primitive_compressible_multispecie->module~flow module~flow_eos_object->module~flow module~flow_eos_object->module~flow_primitive_compressible_multispecie module~flow_eos_object->module~flow_conservative_object module~flow_eos_object->module~flow_compressible_transformations module~flow_eos_object->module~flow_eos_compressible module~flow_eos_object->module~flow_conservative_compressible module~flow_eos_object->module~flow_primitive_compressible module~flow_eos_object->module~flow_primitive_object module~flow_field_scalar_vectorial->module~flow module~flow_field_object->module~flow module~flow_field_object->module~flow_primitive_compressible_multispecie module~flow_field_object->module~flow_field_scalar_vectorial module~flow_field_object->module~flow_conservative_object module~flow_field_object->module~flow_conservative_compressible module~flow_field_object->module~flow_primitive_compressible module~flow_field_object->module~flow_primitive_object module~flow_conservative_object->module~flow module~flow_conservative_object->module~flow_conservative_compressible module~flow_compressible_transformations->module~flow module~flow_eos_compressible->module~flow module~flow_conservative_compressible->module~flow module~flow_conservative_compressible->module~flow_compressible_transformations module~flow_primitive_compressible->module~flow module~flow_primitive_compressible->module~flow_compressible_transformations module~flow_primitive_object->module~flow module~flow_primitive_object->module~flow_primitive_compressible_multispecie module~flow_primitive_object->module~flow_primitive_compressible iso_fortran_env iso_fortran_env iso_fortran_env->module~vecfor iso_fortran_env->module~flow_conservative_compressible iso_fortran_env->module~flow_primitive_compressible module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf var panprogramflow_test_conservative_compressible_assignUsesGraph = svgPanZoom('#programflow_test_conservative_compressible_assignUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FLOw test. Variables conservative1 conservative2 momentum test_passed Source Code flow_test_conservative_compressible_assign Variables Type Attributes Name Initial type( conservative_compressible ) :: conservative1 A conservative object. type( conservative_compressible ) :: conservative2 A conservative object. type(vector) :: momentum A vector object. logical :: test_passed (2) List of passed tests. Source Code program flow_test_conservative_compressible_assign !< FLOw test. use flow , only : conservative_compressible use penf , only : R8P use vecfor , only : vector implicit none type ( conservative_compressible ) :: conservative1 !< A conservative object. type ( conservative_compressible ) :: conservative2 !< A conservative object. type ( vector ) :: momentum !< A vector object. logical :: test_passed ( 2 ) !< List of passed tests. test_passed = . false . conservative1 = 0.125_R8P test_passed ( 1 ) = ( conservative1 % density == 0.125_R8P ). and . & ( conservative1 % momentum % x == 0.125_R8P ). and . & ( conservative1 % momentum % y == 0.125_R8P ). and . & ( conservative1 % momentum % z == 0.125_R8P ). and . & ( conservative1 % energy == 0.125_R8P ) print \"(A,F6.3)\" , 'density   = ' , conservative1 % density print \"(A,3(F6.3,1X))\" , 'momentum  = ' , conservative1 % momentum print \"(A,F6.3)\" , 'energy    = ' , conservative1 % energy momentum = 1._R8P conservative1 = conservative_compressible ( density = 0.125_R8P , momentum = momentum , energy = 2._R8P ) conservative2 = conservative1 test_passed ( 2 ) = conservative1 == conservative2 print \"(A)\" , '' print \"(A,F6.3)\" , 'density   = ' , conservative2 % density print \"(A,3(F6.3,1X))\" , 'momentum  = ' , conservative2 % momentum print \"(A,F6.3)\" , 'energy    = ' , conservative2 % energy print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram flow_test_conservative_compressible_assign","tags":"","loc":"program/flow_test_conservative_compressible_assign.html","title":"flow_test_conservative_compressible_assign – FLOw"},{"text":"Uses: flow penf VecFor program~~flow_test_conservative_compressible_div~~UsesGraph program~flow_test_conservative_compressible_div flow_test_conservative_compressible_div module~flow flow module~flow->program~flow_test_conservative_compressible_div module~vecfor VecFor module~vecfor->program~flow_test_conservative_compressible_div module~flow_primitive_compressible_multispecie flow_primitive_compressible_multispecie module~vecfor->module~flow_primitive_compressible_multispecie module~flow_field_scalar_vectorial flow_field_scalar_vectorial module~vecfor->module~flow_field_scalar_vectorial module~flow_conservative_object flow_conservative_object module~vecfor->module~flow_conservative_object module~flow_compressible_transformations flow_compressible_transformations module~vecfor->module~flow_compressible_transformations module~flow_conservative_compressible flow_conservative_compressible module~vecfor->module~flow_conservative_compressible module~flow_primitive_compressible flow_primitive_compressible module~vecfor->module~flow_primitive_compressible module~flow_primitive_object flow_primitive_object module~vecfor->module~flow_primitive_object module~penf penf module~penf->program~flow_test_conservative_compressible_div module~penf->module~flow_primitive_compressible_multispecie module~flow_eos_object flow_eos_object module~penf->module~flow_eos_object module~penf->module~flow_field_scalar_vectorial module~flow_field_object flow_field_object module~penf->module~flow_field_object module~penf->module~flow_conservative_object module~penf->module~flow_compressible_transformations module~flow_eos_compressible flow_eos_compressible module~penf->module~flow_eos_compressible module~penf->module~flow_conservative_compressible module~penf->module~flow_primitive_compressible module~penf->module~flow_primitive_object module~flow_primitive_compressible_multispecie->module~flow module~flow_eos_object->module~flow module~flow_eos_object->module~flow_primitive_compressible_multispecie module~flow_eos_object->module~flow_conservative_object module~flow_eos_object->module~flow_compressible_transformations module~flow_eos_object->module~flow_eos_compressible module~flow_eos_object->module~flow_conservative_compressible module~flow_eos_object->module~flow_primitive_compressible module~flow_eos_object->module~flow_primitive_object module~flow_field_scalar_vectorial->module~flow module~flow_field_object->module~flow module~flow_field_object->module~flow_primitive_compressible_multispecie module~flow_field_object->module~flow_field_scalar_vectorial module~flow_field_object->module~flow_conservative_object module~flow_field_object->module~flow_conservative_compressible module~flow_field_object->module~flow_primitive_compressible module~flow_field_object->module~flow_primitive_object module~flow_conservative_object->module~flow module~flow_conservative_object->module~flow_conservative_compressible module~flow_compressible_transformations->module~flow module~flow_eos_compressible->module~flow module~flow_conservative_compressible->module~flow module~flow_conservative_compressible->module~flow_compressible_transformations module~flow_primitive_compressible->module~flow module~flow_primitive_compressible->module~flow_compressible_transformations module~flow_primitive_object->module~flow module~flow_primitive_object->module~flow_primitive_compressible_multispecie module~flow_primitive_object->module~flow_primitive_compressible iso_fortran_env iso_fortran_env iso_fortran_env->module~vecfor iso_fortran_env->module~flow_conservative_compressible iso_fortran_env->module~flow_primitive_compressible module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf var panprogramflow_test_conservative_compressible_divUsesGraph = svgPanZoom('#programflow_test_conservative_compressible_divUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FLOw test. Calls program~~flow_test_conservative_compressible_div~~CallsGraph program~flow_test_conservative_compressible_div flow_test_conservative_compressible_div proc~print_error print_error program~flow_test_conservative_compressible_div->proc~print_error Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Variables conservative1 conservative2 conservative3 momentum test_passed Subroutines print_error Source Code flow_test_conservative_compressible_div Variables Type Attributes Name Initial type( conservative_compressible ) :: conservative1 A conservative object. type( conservative_compressible ) :: conservative2 A conservative object. type( conservative_compressible ) :: conservative3 A conservative object. type(vector) :: momentum A vector object. logical :: test_passed (3) List of passed tests. Subroutines subroutine print_error (test, is_test_passed) Print error message if test is failed. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: test Test description. logical, intent(in) :: is_test_passed Test result. Source Code program flow_test_conservative_compressible_div !< FLOw test. use flow , only : conservative_compressible use penf , only : I4P , R8P use vecfor , only : vector implicit none type ( conservative_compressible ) :: conservative1 !< A conservative object. type ( conservative_compressible ) :: conservative2 !< A conservative object. type ( conservative_compressible ) :: conservative3 !< A conservative object. type ( vector ) :: momentum !< A vector object. logical :: test_passed ( 3 ) !< List of passed tests. test_passed = . false . momentum = 1._R8P conservative1 = conservative_compressible ( density = 0.125_R8P , momentum = momentum , energy = 1._R8P ) momentum = 2._R8P conservative2 = conservative_compressible ( density = 1._R8P , momentum = momentum , energy = 1._R8P ) conservative3 = conservative1 / conservative2 test_passed ( 1 ) = conservative3 == ( conservative1 / conservative2 ) print \"(A,F6.3)\" , 'density   => 0.125  / 1   = ' , conservative3 % density print \"(A,3(F6.3,1X))\" , 'momentum  => 1      / 2   = ' , conservative3 % momentum print \"(A,F6.3)\" , 'energy    => 1      / 1   = ' , conservative3 % energy call print_error ( test = 'conservative3 = conservative1 / conservative2' , is_test_passed = test_passed ( 1 )) conservative3 = conservative1 / 2._R8P test_passed ( 2 ) = conservative3 == ( conservative1 / 2._R8P ) print \"(A)\" , '' print \"(A,F6.3)\" , 'density   => 0.125  / 2.0 = ' , conservative3 % density print \"(A,3(F6.3,1X))\" , 'momentum  => 1      / 2.0 = ' , conservative3 % momentum print \"(A,F6.3)\" , 'energy    => 1      / 2.0 = ' , conservative3 % energy call print_error ( test = 'conservative3 = conservative1 / 2.0' , is_test_passed = test_passed ( 2 )) conservative3 = conservative1 / 2_I4P test_passed ( 3 ) = conservative3 == ( conservative1 / 2_I4P ) print \"(A)\" , '' print \"(A,F6.3)\" , 'density   => 0.125  / 2 = ' , conservative3 % density print \"(A,3(F6.3,1X))\" , 'momentum  => 1      / 2 = ' , conservative3 % momentum print \"(A,F6.3)\" , 'energy    => 1      / 2 = ' , conservative3 % energy call print_error ( test = 'conservative3 = conservative1 / 2' , is_test_passed = test_passed ( 3 )) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) contains subroutine print_error ( test , is_test_passed ) !< Print error message if test is failed. character ( * ), intent ( in ) :: test !< Test description. logical , intent ( in ) :: is_test_passed !< Test result. if (. not . is_test_passed ) then print * , '\"' // test // '\" failed!' print * , 'conservative1:' print \"(A,F6.3)\" , '  density   = ' , conservative1 % density print \"(A,3(F6.3,1X))\" , '  momentum  = ' , conservative1 % momentum print \"(A,F6.3)\" , '  energy    = ' , conservative1 % energy print * , 'conservative2:' print \"(A,F6.3)\" , '  density   = ' , conservative2 % density print \"(A,3(F6.3,1X))\" , '  momentum  = ' , conservative2 % momentum print \"(A,F6.3)\" , '  energy    = ' , conservative2 % energy print * , 'conservative3:' print \"(A,F6.3)\" , '  density   = ' , conservative3 % density print \"(A,3(F6.3,1X))\" , '  momentum  = ' , conservative3 % momentum print \"(A,F6.3)\" , '  energy    = ' , conservative3 % energy endif endsubroutine print_error endprogram flow_test_conservative_compressible_div","tags":"","loc":"program/flow_test_conservative_compressible_div.html","title":"flow_test_conservative_compressible_div – FLOw"},{"text":"Uses: flow penf VecFor program~~flow_test_conservative_compressible_eq~~UsesGraph program~flow_test_conservative_compressible_eq flow_test_conservative_compressible_eq module~flow flow module~flow->program~flow_test_conservative_compressible_eq module~vecfor VecFor module~vecfor->program~flow_test_conservative_compressible_eq module~flow_primitive_compressible_multispecie flow_primitive_compressible_multispecie module~vecfor->module~flow_primitive_compressible_multispecie module~flow_field_scalar_vectorial flow_field_scalar_vectorial module~vecfor->module~flow_field_scalar_vectorial module~flow_conservative_object flow_conservative_object module~vecfor->module~flow_conservative_object module~flow_compressible_transformations flow_compressible_transformations module~vecfor->module~flow_compressible_transformations module~flow_conservative_compressible flow_conservative_compressible module~vecfor->module~flow_conservative_compressible module~flow_primitive_compressible flow_primitive_compressible module~vecfor->module~flow_primitive_compressible module~flow_primitive_object flow_primitive_object module~vecfor->module~flow_primitive_object module~penf penf module~penf->program~flow_test_conservative_compressible_eq module~penf->module~flow_primitive_compressible_multispecie module~flow_eos_object flow_eos_object module~penf->module~flow_eos_object module~penf->module~flow_field_scalar_vectorial module~flow_field_object flow_field_object module~penf->module~flow_field_object module~penf->module~flow_conservative_object module~penf->module~flow_compressible_transformations module~flow_eos_compressible flow_eos_compressible module~penf->module~flow_eos_compressible module~penf->module~flow_conservative_compressible module~penf->module~flow_primitive_compressible module~penf->module~flow_primitive_object module~flow_primitive_compressible_multispecie->module~flow module~flow_eos_object->module~flow module~flow_eos_object->module~flow_primitive_compressible_multispecie module~flow_eos_object->module~flow_conservative_object module~flow_eos_object->module~flow_compressible_transformations module~flow_eos_object->module~flow_eos_compressible module~flow_eos_object->module~flow_conservative_compressible module~flow_eos_object->module~flow_primitive_compressible module~flow_eos_object->module~flow_primitive_object module~flow_field_scalar_vectorial->module~flow module~flow_field_object->module~flow module~flow_field_object->module~flow_primitive_compressible_multispecie module~flow_field_object->module~flow_field_scalar_vectorial module~flow_field_object->module~flow_conservative_object module~flow_field_object->module~flow_conservative_compressible module~flow_field_object->module~flow_primitive_compressible module~flow_field_object->module~flow_primitive_object module~flow_conservative_object->module~flow module~flow_conservative_object->module~flow_conservative_compressible module~flow_compressible_transformations->module~flow module~flow_eos_compressible->module~flow module~flow_conservative_compressible->module~flow module~flow_conservative_compressible->module~flow_compressible_transformations module~flow_primitive_compressible->module~flow module~flow_primitive_compressible->module~flow_compressible_transformations module~flow_primitive_object->module~flow module~flow_primitive_object->module~flow_primitive_compressible_multispecie module~flow_primitive_object->module~flow_primitive_compressible iso_fortran_env iso_fortran_env iso_fortran_env->module~vecfor iso_fortran_env->module~flow_conservative_compressible iso_fortran_env->module~flow_primitive_compressible module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf var panprogramflow_test_conservative_compressible_eqUsesGraph = svgPanZoom('#programflow_test_conservative_compressible_eqUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FLOw test. Variables conservative1 conservative2 momentum test_passed Source Code flow_test_conservative_compressible_eq Variables Type Attributes Name Initial type( conservative_compressible ) :: conservative1 A conservative object. type( conservative_compressible ) :: conservative2 A conservative object. type(vector) :: momentum A vector object. logical :: test_passed (5) List of passed tests. Source Code program flow_test_conservative_compressible_eq !< FLOw test. use flow , only : conservative_compressible use penf , only : R8P use vecfor , only : vector implicit none type ( conservative_compressible ) :: conservative1 !< A conservative object. type ( conservative_compressible ) :: conservative2 !< A conservative object. type ( vector ) :: momentum !< A vector object. logical :: test_passed ( 5 ) !< List of passed tests. test_passed = . false . momentum = 1._R8P conservative1 = conservative_compressible ( density = 0.125_R8P , momentum = momentum , energy = 1._R8P ) momentum = 1._R8P conservative2 = conservative_compressible ( density = 1._R8P , momentum = momentum , energy = 1._R8P ) test_passed ( 1 ) = ( conservative1 == conservative2 ). eqv .(. false .) print \"(A,L1)\" , 'density  => 0.125 /= 1 = ' , test_passed ( 1 ) momentum = 1._R8P conservative1 = conservative_compressible ( density = 0.125_R8P , momentum = momentum , energy = 1._R8P ) momentum = 2._R8P conservative2 = conservative_compressible ( density = 0.125_R8P , momentum = momentum , energy = 1._R8P ) test_passed ( 2 ) = ( conservative1 == conservative2 ). eqv .(. false .) print \"(A,L1)\" , 'momentum => 1     /= 2 = ' , test_passed ( 2 ) momentum = 1._R8P conservative1 = conservative_compressible ( density = 0.125_R8P , momentum = momentum , energy = 1._R8P ) momentum = 2._R8P conservative2 = conservative_compressible ( density = 0.125_R8P , momentum = momentum , energy = 2._R8P ) test_passed ( 3 ) = ( conservative1 == conservative2 ). eqv .(. false .) print \"(A,L1)\" , 'energy   => 1     /= 2 = ' , test_passed ( 3 ) momentum = 1._R8P conservative1 = conservative_compressible ( density = 0.125_R8P , momentum = momentum , energy = 1._R8P ) momentum = 2._R8P conservative2 = conservative_compressible ( density = 1._R8P , momentum = momentum , energy = 2._R8P ) test_passed ( 4 ) = ( conservative1 == conservative2 ). eqv .(. false .) print \"(A)\" , new_line ( 'a' ) // 'all together' print \"(A,L1)\" , 'density  => 0.125 /= 1 = ' , test_passed ( 4 ) print \"(A,L1)\" , 'momentum => 1     /= 2 = ' , test_passed ( 4 ) print \"(A,L1)\" , 'energy   => 1     /= 2 = ' , test_passed ( 4 ) momentum = 1._R8P conservative1 = conservative_compressible ( density = 1._R8P , momentum = momentum , energy = 1._R8P ) momentum = 1._R8P conservative2 = conservative_compressible ( density = 1._R8P , momentum = momentum , energy = 1._R8P ) test_passed ( 5 ) = ( conservative1 == conservative2 ). eqv .(. true .) print \"(A)\" , new_line ( 'a' ) // 'all together true' print \"(A,L1)\" , 'density  => 1 == 1 = ' , test_passed ( 5 ) print \"(A,L1)\" , 'momentum => 1 == 1 = ' , test_passed ( 5 ) print \"(A,L1)\" , 'energy   => 1 == 1 = ' , test_passed ( 5 ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram flow_test_conservative_compressible_eq","tags":"","loc":"program/flow_test_conservative_compressible_eq.html","title":"flow_test_conservative_compressible_eq – FLOw"},{"text":"Uses: flow penf VecFor program~~flow_test_conservative_compressible_mul~~UsesGraph program~flow_test_conservative_compressible_mul flow_test_conservative_compressible_mul module~flow flow module~flow->program~flow_test_conservative_compressible_mul module~vecfor VecFor module~vecfor->program~flow_test_conservative_compressible_mul module~flow_primitive_compressible_multispecie flow_primitive_compressible_multispecie module~vecfor->module~flow_primitive_compressible_multispecie module~flow_field_scalar_vectorial flow_field_scalar_vectorial module~vecfor->module~flow_field_scalar_vectorial module~flow_conservative_object flow_conservative_object module~vecfor->module~flow_conservative_object module~flow_compressible_transformations flow_compressible_transformations module~vecfor->module~flow_compressible_transformations module~flow_conservative_compressible flow_conservative_compressible module~vecfor->module~flow_conservative_compressible module~flow_primitive_compressible flow_primitive_compressible module~vecfor->module~flow_primitive_compressible module~flow_primitive_object flow_primitive_object module~vecfor->module~flow_primitive_object module~penf penf module~penf->program~flow_test_conservative_compressible_mul module~penf->module~flow_primitive_compressible_multispecie module~flow_eos_object flow_eos_object module~penf->module~flow_eos_object module~penf->module~flow_field_scalar_vectorial module~flow_field_object flow_field_object module~penf->module~flow_field_object module~penf->module~flow_conservative_object module~penf->module~flow_compressible_transformations module~flow_eos_compressible flow_eos_compressible module~penf->module~flow_eos_compressible module~penf->module~flow_conservative_compressible module~penf->module~flow_primitive_compressible module~penf->module~flow_primitive_object module~flow_primitive_compressible_multispecie->module~flow module~flow_eos_object->module~flow module~flow_eos_object->module~flow_primitive_compressible_multispecie module~flow_eos_object->module~flow_conservative_object module~flow_eos_object->module~flow_compressible_transformations module~flow_eos_object->module~flow_eos_compressible module~flow_eos_object->module~flow_conservative_compressible module~flow_eos_object->module~flow_primitive_compressible module~flow_eos_object->module~flow_primitive_object module~flow_field_scalar_vectorial->module~flow module~flow_field_object->module~flow module~flow_field_object->module~flow_primitive_compressible_multispecie module~flow_field_object->module~flow_field_scalar_vectorial module~flow_field_object->module~flow_conservative_object module~flow_field_object->module~flow_conservative_compressible module~flow_field_object->module~flow_primitive_compressible module~flow_field_object->module~flow_primitive_object module~flow_conservative_object->module~flow module~flow_conservative_object->module~flow_conservative_compressible module~flow_compressible_transformations->module~flow module~flow_eos_compressible->module~flow module~flow_conservative_compressible->module~flow module~flow_conservative_compressible->module~flow_compressible_transformations module~flow_primitive_compressible->module~flow module~flow_primitive_compressible->module~flow_compressible_transformations module~flow_primitive_object->module~flow module~flow_primitive_object->module~flow_primitive_compressible_multispecie module~flow_primitive_object->module~flow_primitive_compressible iso_fortran_env iso_fortran_env iso_fortran_env->module~vecfor iso_fortran_env->module~flow_conservative_compressible iso_fortran_env->module~flow_primitive_compressible module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf var panprogramflow_test_conservative_compressible_mulUsesGraph = svgPanZoom('#programflow_test_conservative_compressible_mulUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FLOw test. Calls program~~flow_test_conservative_compressible_mul~~CallsGraph program~flow_test_conservative_compressible_mul flow_test_conservative_compressible_mul proc~print_error~2 print_error program~flow_test_conservative_compressible_mul->proc~print_error~2 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Variables conservative1 conservative2 conservative3 momentum test_passed Subroutines print_error Source Code flow_test_conservative_compressible_mul Variables Type Attributes Name Initial type( conservative_compressible ) :: conservative1 A conservative object. type( conservative_compressible ) :: conservative2 A conservative object. type( conservative_compressible ) :: conservative3 A conservative object. type(vector) :: momentum A vector object. logical :: test_passed (5) List of passed tests. Subroutines subroutine print_error (test, is_test_passed) Print error message if test is failed. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: test Test description. logical, intent(in) :: is_test_passed Test result. Source Code program flow_test_conservative_compressible_mul !< FLOw test. use flow , only : conservative_compressible use penf , only : I4P , R8P use vecfor , only : vector implicit none type ( conservative_compressible ) :: conservative1 !< A conservative object. type ( conservative_compressible ) :: conservative2 !< A conservative object. type ( conservative_compressible ) :: conservative3 !< A conservative object. type ( vector ) :: momentum !< A vector object. logical :: test_passed ( 5 ) !< List of passed tests. test_passed = . false . momentum = 1._R8P conservative1 = conservative_compressible ( density = 0.125_R8P , momentum = momentum , energy = 1._R8P ) momentum = 2._R8P conservative2 = conservative_compressible ( density = 1._R8P , momentum = momentum , energy = 1._R8P ) conservative3 = conservative1 * conservative2 test_passed ( 1 ) = conservative3 == ( conservative1 * conservative2 ) print \"(A,F6.3)\" , 'density   => 0.125  * 1 = ' , conservative3 % density print \"(A,3(F6.3,1X))\" , 'momentum  => 1      * 2 = ' , conservative3 % momentum print \"(A,F6.3)\" , 'energy    => 1      * 1 = ' , conservative3 % energy call print_error ( test = 'conservative3 = conservative1 * conservative2' , is_test_passed = test_passed ( 1 )) conservative3 = 2._R8P * conservative1 test_passed ( 2 ) = conservative3 == ( 2._R8P * conservative1 ) print \"(A)\" , '' print \"(A,F6.3)\" , 'density   => 2.0 * 0.125  = ' , conservative3 % density print \"(A,3(F6.3,1X))\" , 'momentum  => 2.0 * 1      = ' , conservative3 % momentum print \"(A,F6.3)\" , 'energy    => 2.0 * 1      = ' , conservative3 % energy call print_error ( test = 'conservative3 = 2.0 * conservative1' , is_test_passed = test_passed ( 2 )) conservative3 = conservative1 * 2._R8P test_passed ( 3 ) = conservative3 == ( conservative1 * 2._R8P ) print \"(A)\" , '' print \"(A,F6.3)\" , 'density   => 0.125  * 2.0 = ' , conservative3 % density print \"(A,3(F6.3,1X))\" , 'momentum  => 1      * 2.0 = ' , conservative3 % momentum print \"(A,F6.3)\" , 'energy    => 1      * 2.0 = ' , conservative3 % energy call print_error ( test = 'conservative3 = conservative1 * 2.0' , is_test_passed = test_passed ( 3 )) conservative3 = 2_I4P * conservative1 test_passed ( 4 ) = conservative3 == ( 2_I4P * conservative1 ) print \"(A)\" , '' print \"(A,F6.3)\" , 'density   => 2 * 0.125  = ' , conservative3 % density print \"(A,3(F6.3,1X))\" , 'momentum  => 2 * 1      = ' , conservative3 % momentum print \"(A,F6.3)\" , 'energy    => 2 * 1      = ' , conservative3 % energy call print_error ( test = 'conservative3 = 2 * conservative1' , is_test_passed = test_passed ( 4 )) conservative3 = conservative1 * 2_I4P test_passed ( 5 ) = conservative3 == ( conservative1 * 2_I4P ) print \"(A)\" , '' print \"(A,F6.3)\" , 'density   => 0.125  * 2 = ' , conservative3 % density print \"(A,3(F6.3,1X))\" , 'momentum  => 1      * 2 = ' , conservative3 % momentum print \"(A,F6.3)\" , 'energy    => 1      * 2 = ' , conservative3 % energy call print_error ( test = 'conservative3 = conservative1 * 2' , is_test_passed = test_passed ( 5 )) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) contains subroutine print_error ( test , is_test_passed ) !< Print error message if test is failed. character ( * ), intent ( in ) :: test !< Test description. logical , intent ( in ) :: is_test_passed !< Test result. if (. not . is_test_passed ) then print * , '\"' // test // '\" failed!' print * , 'conservative1:' print \"(A,F6.3)\" , '  density  = ' , conservative1 % density print \"(A,3(F6.3,1X))\" , '  momentum = ' , conservative1 % momentum print \"(A,F6.3)\" , '  energy   = ' , conservative1 % energy print * , 'conservative2:' print \"(A,F6.3)\" , '  density  = ' , conservative2 % density print \"(A,3(F6.3,1X))\" , '  momentum = ' , conservative2 % momentum print \"(A,F6.3)\" , '  energy   = ' , conservative2 % energy print * , 'conservative3:' print \"(A,F6.3)\" , '  density  = ' , conservative3 % density print \"(A,3(F6.3,1X))\" , '  momentum = ' , conservative3 % momentum print \"(A,F6.3)\" , '  energy   = ' , conservative3 % energy endif endsubroutine print_error endprogram flow_test_conservative_compressible_mul","tags":"","loc":"program/flow_test_conservative_compressible_mul.html","title":"flow_test_conservative_compressible_mul – FLOw"},{"text":"Uses: flow penf VecFor program~~flow_test_conservative_compressible_not_eq~~UsesGraph program~flow_test_conservative_compressible_not_eq flow_test_conservative_compressible_not_eq module~flow flow module~flow->program~flow_test_conservative_compressible_not_eq module~vecfor VecFor module~vecfor->program~flow_test_conservative_compressible_not_eq module~flow_primitive_compressible_multispecie flow_primitive_compressible_multispecie module~vecfor->module~flow_primitive_compressible_multispecie module~flow_field_scalar_vectorial flow_field_scalar_vectorial module~vecfor->module~flow_field_scalar_vectorial module~flow_conservative_object flow_conservative_object module~vecfor->module~flow_conservative_object module~flow_compressible_transformations flow_compressible_transformations module~vecfor->module~flow_compressible_transformations module~flow_conservative_compressible flow_conservative_compressible module~vecfor->module~flow_conservative_compressible module~flow_primitive_compressible flow_primitive_compressible module~vecfor->module~flow_primitive_compressible module~flow_primitive_object flow_primitive_object module~vecfor->module~flow_primitive_object module~penf penf module~penf->program~flow_test_conservative_compressible_not_eq module~penf->module~flow_primitive_compressible_multispecie module~flow_eos_object flow_eos_object module~penf->module~flow_eos_object module~penf->module~flow_field_scalar_vectorial module~flow_field_object flow_field_object module~penf->module~flow_field_object module~penf->module~flow_conservative_object module~penf->module~flow_compressible_transformations module~flow_eos_compressible flow_eos_compressible module~penf->module~flow_eos_compressible module~penf->module~flow_conservative_compressible module~penf->module~flow_primitive_compressible module~penf->module~flow_primitive_object module~flow_primitive_compressible_multispecie->module~flow module~flow_eos_object->module~flow module~flow_eos_object->module~flow_primitive_compressible_multispecie module~flow_eos_object->module~flow_conservative_object module~flow_eos_object->module~flow_compressible_transformations module~flow_eos_object->module~flow_eos_compressible module~flow_eos_object->module~flow_conservative_compressible module~flow_eos_object->module~flow_primitive_compressible module~flow_eos_object->module~flow_primitive_object module~flow_field_scalar_vectorial->module~flow module~flow_field_object->module~flow module~flow_field_object->module~flow_primitive_compressible_multispecie module~flow_field_object->module~flow_field_scalar_vectorial module~flow_field_object->module~flow_conservative_object module~flow_field_object->module~flow_conservative_compressible module~flow_field_object->module~flow_primitive_compressible module~flow_field_object->module~flow_primitive_object module~flow_conservative_object->module~flow module~flow_conservative_object->module~flow_conservative_compressible module~flow_compressible_transformations->module~flow module~flow_eos_compressible->module~flow module~flow_conservative_compressible->module~flow module~flow_conservative_compressible->module~flow_compressible_transformations module~flow_primitive_compressible->module~flow module~flow_primitive_compressible->module~flow_compressible_transformations module~flow_primitive_object->module~flow module~flow_primitive_object->module~flow_primitive_compressible_multispecie module~flow_primitive_object->module~flow_primitive_compressible iso_fortran_env iso_fortran_env iso_fortran_env->module~vecfor iso_fortran_env->module~flow_conservative_compressible iso_fortran_env->module~flow_primitive_compressible module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf var panprogramflow_test_conservative_compressible_not_eqUsesGraph = svgPanZoom('#programflow_test_conservative_compressible_not_eqUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FLOw test. Variables conservative1 conservative2 momentum test_passed Source Code flow_test_conservative_compressible_not_eq Variables Type Attributes Name Initial type( conservative_compressible ) :: conservative1 A conservative object. type( conservative_compressible ) :: conservative2 A conservative object. type(vector) :: momentum A vector object. logical :: test_passed (5) List of passed tests. Source Code program flow_test_conservative_compressible_not_eq !< FLOw test. use flow , only : conservative_compressible use penf , only : R8P use vecfor , only : vector implicit none type ( conservative_compressible ) :: conservative1 !< A conservative object. type ( conservative_compressible ) :: conservative2 !< A conservative object. type ( vector ) :: momentum !< A vector object. logical :: test_passed ( 5 ) !< List of passed tests. test_passed = . false . momentum = 1._R8P conservative1 = conservative_compressible ( density = 0.125_R8P , momentum = momentum , energy = 1._R8P ) momentum = 1._R8P conservative2 = conservative_compressible ( density = 1._R8P , momentum = momentum , energy = 1._R8P ) test_passed ( 1 ) = ( conservative1 /= conservative2 ). eqv .(. true .) print \"(A,L1)\" , 'density  => 0.125 /= 1 = ' , test_passed ( 1 ) momentum = 1._R8P conservative1 = conservative_compressible ( density = 0.125_R8P , momentum = momentum , energy = 1._R8P ) momentum = 2._R8P conservative2 = conservative_compressible ( density = 0.125_R8P , momentum = momentum , energy = 1._R8P ) test_passed ( 2 ) = ( conservative1 /= conservative2 ). eqv .(. true .) print \"(A,L1)\" , 'momentum => 1     /= 2 = ' , test_passed ( 2 ) momentum = 1._R8P conservative1 = conservative_compressible ( density = 0.125_R8P , momentum = momentum , energy = 1._R8P ) momentum = 2._R8P conservative2 = conservative_compressible ( density = 0.125_R8P , momentum = momentum , energy = 2._R8P ) test_passed ( 3 ) = ( conservative1 /= conservative2 ). eqv .(. true .) print \"(A,L1)\" , 'energy   => 1     /= 2 = ' , test_passed ( 3 ) momentum = 1._R8P conservative1 = conservative_compressible ( density = 0.125_R8P , momentum = momentum , energy = 1._R8P ) momentum = 2._R8P conservative2 = conservative_compressible ( density = 1._R8P , momentum = momentum , energy = 2._R8P ) test_passed ( 4 ) = ( conservative1 /= conservative2 ). eqv .(. true .) print \"(A)\" , new_line ( 'a' ) // 'all together' print \"(A,L1)\" , 'density  => 0.125 /= 1 = ' , test_passed ( 4 ) print \"(A,L1)\" , 'momentum => 1     /= 2 = ' , test_passed ( 4 ) print \"(A,L1)\" , 'energy   => 1     /= 2 = ' , test_passed ( 4 ) momentum = 1._R8P conservative1 = conservative_compressible ( density = 1._R8P , momentum = momentum , energy = 1._R8P ) momentum = 1._R8P conservative2 = conservative_compressible ( density = 1._R8P , momentum = momentum , energy = 1._R8P ) test_passed ( 5 ) = ( conservative1 /= conservative2 ). eqv .(. false .) print \"(A)\" , new_line ( 'a' ) // 'all together' print \"(A,L1)\" , 'density  => 0.125 /= 1 = ' , test_passed ( 5 ) print \"(A,L1)\" , 'momentum => 1     /= 2 = ' , test_passed ( 5 ) print \"(A,L1)\" , 'energy   => 1     /= 2 = ' , test_passed ( 5 ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram flow_test_conservative_compressible_not_eq","tags":"","loc":"program/flow_test_conservative_compressible_not_eq.html","title":"flow_test_conservative_compressible_not_eq – FLOw"},{"text":"Uses: flow penf VecFor program~~flow_test_conservative_compressible_add~2~~UsesGraph program~flow_test_conservative_compressible_add~2 flow_test_conservative_compressible_add module~flow flow module~flow->program~flow_test_conservative_compressible_add~2 module~vecfor VecFor module~vecfor->program~flow_test_conservative_compressible_add~2 module~flow_primitive_compressible_multispecie flow_primitive_compressible_multispecie module~vecfor->module~flow_primitive_compressible_multispecie module~flow_field_scalar_vectorial flow_field_scalar_vectorial module~vecfor->module~flow_field_scalar_vectorial module~flow_conservative_object flow_conservative_object module~vecfor->module~flow_conservative_object module~flow_compressible_transformations flow_compressible_transformations module~vecfor->module~flow_compressible_transformations module~flow_conservative_compressible flow_conservative_compressible module~vecfor->module~flow_conservative_compressible module~flow_primitive_compressible flow_primitive_compressible module~vecfor->module~flow_primitive_compressible module~flow_primitive_object flow_primitive_object module~vecfor->module~flow_primitive_object module~penf penf module~penf->program~flow_test_conservative_compressible_add~2 module~penf->module~flow_primitive_compressible_multispecie module~flow_eos_object flow_eos_object module~penf->module~flow_eos_object module~penf->module~flow_field_scalar_vectorial module~flow_field_object flow_field_object module~penf->module~flow_field_object module~penf->module~flow_conservative_object module~penf->module~flow_compressible_transformations module~flow_eos_compressible flow_eos_compressible module~penf->module~flow_eos_compressible module~penf->module~flow_conservative_compressible module~penf->module~flow_primitive_compressible module~penf->module~flow_primitive_object module~flow_primitive_compressible_multispecie->module~flow module~flow_eos_object->module~flow module~flow_eos_object->module~flow_primitive_compressible_multispecie module~flow_eos_object->module~flow_conservative_object module~flow_eos_object->module~flow_compressible_transformations module~flow_eos_object->module~flow_eos_compressible module~flow_eos_object->module~flow_conservative_compressible module~flow_eos_object->module~flow_primitive_compressible module~flow_eos_object->module~flow_primitive_object module~flow_field_scalar_vectorial->module~flow module~flow_field_object->module~flow module~flow_field_object->module~flow_primitive_compressible_multispecie module~flow_field_object->module~flow_field_scalar_vectorial module~flow_field_object->module~flow_conservative_object module~flow_field_object->module~flow_conservative_compressible module~flow_field_object->module~flow_primitive_compressible module~flow_field_object->module~flow_primitive_object module~flow_conservative_object->module~flow module~flow_conservative_object->module~flow_conservative_compressible module~flow_compressible_transformations->module~flow module~flow_eos_compressible->module~flow module~flow_conservative_compressible->module~flow module~flow_conservative_compressible->module~flow_compressible_transformations module~flow_primitive_compressible->module~flow module~flow_primitive_compressible->module~flow_compressible_transformations module~flow_primitive_object->module~flow module~flow_primitive_object->module~flow_primitive_compressible_multispecie module~flow_primitive_object->module~flow_primitive_compressible iso_fortran_env iso_fortran_env iso_fortran_env->module~vecfor iso_fortran_env->module~flow_conservative_compressible iso_fortran_env->module~flow_primitive_compressible module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf var panprogramflow_test_conservative_compressible_add2UsesGraph = svgPanZoom('#programflow_test_conservative_compressible_add2UsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FLOw test. Variables conservative1 conservative2 momentum test_passed Source Code flow_test_conservative_compressible_add Variables Type Attributes Name Initial type( conservative_compressible ) :: conservative1 A conservative object. type( conservative_compressible ) :: conservative2 A conservative object. type(vector) :: momentum A vector object. logical :: test_passed (2) List of passed tests. Source Code program flow_test_conservative_compressible_add !< FLOw test. use flow , only : conservative_compressible use penf , only : I4P , R8P use vecfor , only : vector implicit none type ( conservative_compressible ) :: conservative1 !< A conservative object. type ( conservative_compressible ) :: conservative2 !< A conservative object. type ( vector ) :: momentum !< A vector object. logical :: test_passed ( 2 ) !< List of passed tests. test_passed = . false . momentum = 0.5_R8P conservative1 = conservative_compressible ( density = 0.125_R8P , momentum = momentum , energy = 1._R8P ) conservative2 = conservative1 ** 2_I4P print \"(A,F6.3)\" , 'density  => 0.125 ** 2 = ' , conservative2 % density print \"(A,3(F6.3,1X))\" , 'momentum => 0.5   ** 2 = ' , conservative2 % momentum print \"(A,F6.3)\" , 'energy   => 1     ** 2 = ' , conservative2 % energy test_passed ( 1 ) = conservative2 % density == ( 0.125_R8P ** 2_I4P ) momentum = 0.5_R8P conservative1 = conservative_compressible ( density = 0.125_R8P , momentum = momentum , energy = 1._R8P ) conservative2 = conservative1 ** 2._R8P print \"(A,F6.3)\" , 'density  => 0.125 ** 2.0 = ' , conservative2 % density print \"(A,3(F6.3,1X))\" , 'momentum => 0.5   ** 2.0 = ' , conservative2 % momentum print \"(A,F6.3)\" , 'energy   => 1     ** 2.0 = ' , conservative2 % energy test_passed ( 2 ) = conservative2 % density == ( 0.125_R8P ** 2._R8P ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram flow_test_conservative_compressible_add","tags":"","loc":"program/flow_test_conservative_compressible_add~2.html","title":"flow_test_conservative_compressible_add – FLOw"},{"text":"Uses: flow penf VecFor program~~flow_test_conservative_compressible_sub~~UsesGraph program~flow_test_conservative_compressible_sub flow_test_conservative_compressible_sub module~flow flow module~flow->program~flow_test_conservative_compressible_sub module~vecfor VecFor module~vecfor->program~flow_test_conservative_compressible_sub module~flow_primitive_compressible_multispecie flow_primitive_compressible_multispecie module~vecfor->module~flow_primitive_compressible_multispecie module~flow_field_scalar_vectorial flow_field_scalar_vectorial module~vecfor->module~flow_field_scalar_vectorial module~flow_conservative_object flow_conservative_object module~vecfor->module~flow_conservative_object module~flow_compressible_transformations flow_compressible_transformations module~vecfor->module~flow_compressible_transformations module~flow_conservative_compressible flow_conservative_compressible module~vecfor->module~flow_conservative_compressible module~flow_primitive_compressible flow_primitive_compressible module~vecfor->module~flow_primitive_compressible module~flow_primitive_object flow_primitive_object module~vecfor->module~flow_primitive_object module~penf penf module~penf->program~flow_test_conservative_compressible_sub module~penf->module~flow_primitive_compressible_multispecie module~flow_eos_object flow_eos_object module~penf->module~flow_eos_object module~penf->module~flow_field_scalar_vectorial module~flow_field_object flow_field_object module~penf->module~flow_field_object module~penf->module~flow_conservative_object module~penf->module~flow_compressible_transformations module~flow_eos_compressible flow_eos_compressible module~penf->module~flow_eos_compressible module~penf->module~flow_conservative_compressible module~penf->module~flow_primitive_compressible module~penf->module~flow_primitive_object module~flow_primitive_compressible_multispecie->module~flow module~flow_eos_object->module~flow module~flow_eos_object->module~flow_primitive_compressible_multispecie module~flow_eos_object->module~flow_conservative_object module~flow_eos_object->module~flow_compressible_transformations module~flow_eos_object->module~flow_eos_compressible module~flow_eos_object->module~flow_conservative_compressible module~flow_eos_object->module~flow_primitive_compressible module~flow_eos_object->module~flow_primitive_object module~flow_field_scalar_vectorial->module~flow module~flow_field_object->module~flow module~flow_field_object->module~flow_primitive_compressible_multispecie module~flow_field_object->module~flow_field_scalar_vectorial module~flow_field_object->module~flow_conservative_object module~flow_field_object->module~flow_conservative_compressible module~flow_field_object->module~flow_primitive_compressible module~flow_field_object->module~flow_primitive_object module~flow_conservative_object->module~flow module~flow_conservative_object->module~flow_conservative_compressible module~flow_compressible_transformations->module~flow module~flow_eos_compressible->module~flow module~flow_conservative_compressible->module~flow module~flow_conservative_compressible->module~flow_compressible_transformations module~flow_primitive_compressible->module~flow module~flow_primitive_compressible->module~flow_compressible_transformations module~flow_primitive_object->module~flow module~flow_primitive_object->module~flow_primitive_compressible_multispecie module~flow_primitive_object->module~flow_primitive_compressible iso_fortran_env iso_fortran_env iso_fortran_env->module~vecfor iso_fortran_env->module~flow_conservative_compressible iso_fortran_env->module~flow_primitive_compressible module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf var panprogramflow_test_conservative_compressible_subUsesGraph = svgPanZoom('#programflow_test_conservative_compressible_subUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FLOw test. Variables conservative1 conservative2 conservative3 momentum test_passed Source Code flow_test_conservative_compressible_sub Variables Type Attributes Name Initial type( conservative_compressible ) :: conservative1 A conservative object. type( conservative_compressible ) :: conservative2 A conservative object. type( conservative_compressible ) :: conservative3 A conservative object. type(vector) :: momentum A vector object. logical :: test_passed (2) List of passed tests. Source Code program flow_test_conservative_compressible_sub !< FLOw test. use flow , only : conservative_compressible use penf , only : R8P use vecfor , only : vector implicit none type ( conservative_compressible ) :: conservative1 !< A conservative object. type ( conservative_compressible ) :: conservative2 !< A conservative object. type ( conservative_compressible ) :: conservative3 !< A conservative object. type ( vector ) :: momentum !< A vector object. logical :: test_passed ( 2 ) !< List of passed tests. test_passed = . false . momentum = 1._R8P conservative1 = conservative_compressible ( density = 0.125_R8P , momentum = momentum , energy = 1._R8P ) momentum = 2._R8P conservative2 = conservative_compressible ( density = 1._R8P , momentum = momentum , energy = 1._R8P ) conservative3 = conservative1 - conservative2 test_passed ( 1 ) = conservative3 == ( conservative1 - conservative2 ) print \"(A,F6.3)\" , 'density   => 0.125  - 1   = ' , conservative3 % density print \"(A,3(F6.3,1X))\" , 'momentum  => 1      - 2   = ' , conservative3 % momentum print \"(A,F6.3)\" , 'energy    => 1      - 1   = ' , conservative3 % energy momentum = - 1._R8P conservative1 = conservative_compressible ( density = 0.125_R8P , momentum = momentum , energy = 1._R8P ) conservative2 = - conservative1 test_passed ( 2 ) = conservative2 == - conservative1 print \"(A,F6.3)\" , 'density   => - (0.125) = ' , conservative2 % density print \"(A,3(F6.3,1X))\" , 'momentum  => - (-1)    = ' , conservative2 % momentum print \"(A,F6.3)\" , 'energy    => - (1)     = ' , conservative2 % energy print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram flow_test_conservative_compressible_sub","tags":"","loc":"program/flow_test_conservative_compressible_sub.html","title":"flow_test_conservative_compressible_sub – FLOw"},{"text":"Uses: flow penf program~~flow_test_eos_compressible~~UsesGraph program~flow_test_eos_compressible flow_test_eos_compressible module~flow flow module~flow->program~flow_test_eos_compressible module~penf penf module~penf->program~flow_test_eos_compressible module~flow_primitive_compressible_multispecie flow_primitive_compressible_multispecie module~penf->module~flow_primitive_compressible_multispecie module~flow_eos_object flow_eos_object module~penf->module~flow_eos_object module~flow_field_scalar_vectorial flow_field_scalar_vectorial module~penf->module~flow_field_scalar_vectorial module~flow_field_object flow_field_object module~penf->module~flow_field_object module~flow_conservative_object flow_conservative_object module~penf->module~flow_conservative_object module~flow_compressible_transformations flow_compressible_transformations module~penf->module~flow_compressible_transformations module~flow_eos_compressible flow_eos_compressible module~penf->module~flow_eos_compressible module~flow_conservative_compressible flow_conservative_compressible module~penf->module~flow_conservative_compressible module~flow_primitive_compressible flow_primitive_compressible module~penf->module~flow_primitive_compressible module~flow_primitive_object flow_primitive_object module~penf->module~flow_primitive_object module~flow_primitive_compressible_multispecie->module~flow module~flow_eos_object->module~flow module~flow_eos_object->module~flow_primitive_compressible_multispecie module~flow_eos_object->module~flow_conservative_object module~flow_eos_object->module~flow_compressible_transformations module~flow_eos_object->module~flow_eos_compressible module~flow_eos_object->module~flow_conservative_compressible module~flow_eos_object->module~flow_primitive_compressible module~flow_eos_object->module~flow_primitive_object module~flow_field_scalar_vectorial->module~flow module~flow_field_object->module~flow module~flow_field_object->module~flow_primitive_compressible_multispecie module~flow_field_object->module~flow_field_scalar_vectorial module~flow_field_object->module~flow_conservative_object module~flow_field_object->module~flow_conservative_compressible module~flow_field_object->module~flow_primitive_compressible module~flow_field_object->module~flow_primitive_object module~flow_conservative_object->module~flow module~flow_conservative_object->module~flow_conservative_compressible module~flow_compressible_transformations->module~flow module~flow_eos_compressible->module~flow module~flow_conservative_compressible->module~flow module~flow_conservative_compressible->module~flow_compressible_transformations module~flow_primitive_compressible->module~flow module~flow_primitive_compressible->module~flow_compressible_transformations module~flow_primitive_object->module~flow module~flow_primitive_object->module~flow_primitive_compressible_multispecie module~flow_primitive_object->module~flow_primitive_compressible module~vecfor VecFor module~vecfor->module~flow_primitive_compressible_multispecie module~vecfor->module~flow_field_scalar_vectorial module~vecfor->module~flow_conservative_object module~vecfor->module~flow_compressible_transformations module~vecfor->module~flow_conservative_compressible module~vecfor->module~flow_primitive_compressible module~vecfor->module~flow_primitive_object iso_fortran_env iso_fortran_env iso_fortran_env->module~flow_conservative_compressible iso_fortran_env->module~flow_primitive_compressible iso_fortran_env->module~vecfor module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf var panprogramflow_test_eos_compressibleUsesGraph = svgPanZoom('#programflow_test_eos_compressibleUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. Flow test. Variables are_tests_passed eos Source Code flow_test_eos_compressible Variables Type Attributes Name Initial logical :: are_tests_passed (13) List of passed tests. type( eos_compressible ) :: eos An equation of state. Source Code program flow_test_eos_compressible !< Flow test. use flow , only : eos_compressible use penf , only : R8P , ZeroR8 implicit none type ( eos_compressible ) :: eos !< An equation of state. logical :: are_tests_passed ( 13 ) !< List of passed tests. are_tests_passed = . false . eos = eos_compressible ( cp = 104 0.004_R8P , cv = 74 2.86_R8P ) print \"(A)\" , 'EOS description:' print \"(A)\" , eos % description () are_tests_passed ( 1 ) = ( eos % g () >= 1.4_R8P - ZeroR8 ). and .( eos % g () <= 1.4_R8P + ZeroR8 ) print \"(A,L1)\" , 'eos%g() = 1.4, is right? ' , are_tests_passed ( 1 ) eos = eos_compressible ( cp = 104 0.004_R8P , gam = 1.4_R8P ) are_tests_passed ( 2 ) = ( eos % cv () >= 74 2.86_R8P - ZeroR8 ). and .( eos % cv () <= 74 2.86_R8P + ZeroR8 ) print \"(A,L1)\" , 'eos%cv() = 742.86, is right? ' , are_tests_passed ( 2 ) eos = eos_compressible ( cv = 74 2.86_R8P , gam = 1.4_R8P ) are_tests_passed ( 3 ) = ( eos % R () >= 29 7.144_R8P - 1000 * ZeroR8 ). and .( eos % R () <= 29 7.144_R8P + 1000 * ZeroR8 ) print \"(A,L1)\" , 'eos%R() = 297.144, is right? ' , are_tests_passed ( 3 ) eos = eos_compressible ( cv = 74 2.86_R8P , R = 29 7.144_R8P ) are_tests_passed ( 4 ) = ( eos % cp () >= 104 0.004_R8P - ZeroR8 ). and .( eos % cp () <= 104 0.004_R8P + ZeroR8 ) print \"(A,L1)\" , 'eos%cp() = 1040.004, is right? ' , are_tests_passed ( 4 ) eos = eos_compressible ( cp = 104 0.004_R8P , R = 29 7.144_R8P ) are_tests_passed ( 5 ) = ( eos % cv () >= 74 2.86_R8P - 1000 * ZeroR8 ). and .( eos % cv () <= 74 2.86_R8P + 1000 * ZeroR8 ) print \"(A,L1)\" , 'eos%cv() = 742.86, is right? ' , are_tests_passed ( 5 ) eos = eos_compressible ( gam = 1.4_R8P , R = 29 7.144_R8P ) are_tests_passed ( 6 ) = ( eos % cp () >= 104 0.004_R8P - 1000 * ZeroR8 ). and .( eos % cp () <= 104 0.004_R8P + 1000 * ZeroR8 ) print \"(A,L1)\" , 'eos%cp() = 1040.004, is right? ' , are_tests_passed ( 6 ) eos = eos_compressible ( cp = 104 0.004_R8P , cv = 74 2.86_R8P ) are_tests_passed ( 7 ) = ( eos % pressure ( density = 1._R8P , energy = 1._R8P ) >= 0.4_R8P - ZeroR8 ). and .& ( eos % pressure ( density = 1._R8P , energy = 1._R8P ) <= 0.4_R8P + ZeroR8 ) print \"(A,L1)\" , 'eos%pressure(density=1, energy=1) = 0.4, is right? ' , are_tests_passed ( 7 ) are_tests_passed ( 8 ) = ( eos % pressure ( density = 1._R8P , temperature = 1._R8P ) >= 29 7.144_R8P - 1000 * ZeroR8 ). and .& ( eos % pressure ( density = 1._R8P , temperature = 1._R8P ) <= 29 7.144_R8P + 1000 * ZeroR8 ) print \"(A,L1)\" , 'eos%pressure(density=1, temperature=1) = 297.144, is right? ' , are_tests_passed ( 8 ) are_tests_passed ( 9 ) = ( eos % density ( pressure = 1._R8P , speed_of_sound = 1._R8P ) >= 1.4_R8P - ZeroR8 ). and .& ( eos % density ( pressure = 1._R8P , speed_of_sound = 1._R8P ) <= 1.4_R8P + ZeroR8 ) print \"(A,L1)\" , 'eos%density(pressure=1, speed_of_sound=1) = 1.4, is right? ' , are_tests_passed ( 9 ) are_tests_passed ( 10 ) = ( eos % internal_energy ( density = 1._R8P , pressure = 1._R8P ) >= 1._R8P / 0.4_R8P - ZeroR8 ). and .& ( eos % internal_energy ( density = 1._R8P , pressure = 1._R8P ) <= 1._R8P / 0.4_R8P + ZeroR8 ) print \"(A,L1)\" , 'eos%internal_energy(density=1, pressure=1) = 1/0.4, is right? ' , are_tests_passed ( 10 ) are_tests_passed ( 11 ) = ( eos % temperature ( density = 1._R8P , pressure = 1._R8P ) >= 1._R8P / 29 7.144_R8P - ZeroR8 ). and .& ( eos % temperature ( density = 1._R8P , pressure = 1._R8P ) <= 1._R8P / 29 7.144_R8P + ZeroR8 ) print \"(A,L1)\" , 'eos%temperature(density=1, pressure=1) = 1/297.144, is right? ' , are_tests_passed ( 11 ) are_tests_passed ( 12 ) = ( eos % temperature ( energy = 1._R8P ) >= 1._R8P / 74 2.86_R8P - ZeroR8 ). and .& ( eos % temperature ( energy = 1._R8P ) <= 1._R8P / 74 2.86_R8P + ZeroR8 ) print \"(A,L1)\" , 'eos%temperature(energy=1) = 1/742.86, is right? ' , are_tests_passed ( 12 ) are_tests_passed ( 13 ) = ( eos % total_entalpy ( pressure = 1._R8P , & density = 1._R8P , & velocity_sq_norm = 2._R8P ) >= 4.5_R8P - ZeroR8 ). and .& ( eos % total_entalpy ( pressure = 1._R8P , & density = 1._R8P , & velocity_sq_norm = 2._R8P ) <= 4.5_R8P + ZeroR8 ) print \"(A,L1)\" , 'eos%total_entalpy(pressure=1, density=1, velocity_sq_norm=2) = 4.5, is right? ' , are_tests_passed ( 13 ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( are_tests_passed ) endprogram flow_test_eos_compressible","tags":"","loc":"program/flow_test_eos_compressible.html","title":"flow_test_eos_compressible – FLOw"},{"text":"Uses: flow penf VecFor program~~flow_test_primitive_compressible_add~~UsesGraph program~flow_test_primitive_compressible_add flow_test_primitive_compressible_add module~flow flow module~flow->program~flow_test_primitive_compressible_add module~vecfor VecFor module~vecfor->program~flow_test_primitive_compressible_add module~flow_primitive_compressible_multispecie flow_primitive_compressible_multispecie module~vecfor->module~flow_primitive_compressible_multispecie module~flow_field_scalar_vectorial flow_field_scalar_vectorial module~vecfor->module~flow_field_scalar_vectorial module~flow_conservative_object flow_conservative_object module~vecfor->module~flow_conservative_object module~flow_compressible_transformations flow_compressible_transformations module~vecfor->module~flow_compressible_transformations module~flow_conservative_compressible flow_conservative_compressible module~vecfor->module~flow_conservative_compressible module~flow_primitive_compressible flow_primitive_compressible module~vecfor->module~flow_primitive_compressible module~flow_primitive_object flow_primitive_object module~vecfor->module~flow_primitive_object module~penf penf module~penf->program~flow_test_primitive_compressible_add module~penf->module~flow_primitive_compressible_multispecie module~flow_eos_object flow_eos_object module~penf->module~flow_eos_object module~penf->module~flow_field_scalar_vectorial module~flow_field_object flow_field_object module~penf->module~flow_field_object module~penf->module~flow_conservative_object module~penf->module~flow_compressible_transformations module~flow_eos_compressible flow_eos_compressible module~penf->module~flow_eos_compressible module~penf->module~flow_conservative_compressible module~penf->module~flow_primitive_compressible module~penf->module~flow_primitive_object module~flow_primitive_compressible_multispecie->module~flow module~flow_eos_object->module~flow module~flow_eos_object->module~flow_primitive_compressible_multispecie module~flow_eos_object->module~flow_conservative_object module~flow_eos_object->module~flow_compressible_transformations module~flow_eos_object->module~flow_eos_compressible module~flow_eos_object->module~flow_conservative_compressible module~flow_eos_object->module~flow_primitive_compressible module~flow_eos_object->module~flow_primitive_object module~flow_field_scalar_vectorial->module~flow module~flow_field_object->module~flow module~flow_field_object->module~flow_primitive_compressible_multispecie module~flow_field_object->module~flow_field_scalar_vectorial module~flow_field_object->module~flow_conservative_object module~flow_field_object->module~flow_conservative_compressible module~flow_field_object->module~flow_primitive_compressible module~flow_field_object->module~flow_primitive_object module~flow_conservative_object->module~flow module~flow_conservative_object->module~flow_conservative_compressible module~flow_compressible_transformations->module~flow module~flow_eos_compressible->module~flow module~flow_conservative_compressible->module~flow module~flow_conservative_compressible->module~flow_compressible_transformations module~flow_primitive_compressible->module~flow module~flow_primitive_compressible->module~flow_compressible_transformations module~flow_primitive_object->module~flow module~flow_primitive_object->module~flow_primitive_compressible_multispecie module~flow_primitive_object->module~flow_primitive_compressible iso_fortran_env iso_fortran_env iso_fortran_env->module~vecfor iso_fortran_env->module~flow_conservative_compressible iso_fortran_env->module~flow_primitive_compressible module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf var panprogramflow_test_primitive_compressible_addUsesGraph = svgPanZoom('#programflow_test_primitive_compressible_addUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FLOw test. Variables primitive1 primitive2 primitive3 test_passed velocity Source Code flow_test_primitive_compressible_add Variables Type Attributes Name Initial type( primitive_compressible ) :: primitive1 A primitive object. type( primitive_compressible ) :: primitive2 A primitive object. type( primitive_compressible ) :: primitive3 A primitive object. logical :: test_passed (2) List of passed tests. type(vector) :: velocity A vector object. Source Code program flow_test_primitive_compressible_add !< FLOw test. use flow , only : primitive_compressible use penf , only : R8P use vecfor , only : vector implicit none type ( primitive_compressible ) :: primitive1 !< A primitive object. type ( primitive_compressible ) :: primitive2 !< A primitive object. type ( primitive_compressible ) :: primitive3 !< A primitive object. type ( vector ) :: velocity !< A vector object. logical :: test_passed ( 2 ) !< List of passed tests. test_passed = . false . velocity = 1._R8P primitive1 = primitive_compressible ( density = 0.125_R8P , velocity = velocity , pressure = 1._R8P ) velocity = 2._R8P primitive2 = primitive_compressible ( density = 1._R8P , velocity = velocity , pressure = 1._R8P ) primitive3 = primitive1 + primitive2 test_passed ( 1 ) = primitive3 == ( primitive1 + primitive2 ) print \"(A,F6.3)\" , 'density   => 0.125  + 1   = ' , primitive3 % density print \"(A,3(F6.3,1X))\" , 'velocity  => 1      + 2   = ' , primitive3 % velocity print \"(A,F6.3)\" , 'pressure  => 1      + 1   = ' , primitive3 % pressure velocity = - 1._R8P primitive1 = primitive_compressible ( density = 0.125_R8P , velocity = velocity , pressure = 1._R8P ) primitive2 = + primitive1 test_passed ( 2 ) = primitive2 == primitive1 print \"(A,F6.3)\" , 'density   => + (0.125) = ' , primitive2 % density print \"(A,3(F6.3,1X))\" , 'velocity  => + (-1)    = ' , primitive2 % velocity print \"(A,F6.3)\" , 'pressure  => + (1)     = ' , primitive2 % pressure print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram flow_test_primitive_compressible_add","tags":"","loc":"program/flow_test_primitive_compressible_add.html","title":"flow_test_primitive_compressible_add – FLOw"},{"text":"Uses: flow penf VecFor program~~flow_test_primitive_compressible_assign~~UsesGraph program~flow_test_primitive_compressible_assign flow_test_primitive_compressible_assign module~flow flow module~flow->program~flow_test_primitive_compressible_assign module~vecfor VecFor module~vecfor->program~flow_test_primitive_compressible_assign module~flow_primitive_compressible_multispecie flow_primitive_compressible_multispecie module~vecfor->module~flow_primitive_compressible_multispecie module~flow_field_scalar_vectorial flow_field_scalar_vectorial module~vecfor->module~flow_field_scalar_vectorial module~flow_conservative_object flow_conservative_object module~vecfor->module~flow_conservative_object module~flow_compressible_transformations flow_compressible_transformations module~vecfor->module~flow_compressible_transformations module~flow_conservative_compressible flow_conservative_compressible module~vecfor->module~flow_conservative_compressible module~flow_primitive_compressible flow_primitive_compressible module~vecfor->module~flow_primitive_compressible module~flow_primitive_object flow_primitive_object module~vecfor->module~flow_primitive_object module~penf penf module~penf->program~flow_test_primitive_compressible_assign module~penf->module~flow_primitive_compressible_multispecie module~flow_eos_object flow_eos_object module~penf->module~flow_eos_object module~penf->module~flow_field_scalar_vectorial module~flow_field_object flow_field_object module~penf->module~flow_field_object module~penf->module~flow_conservative_object module~penf->module~flow_compressible_transformations module~flow_eos_compressible flow_eos_compressible module~penf->module~flow_eos_compressible module~penf->module~flow_conservative_compressible module~penf->module~flow_primitive_compressible module~penf->module~flow_primitive_object module~flow_primitive_compressible_multispecie->module~flow module~flow_eos_object->module~flow module~flow_eos_object->module~flow_primitive_compressible_multispecie module~flow_eos_object->module~flow_conservative_object module~flow_eos_object->module~flow_compressible_transformations module~flow_eos_object->module~flow_eos_compressible module~flow_eos_object->module~flow_conservative_compressible module~flow_eos_object->module~flow_primitive_compressible module~flow_eos_object->module~flow_primitive_object module~flow_field_scalar_vectorial->module~flow module~flow_field_object->module~flow module~flow_field_object->module~flow_primitive_compressible_multispecie module~flow_field_object->module~flow_field_scalar_vectorial module~flow_field_object->module~flow_conservative_object module~flow_field_object->module~flow_conservative_compressible module~flow_field_object->module~flow_primitive_compressible module~flow_field_object->module~flow_primitive_object module~flow_conservative_object->module~flow module~flow_conservative_object->module~flow_conservative_compressible module~flow_compressible_transformations->module~flow module~flow_eos_compressible->module~flow module~flow_conservative_compressible->module~flow module~flow_conservative_compressible->module~flow_compressible_transformations module~flow_primitive_compressible->module~flow module~flow_primitive_compressible->module~flow_compressible_transformations module~flow_primitive_object->module~flow module~flow_primitive_object->module~flow_primitive_compressible_multispecie module~flow_primitive_object->module~flow_primitive_compressible iso_fortran_env iso_fortran_env iso_fortran_env->module~vecfor iso_fortran_env->module~flow_conservative_compressible iso_fortran_env->module~flow_primitive_compressible module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf var panprogramflow_test_primitive_compressible_assignUsesGraph = svgPanZoom('#programflow_test_primitive_compressible_assignUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FLOw test. Variables primitive1 primitive2 test_passed velocity Source Code flow_test_primitive_compressible_assign Variables Type Attributes Name Initial type( primitive_compressible ) :: primitive1 A primitive object. type( primitive_compressible ) :: primitive2 A primitive object. logical :: test_passed (2) List of passed tests. type(vector) :: velocity A vector object. Source Code program flow_test_primitive_compressible_assign !< FLOw test. use flow , only : primitive_compressible use penf , only : R8P use vecfor , only : vector implicit none type ( primitive_compressible ) :: primitive1 !< A primitive object. type ( primitive_compressible ) :: primitive2 !< A primitive object. type ( vector ) :: velocity !< A vector object. logical :: test_passed ( 2 ) !< List of passed tests. test_passed = . false . primitive1 = 0.125_R8P test_passed ( 1 ) = ( primitive1 % density == 0.125_R8P ). and . & ( primitive1 % velocity % x == 0.125_R8P ). and . & ( primitive1 % velocity % y == 0.125_R8P ). and . & ( primitive1 % velocity % z == 0.125_R8P ). and . & ( primitive1 % pressure == 0.125_R8P ) print \"(A,F6.3)\" , 'density   = ' , primitive1 % density print \"(A,3(F6.3,1X))\" , 'velocity  = ' , primitive1 % velocity print \"(A,F6.3)\" , 'pressure  = ' , primitive1 % pressure velocity = 1._R8P primitive1 = primitive_compressible ( density = 0.125_R8P , velocity = velocity , pressure = 2._R8P ) primitive2 = primitive1 test_passed ( 2 ) = primitive1 == primitive2 print \"(A)\" , '' print \"(A,F6.3)\" , 'density   = ' , primitive2 % density print \"(A,3(F6.3,1X))\" , 'velocity  = ' , primitive2 % velocity print \"(A,F6.3)\" , 'pressure  = ' , primitive2 % pressure print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram flow_test_primitive_compressible_assign","tags":"","loc":"program/flow_test_primitive_compressible_assign.html","title":"flow_test_primitive_compressible_assign – FLOw"},{"text":"Uses: flow penf VecFor program~~flow_test_primitive_compressible_div~~UsesGraph program~flow_test_primitive_compressible_div flow_test_primitive_compressible_div module~flow flow module~flow->program~flow_test_primitive_compressible_div module~vecfor VecFor module~vecfor->program~flow_test_primitive_compressible_div module~flow_primitive_compressible_multispecie flow_primitive_compressible_multispecie module~vecfor->module~flow_primitive_compressible_multispecie module~flow_field_scalar_vectorial flow_field_scalar_vectorial module~vecfor->module~flow_field_scalar_vectorial module~flow_conservative_object flow_conservative_object module~vecfor->module~flow_conservative_object module~flow_compressible_transformations flow_compressible_transformations module~vecfor->module~flow_compressible_transformations module~flow_conservative_compressible flow_conservative_compressible module~vecfor->module~flow_conservative_compressible module~flow_primitive_compressible flow_primitive_compressible module~vecfor->module~flow_primitive_compressible module~flow_primitive_object flow_primitive_object module~vecfor->module~flow_primitive_object module~penf penf module~penf->program~flow_test_primitive_compressible_div module~penf->module~flow_primitive_compressible_multispecie module~flow_eos_object flow_eos_object module~penf->module~flow_eos_object module~penf->module~flow_field_scalar_vectorial module~flow_field_object flow_field_object module~penf->module~flow_field_object module~penf->module~flow_conservative_object module~penf->module~flow_compressible_transformations module~flow_eos_compressible flow_eos_compressible module~penf->module~flow_eos_compressible module~penf->module~flow_conservative_compressible module~penf->module~flow_primitive_compressible module~penf->module~flow_primitive_object module~flow_primitive_compressible_multispecie->module~flow module~flow_eos_object->module~flow module~flow_eos_object->module~flow_primitive_compressible_multispecie module~flow_eos_object->module~flow_conservative_object module~flow_eos_object->module~flow_compressible_transformations module~flow_eos_object->module~flow_eos_compressible module~flow_eos_object->module~flow_conservative_compressible module~flow_eos_object->module~flow_primitive_compressible module~flow_eos_object->module~flow_primitive_object module~flow_field_scalar_vectorial->module~flow module~flow_field_object->module~flow module~flow_field_object->module~flow_primitive_compressible_multispecie module~flow_field_object->module~flow_field_scalar_vectorial module~flow_field_object->module~flow_conservative_object module~flow_field_object->module~flow_conservative_compressible module~flow_field_object->module~flow_primitive_compressible module~flow_field_object->module~flow_primitive_object module~flow_conservative_object->module~flow module~flow_conservative_object->module~flow_conservative_compressible module~flow_compressible_transformations->module~flow module~flow_eos_compressible->module~flow module~flow_conservative_compressible->module~flow module~flow_conservative_compressible->module~flow_compressible_transformations module~flow_primitive_compressible->module~flow module~flow_primitive_compressible->module~flow_compressible_transformations module~flow_primitive_object->module~flow module~flow_primitive_object->module~flow_primitive_compressible_multispecie module~flow_primitive_object->module~flow_primitive_compressible iso_fortran_env iso_fortran_env iso_fortran_env->module~vecfor iso_fortran_env->module~flow_conservative_compressible iso_fortran_env->module~flow_primitive_compressible module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf var panprogramflow_test_primitive_compressible_divUsesGraph = svgPanZoom('#programflow_test_primitive_compressible_divUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FLOw test. Calls program~~flow_test_primitive_compressible_div~~CallsGraph program~flow_test_primitive_compressible_div flow_test_primitive_compressible_div proc~print_error~3 print_error program~flow_test_primitive_compressible_div->proc~print_error~3 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Variables primitive1 primitive2 primitive3 test_passed velocity Subroutines print_error Source Code flow_test_primitive_compressible_div Variables Type Attributes Name Initial type( primitive_compressible ) :: primitive1 A primitive object. type( primitive_compressible ) :: primitive2 A primitive object. type( primitive_compressible ) :: primitive3 A primitive object. logical :: test_passed (3) List of passed tests. type(vector) :: velocity A vector object. Subroutines subroutine print_error (test, is_test_passed) Print error message if test is failed. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: test Test description. logical, intent(in) :: is_test_passed Test result. Source Code program flow_test_primitive_compressible_div !< FLOw test. use flow , only : primitive_compressible use penf , only : I4P , R8P use vecfor , only : vector implicit none type ( primitive_compressible ) :: primitive1 !< A primitive object. type ( primitive_compressible ) :: primitive2 !< A primitive object. type ( primitive_compressible ) :: primitive3 !< A primitive object. type ( vector ) :: velocity !< A vector object. logical :: test_passed ( 3 ) !< List of passed tests. test_passed = . false . velocity = 1._R8P primitive1 = primitive_compressible ( density = 0.125_R8P , velocity = velocity , pressure = 1._R8P ) velocity = 2._R8P primitive2 = primitive_compressible ( density = 1._R8P , velocity = velocity , pressure = 1._R8P ) primitive3 = primitive1 / primitive2 test_passed ( 1 ) = primitive3 == ( primitive1 / primitive2 ) print \"(A,F6.3)\" , 'density   => 0.125  / 1   = ' , primitive3 % density print \"(A,3(F6.3,1X))\" , 'velocity  => 1      / 2   = ' , primitive3 % velocity print \"(A,F6.3)\" , 'pressure  => 1      / 1   = ' , primitive3 % pressure call print_error ( test = 'primitive3 = primitive1 / primitive2' , is_test_passed = test_passed ( 1 )) primitive3 = primitive1 / 2._R8P test_passed ( 2 ) = primitive3 == ( primitive1 / 2._R8P ) print \"(A)\" , '' print \"(A,F6.3)\" , 'density   => 0.125  / 2.0 = ' , primitive3 % density print \"(A,3(F6.3,1X))\" , 'velocity  => 1      / 2.0 = ' , primitive3 % velocity print \"(A,F6.3)\" , 'pressure  => 1      / 2.0 = ' , primitive3 % pressure call print_error ( test = 'primitive3 = primitive1 / 2.0' , is_test_passed = test_passed ( 2 )) primitive3 = primitive1 / 2_I4P test_passed ( 3 ) = primitive3 == ( primitive1 / 2_I4P ) print \"(A)\" , '' print \"(A,F6.3)\" , 'density   => 0.125  / 2 = ' , primitive3 % density print \"(A,3(F6.3,1X))\" , 'velocity  => 1      / 2 = ' , primitive3 % velocity print \"(A,F6.3)\" , 'pressure  => 1      / 2 = ' , primitive3 % pressure call print_error ( test = 'primitive3 = primitive1 / 2' , is_test_passed = test_passed ( 3 )) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) contains subroutine print_error ( test , is_test_passed ) !< Print error message if test is failed. character ( * ), intent ( in ) :: test !< Test description. logical , intent ( in ) :: is_test_passed !< Test result. if (. not . is_test_passed ) then print * , '\"' // test // '\" failed!' print * , 'primitive1:' print \"(A,F6.3)\" , '  density   = ' , primitive1 % density print \"(A,3(F6.3,1X))\" , '  velocity  = ' , primitive1 % velocity print \"(A,F6.3)\" , '  pressure  = ' , primitive1 % pressure print * , 'primitive2:' print \"(A,F6.3)\" , '  density   = ' , primitive2 % density print \"(A,3(F6.3,1X))\" , '  velocity  = ' , primitive2 % velocity print \"(A,F6.3)\" , '  pressure  = ' , primitive2 % pressure print * , 'primitive3:' print \"(A,F6.3)\" , '  density   = ' , primitive3 % density print \"(A,3(F6.3,1X))\" , '  velocity  = ' , primitive3 % velocity print \"(A,F6.3)\" , '  pressure  = ' , primitive3 % pressure endif endsubroutine print_error endprogram flow_test_primitive_compressible_div","tags":"","loc":"program/flow_test_primitive_compressible_div.html","title":"flow_test_primitive_compressible_div – FLOw"},{"text":"Uses: flow penf VecFor program~~flow_test_primitive_compressible_eq~~UsesGraph program~flow_test_primitive_compressible_eq flow_test_primitive_compressible_eq module~flow flow module~flow->program~flow_test_primitive_compressible_eq module~vecfor VecFor module~vecfor->program~flow_test_primitive_compressible_eq module~flow_primitive_compressible_multispecie flow_primitive_compressible_multispecie module~vecfor->module~flow_primitive_compressible_multispecie module~flow_field_scalar_vectorial flow_field_scalar_vectorial module~vecfor->module~flow_field_scalar_vectorial module~flow_conservative_object flow_conservative_object module~vecfor->module~flow_conservative_object module~flow_compressible_transformations flow_compressible_transformations module~vecfor->module~flow_compressible_transformations module~flow_conservative_compressible flow_conservative_compressible module~vecfor->module~flow_conservative_compressible module~flow_primitive_compressible flow_primitive_compressible module~vecfor->module~flow_primitive_compressible module~flow_primitive_object flow_primitive_object module~vecfor->module~flow_primitive_object module~penf penf module~penf->program~flow_test_primitive_compressible_eq module~penf->module~flow_primitive_compressible_multispecie module~flow_eos_object flow_eos_object module~penf->module~flow_eos_object module~penf->module~flow_field_scalar_vectorial module~flow_field_object flow_field_object module~penf->module~flow_field_object module~penf->module~flow_conservative_object module~penf->module~flow_compressible_transformations module~flow_eos_compressible flow_eos_compressible module~penf->module~flow_eos_compressible module~penf->module~flow_conservative_compressible module~penf->module~flow_primitive_compressible module~penf->module~flow_primitive_object module~flow_primitive_compressible_multispecie->module~flow module~flow_eos_object->module~flow module~flow_eos_object->module~flow_primitive_compressible_multispecie module~flow_eos_object->module~flow_conservative_object module~flow_eos_object->module~flow_compressible_transformations module~flow_eos_object->module~flow_eos_compressible module~flow_eos_object->module~flow_conservative_compressible module~flow_eos_object->module~flow_primitive_compressible module~flow_eos_object->module~flow_primitive_object module~flow_field_scalar_vectorial->module~flow module~flow_field_object->module~flow module~flow_field_object->module~flow_primitive_compressible_multispecie module~flow_field_object->module~flow_field_scalar_vectorial module~flow_field_object->module~flow_conservative_object module~flow_field_object->module~flow_conservative_compressible module~flow_field_object->module~flow_primitive_compressible module~flow_field_object->module~flow_primitive_object module~flow_conservative_object->module~flow module~flow_conservative_object->module~flow_conservative_compressible module~flow_compressible_transformations->module~flow module~flow_eos_compressible->module~flow module~flow_conservative_compressible->module~flow module~flow_conservative_compressible->module~flow_compressible_transformations module~flow_primitive_compressible->module~flow module~flow_primitive_compressible->module~flow_compressible_transformations module~flow_primitive_object->module~flow module~flow_primitive_object->module~flow_primitive_compressible_multispecie module~flow_primitive_object->module~flow_primitive_compressible iso_fortran_env iso_fortran_env iso_fortran_env->module~vecfor iso_fortran_env->module~flow_conservative_compressible iso_fortran_env->module~flow_primitive_compressible module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf var panprogramflow_test_primitive_compressible_eqUsesGraph = svgPanZoom('#programflow_test_primitive_compressible_eqUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FLOw test. Variables primitive1 primitive2 test_passed velocity Source Code flow_test_primitive_compressible_eq Variables Type Attributes Name Initial type( primitive_compressible ) :: primitive1 A primitive object. type( primitive_compressible ) :: primitive2 A primitive object. logical :: test_passed (5) List of passed tests. type(vector) :: velocity A vector object. Source Code program flow_test_primitive_compressible_eq !< FLOw test. use flow , only : primitive_compressible use penf , only : R8P use vecfor , only : vector implicit none type ( primitive_compressible ) :: primitive1 !< A primitive object. type ( primitive_compressible ) :: primitive2 !< A primitive object. type ( vector ) :: velocity !< A vector object. logical :: test_passed ( 5 ) !< List of passed tests. test_passed = . false . velocity = 1._R8P primitive1 = primitive_compressible ( density = 0.125_R8P , velocity = velocity , pressure = 1._R8P ) velocity = 1._R8P primitive2 = primitive_compressible ( density = 1._R8P , velocity = velocity , pressure = 1._R8P ) test_passed ( 1 ) = ( primitive1 == primitive2 ). eqv .(. false .) print \"(A,L1)\" , 'density  => 0.125 /= 1 = ' , test_passed ( 1 ) velocity = 1._R8P primitive1 = primitive_compressible ( density = 0.125_R8P , velocity = velocity , pressure = 1._R8P ) velocity = 2._R8P primitive2 = primitive_compressible ( density = 0.125_R8P , velocity = velocity , pressure = 1._R8P ) test_passed ( 2 ) = ( primitive1 == primitive2 ). eqv .(. false .) print \"(A,L1)\" , 'velocity => 1     /= 2 = ' , test_passed ( 2 ) velocity = 1._R8P primitive1 = primitive_compressible ( density = 0.125_R8P , velocity = velocity , pressure = 1._R8P ) velocity = 2._R8P primitive2 = primitive_compressible ( density = 0.125_R8P , velocity = velocity , pressure = 2._R8P ) test_passed ( 3 ) = ( primitive1 == primitive2 ). eqv .(. false .) print \"(A,L1)\" , 'pressure => 1     /= 2 = ' , test_passed ( 3 ) velocity = 1._R8P primitive1 = primitive_compressible ( density = 0.125_R8P , velocity = velocity , pressure = 1._R8P ) velocity = 2._R8P primitive2 = primitive_compressible ( density = 1._R8P , velocity = velocity , pressure = 2._R8P ) test_passed ( 4 ) = ( primitive1 == primitive2 ). eqv .(. false .) print \"(A)\" , new_line ( 'a' ) // 'all together' print \"(A,L1)\" , 'density  => 0.125 /= 1 = ' , test_passed ( 4 ) print \"(A,L1)\" , 'velocity => 1     /= 2 = ' , test_passed ( 4 ) print \"(A,L1)\" , 'pressure => 1     /= 2 = ' , test_passed ( 4 ) velocity = 1._R8P primitive1 = primitive_compressible ( density = 1._R8P , velocity = velocity , pressure = 1._R8P ) velocity = 1._R8P primitive2 = primitive_compressible ( density = 1._R8P , velocity = velocity , pressure = 1._R8P ) test_passed ( 5 ) = ( primitive1 == primitive2 ). eqv .(. true .) print \"(A)\" , new_line ( 'a' ) // 'all together true' print \"(A,L1)\" , 'density  => 1 == 1 = ' , test_passed ( 5 ) print \"(A,L1)\" , 'velocity => 1 == 1 = ' , test_passed ( 5 ) print \"(A,L1)\" , 'pressure => 1 == 1 = ' , test_passed ( 5 ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram flow_test_primitive_compressible_eq","tags":"","loc":"program/flow_test_primitive_compressible_eq.html","title":"flow_test_primitive_compressible_eq – FLOw"},{"text":"Uses: flow penf VecFor program~~flow_test_primitive_compressible_mul~~UsesGraph program~flow_test_primitive_compressible_mul flow_test_primitive_compressible_mul module~flow flow module~flow->program~flow_test_primitive_compressible_mul module~vecfor VecFor module~vecfor->program~flow_test_primitive_compressible_mul module~flow_primitive_compressible_multispecie flow_primitive_compressible_multispecie module~vecfor->module~flow_primitive_compressible_multispecie module~flow_field_scalar_vectorial flow_field_scalar_vectorial module~vecfor->module~flow_field_scalar_vectorial module~flow_conservative_object flow_conservative_object module~vecfor->module~flow_conservative_object module~flow_compressible_transformations flow_compressible_transformations module~vecfor->module~flow_compressible_transformations module~flow_conservative_compressible flow_conservative_compressible module~vecfor->module~flow_conservative_compressible module~flow_primitive_compressible flow_primitive_compressible module~vecfor->module~flow_primitive_compressible module~flow_primitive_object flow_primitive_object module~vecfor->module~flow_primitive_object module~penf penf module~penf->program~flow_test_primitive_compressible_mul module~penf->module~flow_primitive_compressible_multispecie module~flow_eos_object flow_eos_object module~penf->module~flow_eos_object module~penf->module~flow_field_scalar_vectorial module~flow_field_object flow_field_object module~penf->module~flow_field_object module~penf->module~flow_conservative_object module~penf->module~flow_compressible_transformations module~flow_eos_compressible flow_eos_compressible module~penf->module~flow_eos_compressible module~penf->module~flow_conservative_compressible module~penf->module~flow_primitive_compressible module~penf->module~flow_primitive_object module~flow_primitive_compressible_multispecie->module~flow module~flow_eos_object->module~flow module~flow_eos_object->module~flow_primitive_compressible_multispecie module~flow_eos_object->module~flow_conservative_object module~flow_eos_object->module~flow_compressible_transformations module~flow_eos_object->module~flow_eos_compressible module~flow_eos_object->module~flow_conservative_compressible module~flow_eos_object->module~flow_primitive_compressible module~flow_eos_object->module~flow_primitive_object module~flow_field_scalar_vectorial->module~flow module~flow_field_object->module~flow module~flow_field_object->module~flow_primitive_compressible_multispecie module~flow_field_object->module~flow_field_scalar_vectorial module~flow_field_object->module~flow_conservative_object module~flow_field_object->module~flow_conservative_compressible module~flow_field_object->module~flow_primitive_compressible module~flow_field_object->module~flow_primitive_object module~flow_conservative_object->module~flow module~flow_conservative_object->module~flow_conservative_compressible module~flow_compressible_transformations->module~flow module~flow_eos_compressible->module~flow module~flow_conservative_compressible->module~flow module~flow_conservative_compressible->module~flow_compressible_transformations module~flow_primitive_compressible->module~flow module~flow_primitive_compressible->module~flow_compressible_transformations module~flow_primitive_object->module~flow module~flow_primitive_object->module~flow_primitive_compressible_multispecie module~flow_primitive_object->module~flow_primitive_compressible iso_fortran_env iso_fortran_env iso_fortran_env->module~vecfor iso_fortran_env->module~flow_conservative_compressible iso_fortran_env->module~flow_primitive_compressible module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf var panprogramflow_test_primitive_compressible_mulUsesGraph = svgPanZoom('#programflow_test_primitive_compressible_mulUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FLOw test. Calls program~~flow_test_primitive_compressible_mul~~CallsGraph program~flow_test_primitive_compressible_mul flow_test_primitive_compressible_mul proc~print_error~4 print_error program~flow_test_primitive_compressible_mul->proc~print_error~4 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Variables primitive1 primitive2 primitive3 test_passed velocity Subroutines print_error Source Code flow_test_primitive_compressible_mul Variables Type Attributes Name Initial type( primitive_compressible ) :: primitive1 A primitive object. type( primitive_compressible ) :: primitive2 A primitive object. type( primitive_compressible ) :: primitive3 A primitive object. logical :: test_passed (5) List of passed tests. type(vector) :: velocity A vector object. Subroutines subroutine print_error (test, is_test_passed) Print error message if test is failed. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: test Test description. logical, intent(in) :: is_test_passed Test result. Source Code program flow_test_primitive_compressible_mul !< FLOw test. use flow , only : primitive_compressible use penf , only : I4P , R8P use vecfor , only : vector implicit none type ( primitive_compressible ) :: primitive1 !< A primitive object. type ( primitive_compressible ) :: primitive2 !< A primitive object. type ( primitive_compressible ) :: primitive3 !< A primitive object. type ( vector ) :: velocity !< A vector object. logical :: test_passed ( 5 ) !< List of passed tests. test_passed = . false . velocity = 1._R8P primitive1 = primitive_compressible ( density = 0.125_R8P , velocity = velocity , pressure = 1._R8P ) velocity = 2._R8P primitive2 = primitive_compressible ( density = 1._R8P , velocity = velocity , pressure = 1._R8P ) primitive3 = primitive1 * primitive2 test_passed ( 1 ) = primitive3 == ( primitive1 * primitive2 ) print \"(A,F6.3)\" , 'density   => 0.125  * 1 = ' , primitive3 % density print \"(A,3(F6.3,1X))\" , 'velocity  => 1      * 2 = ' , primitive3 % velocity print \"(A,F6.3)\" , 'pressure  => 1      * 1 = ' , primitive3 % pressure call print_error ( test = 'primitive3 = primitive1 * primitive2' , is_test_passed = test_passed ( 1 )) primitive3 = 2._R8P * primitive1 test_passed ( 2 ) = primitive3 == ( 2._R8P * primitive1 ) print \"(A)\" , '' print \"(A,F6.3)\" , 'density   => 2.0 * 0.125  = ' , primitive3 % density print \"(A,3(F6.3,1X))\" , 'velocity  => 2.0 * 1      = ' , primitive3 % velocity print \"(A,F6.3)\" , 'pressure  => 2.0 * 1      = ' , primitive3 % pressure call print_error ( test = 'primitive3 = 2.0 * primitive1' , is_test_passed = test_passed ( 2 )) primitive3 = primitive1 * 2._R8P test_passed ( 3 ) = primitive3 == ( primitive1 * 2._R8P ) print \"(A)\" , '' print \"(A,F6.3)\" , 'density   => 0.125  * 2.0 = ' , primitive3 % density print \"(A,3(F6.3,1X))\" , 'velocity  => 1      * 2.0 = ' , primitive3 % velocity print \"(A,F6.3)\" , 'pressure  => 1      * 2.0 = ' , primitive3 % pressure call print_error ( test = 'primitive3 = primitive1 * 2.0' , is_test_passed = test_passed ( 3 )) primitive3 = 2_I4P * primitive1 test_passed ( 4 ) = primitive3 == ( 2_I4P * primitive1 ) print \"(A)\" , '' print \"(A,F6.3)\" , 'density   => 2 * 0.125  = ' , primitive3 % density print \"(A,3(F6.3,1X))\" , 'velocity  => 2 * 1      = ' , primitive3 % velocity print \"(A,F6.3)\" , 'pressure  => 2 * 1      = ' , primitive3 % pressure call print_error ( test = 'primitive3 = 2 * primitive1' , is_test_passed = test_passed ( 4 )) primitive3 = primitive1 * 2_I4P test_passed ( 5 ) = primitive3 == ( primitive1 * 2_I4P ) print \"(A)\" , '' print \"(A,F6.3)\" , 'density   => 0.125  * 2 = ' , primitive3 % density print \"(A,3(F6.3,1X))\" , 'velocity  => 1      * 2 = ' , primitive3 % velocity print \"(A,F6.3)\" , 'pressure  => 1      * 2 = ' , primitive3 % pressure call print_error ( test = 'primitive3 = primitive1 * 2' , is_test_passed = test_passed ( 5 )) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) contains subroutine print_error ( test , is_test_passed ) !< Print error message if test is failed. character ( * ), intent ( in ) :: test !< Test description. logical , intent ( in ) :: is_test_passed !< Test result. if (. not . is_test_passed ) then print * , '\"' // test // '\" failed!' print * , 'primitive1:' print \"(A,F6.3)\" , '  density   = ' , primitive1 % density print \"(A,3(F6.3,1X))\" , '  velocity  = ' , primitive1 % velocity print \"(A,F6.3)\" , '  pressure  = ' , primitive1 % pressure print * , 'primitive2:' print \"(A,F6.3)\" , '  density   = ' , primitive2 % density print \"(A,3(F6.3,1X))\" , '  velocity  = ' , primitive2 % velocity print \"(A,F6.3)\" , '  pressure  = ' , primitive2 % pressure print * , 'primitive3:' print \"(A,F6.3)\" , '  density   = ' , primitive3 % density print \"(A,3(F6.3,1X))\" , '  velocity  = ' , primitive3 % velocity print \"(A,F6.3)\" , '  pressure  = ' , primitive3 % pressure endif endsubroutine print_error endprogram flow_test_primitive_compressible_mul","tags":"","loc":"program/flow_test_primitive_compressible_mul.html","title":"flow_test_primitive_compressible_mul – FLOw"},{"text":"Uses: flow penf VecFor program~~flow_test_primitive_compressible_multispecie_add~~UsesGraph program~flow_test_primitive_compressible_multispecie_add flow_test_primitive_compressible_multispecie_add module~flow flow module~flow->program~flow_test_primitive_compressible_multispecie_add module~vecfor VecFor module~vecfor->program~flow_test_primitive_compressible_multispecie_add module~flow_primitive_compressible_multispecie flow_primitive_compressible_multispecie module~vecfor->module~flow_primitive_compressible_multispecie module~flow_field_scalar_vectorial flow_field_scalar_vectorial module~vecfor->module~flow_field_scalar_vectorial module~flow_conservative_object flow_conservative_object module~vecfor->module~flow_conservative_object module~flow_compressible_transformations flow_compressible_transformations module~vecfor->module~flow_compressible_transformations module~flow_conservative_compressible flow_conservative_compressible module~vecfor->module~flow_conservative_compressible module~flow_primitive_compressible flow_primitive_compressible module~vecfor->module~flow_primitive_compressible module~flow_primitive_object flow_primitive_object module~vecfor->module~flow_primitive_object module~penf penf module~penf->program~flow_test_primitive_compressible_multispecie_add module~penf->module~flow_primitive_compressible_multispecie module~flow_eos_object flow_eos_object module~penf->module~flow_eos_object module~penf->module~flow_field_scalar_vectorial module~flow_field_object flow_field_object module~penf->module~flow_field_object module~penf->module~flow_conservative_object module~penf->module~flow_compressible_transformations module~flow_eos_compressible flow_eos_compressible module~penf->module~flow_eos_compressible module~penf->module~flow_conservative_compressible module~penf->module~flow_primitive_compressible module~penf->module~flow_primitive_object module~flow_primitive_compressible_multispecie->module~flow module~flow_eos_object->module~flow module~flow_eos_object->module~flow_primitive_compressible_multispecie module~flow_eos_object->module~flow_conservative_object module~flow_eos_object->module~flow_compressible_transformations module~flow_eos_object->module~flow_eos_compressible module~flow_eos_object->module~flow_conservative_compressible module~flow_eos_object->module~flow_primitive_compressible module~flow_eos_object->module~flow_primitive_object module~flow_field_scalar_vectorial->module~flow module~flow_field_object->module~flow module~flow_field_object->module~flow_primitive_compressible_multispecie module~flow_field_object->module~flow_field_scalar_vectorial module~flow_field_object->module~flow_conservative_object module~flow_field_object->module~flow_conservative_compressible module~flow_field_object->module~flow_primitive_compressible module~flow_field_object->module~flow_primitive_object module~flow_conservative_object->module~flow module~flow_conservative_object->module~flow_conservative_compressible module~flow_compressible_transformations->module~flow module~flow_eos_compressible->module~flow module~flow_conservative_compressible->module~flow module~flow_conservative_compressible->module~flow_compressible_transformations module~flow_primitive_compressible->module~flow module~flow_primitive_compressible->module~flow_compressible_transformations module~flow_primitive_object->module~flow module~flow_primitive_object->module~flow_primitive_compressible_multispecie module~flow_primitive_object->module~flow_primitive_compressible iso_fortran_env iso_fortran_env iso_fortran_env->module~vecfor iso_fortran_env->module~flow_conservative_compressible iso_fortran_env->module~flow_primitive_compressible module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf var panprogramflow_test_primitive_compressible_multispecie_addUsesGraph = svgPanZoom('#programflow_test_primitive_compressible_multispecie_addUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FLOw test. Variables primitive1 primitive2 primitive3 test_passed velocity Source Code flow_test_primitive_compressible_multispecie_add Variables Type Attributes Name Initial type( primitive_compressible_multispecie ) :: primitive1 A primitive object. type( primitive_compressible_multispecie ) :: primitive2 A primitive object. type( primitive_compressible_multispecie ) :: primitive3 A primitive object. logical :: test_passed (2) List of passed tests. type(vector) :: velocity A vector object. Source Code program flow_test_primitive_compressible_multispecie_add !< FLOw test. use flow , only : primitive_compressible_multispecie use penf , only : R8P use vecfor , only : vector implicit none type ( primitive_compressible_multispecie ) :: primitive1 !< A primitive object. type ( primitive_compressible_multispecie ) :: primitive2 !< A primitive object. type ( primitive_compressible_multispecie ) :: primitive3 !< A primitive object. type ( vector ) :: velocity !< A vector object. logical :: test_passed ( 2 ) !< List of passed tests. test_passed = . false . velocity = 1._R8P primitive1 = primitive_compressible_multispecie ( density = 0.125_R8P , & velocity = velocity , & pressure = 1._R8P , & partial_densities = [ 0.125_R8P / 2 , 0.125_R8P / 2 ]) velocity = 2._R8P primitive2 = primitive_compressible_multispecie ( density = 1._R8P , & velocity = velocity , & pressure = 1._R8P , & partial_densities = [ 1._R8P / 2 , 1._R8P / 2 ]) primitive3 = primitive1 + primitive2 test_passed ( 1 ) = primitive3 == ( primitive1 + primitive2 ) print \"(A,F6.3)\" , 'density   => 0.125  + 1   = ' , primitive3 % density print \"(A,3(F6.3,1X))\" , 'velocity  => 1      + 2   = ' , primitive3 % velocity print \"(A,F6.3)\" , 'pressure  => 1      + 1   = ' , primitive3 % pressure print \"(A,2(F7.4,1X))\" , 'densities => 0.0625 + 0.5 = ' , primitive3 % partial_densities velocity = - 1._R8P primitive1 = primitive_compressible_multispecie ( density = 0.125_R8P , velocity = velocity , pressure = 1._R8P , & partial_densities = [ 0.125_R8P / 2 , 0.125_R8P / 2 ]) primitive2 = + primitive1 test_passed ( 2 ) = primitive2 == primitive1 print \"(A,F6.3)\" , 'density   => + (0.125)  = ' , primitive2 % density print \"(A,3(F6.3,1X))\" , 'velocity  => + (-1)     = ' , primitive2 % velocity print \"(A,F6.3)\" , 'pressure  => + (1)      = ' , primitive2 % pressure print \"(A,2(F7.4,1X))\" , 'densities => + (0.0625) = ' , primitive2 % partial_densities print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram flow_test_primitive_compressible_multispecie_add","tags":"","loc":"program/flow_test_primitive_compressible_multispecie_add.html","title":"flow_test_primitive_compressible_multispecie_add – FLOw"},{"text":"Uses: flow penf VecFor program~~flow_test_primitive_compressible_multispecie_assign~~UsesGraph program~flow_test_primitive_compressible_multispecie_assign flow_test_primitive_compressible_multispecie_assign module~flow flow module~flow->program~flow_test_primitive_compressible_multispecie_assign module~vecfor VecFor module~vecfor->program~flow_test_primitive_compressible_multispecie_assign module~flow_primitive_compressible_multispecie flow_primitive_compressible_multispecie module~vecfor->module~flow_primitive_compressible_multispecie module~flow_field_scalar_vectorial flow_field_scalar_vectorial module~vecfor->module~flow_field_scalar_vectorial module~flow_conservative_object flow_conservative_object module~vecfor->module~flow_conservative_object module~flow_compressible_transformations flow_compressible_transformations module~vecfor->module~flow_compressible_transformations module~flow_conservative_compressible flow_conservative_compressible module~vecfor->module~flow_conservative_compressible module~flow_primitive_compressible flow_primitive_compressible module~vecfor->module~flow_primitive_compressible module~flow_primitive_object flow_primitive_object module~vecfor->module~flow_primitive_object module~penf penf module~penf->program~flow_test_primitive_compressible_multispecie_assign module~penf->module~flow_primitive_compressible_multispecie module~flow_eos_object flow_eos_object module~penf->module~flow_eos_object module~penf->module~flow_field_scalar_vectorial module~flow_field_object flow_field_object module~penf->module~flow_field_object module~penf->module~flow_conservative_object module~penf->module~flow_compressible_transformations module~flow_eos_compressible flow_eos_compressible module~penf->module~flow_eos_compressible module~penf->module~flow_conservative_compressible module~penf->module~flow_primitive_compressible module~penf->module~flow_primitive_object module~flow_primitive_compressible_multispecie->module~flow module~flow_eos_object->module~flow module~flow_eos_object->module~flow_primitive_compressible_multispecie module~flow_eos_object->module~flow_conservative_object module~flow_eos_object->module~flow_compressible_transformations module~flow_eos_object->module~flow_eos_compressible module~flow_eos_object->module~flow_conservative_compressible module~flow_eos_object->module~flow_primitive_compressible module~flow_eos_object->module~flow_primitive_object module~flow_field_scalar_vectorial->module~flow module~flow_field_object->module~flow module~flow_field_object->module~flow_primitive_compressible_multispecie module~flow_field_object->module~flow_field_scalar_vectorial module~flow_field_object->module~flow_conservative_object module~flow_field_object->module~flow_conservative_compressible module~flow_field_object->module~flow_primitive_compressible module~flow_field_object->module~flow_primitive_object module~flow_conservative_object->module~flow module~flow_conservative_object->module~flow_conservative_compressible module~flow_compressible_transformations->module~flow module~flow_eos_compressible->module~flow module~flow_conservative_compressible->module~flow module~flow_conservative_compressible->module~flow_compressible_transformations module~flow_primitive_compressible->module~flow module~flow_primitive_compressible->module~flow_compressible_transformations module~flow_primitive_object->module~flow module~flow_primitive_object->module~flow_primitive_compressible_multispecie module~flow_primitive_object->module~flow_primitive_compressible iso_fortran_env iso_fortran_env iso_fortran_env->module~vecfor iso_fortran_env->module~flow_conservative_compressible iso_fortran_env->module~flow_primitive_compressible module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf var panprogramflow_test_primitive_compressible_multispecie_assignUsesGraph = svgPanZoom('#programflow_test_primitive_compressible_multispecie_assignUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FLOw test. Variables primitive1 primitive2 test_passed velocity Source Code flow_test_primitive_compressible_multispecie_assign Variables Type Attributes Name Initial type( primitive_compressible_multispecie ) :: primitive1 A primitive object. type( primitive_compressible_multispecie ) :: primitive2 A primitive object. logical :: test_passed (2) List of passed tests. type(vector) :: velocity A vector object. Source Code program flow_test_primitive_compressible_multispecie_assign !< FLOw test. use flow , only : primitive_compressible_multispecie use penf , only : R8P use vecfor , only : vector implicit none type ( primitive_compressible_multispecie ) :: primitive1 !< A primitive object. type ( primitive_compressible_multispecie ) :: primitive2 !< A primitive object. type ( vector ) :: velocity !< A vector object. logical :: test_passed ( 2 ) !< List of passed tests. test_passed = . false . primitive1 = 0.125_R8P test_passed ( 1 ) = ( primitive1 % density == 0.125_R8P ). and . & ( primitive1 % velocity % x == 0.125_R8P ). and . & ( primitive1 % velocity % y == 0.125_R8P ). and . & ( primitive1 % velocity % z == 0.125_R8P ). and . & ( primitive1 % pressure == 0.125_R8P ) print \"(A,F6.3)\" , 'density   = ' , primitive1 % density print \"(A,3(F6.3,1X))\" , 'velocity  = ' , primitive1 % velocity print \"(A,F6.3)\" , 'pressure  = ' , primitive1 % pressure velocity = 1._R8P primitive1 = primitive_compressible_multispecie ( density = 0.125_R8P , & velocity = velocity , & pressure = 1._R8P , & partial_densities = [ 0.125_R8P / 2 , 0.125_R8P / 2 ]) primitive2 = primitive1 test_passed ( 2 ) = primitive1 == primitive2 print \"(A)\" , '' print \"(A,F6.3)\" , 'density   = ' , primitive2 % density print \"(A,3(F6.3,1X))\" , 'velocity  = ' , primitive2 % velocity print \"(A,F6.3)\" , 'pressure  = ' , primitive2 % pressure print \"(A,2(F7.4,1X))\" , 'densities = ' , primitive2 % partial_densities ( 1 ), primitive2 % partial_densities ( 2 ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram flow_test_primitive_compressible_multispecie_assign","tags":"","loc":"program/flow_test_primitive_compressible_multispecie_assign.html","title":"flow_test_primitive_compressible_multispecie_assign – FLOw"},{"text":"Uses: flow penf VecFor program~~flow_test_primitive_compressible_multispecie_div~~UsesGraph program~flow_test_primitive_compressible_multispecie_div flow_test_primitive_compressible_multispecie_div module~flow flow module~flow->program~flow_test_primitive_compressible_multispecie_div module~vecfor VecFor module~vecfor->program~flow_test_primitive_compressible_multispecie_div module~flow_primitive_compressible_multispecie flow_primitive_compressible_multispecie module~vecfor->module~flow_primitive_compressible_multispecie module~flow_field_scalar_vectorial flow_field_scalar_vectorial module~vecfor->module~flow_field_scalar_vectorial module~flow_conservative_object flow_conservative_object module~vecfor->module~flow_conservative_object module~flow_compressible_transformations flow_compressible_transformations module~vecfor->module~flow_compressible_transformations module~flow_conservative_compressible flow_conservative_compressible module~vecfor->module~flow_conservative_compressible module~flow_primitive_compressible flow_primitive_compressible module~vecfor->module~flow_primitive_compressible module~flow_primitive_object flow_primitive_object module~vecfor->module~flow_primitive_object module~penf penf module~penf->program~flow_test_primitive_compressible_multispecie_div module~penf->module~flow_primitive_compressible_multispecie module~flow_eos_object flow_eos_object module~penf->module~flow_eos_object module~penf->module~flow_field_scalar_vectorial module~flow_field_object flow_field_object module~penf->module~flow_field_object module~penf->module~flow_conservative_object module~penf->module~flow_compressible_transformations module~flow_eos_compressible flow_eos_compressible module~penf->module~flow_eos_compressible module~penf->module~flow_conservative_compressible module~penf->module~flow_primitive_compressible module~penf->module~flow_primitive_object module~flow_primitive_compressible_multispecie->module~flow module~flow_eos_object->module~flow module~flow_eos_object->module~flow_primitive_compressible_multispecie module~flow_eos_object->module~flow_conservative_object module~flow_eos_object->module~flow_compressible_transformations module~flow_eos_object->module~flow_eos_compressible module~flow_eos_object->module~flow_conservative_compressible module~flow_eos_object->module~flow_primitive_compressible module~flow_eos_object->module~flow_primitive_object module~flow_field_scalar_vectorial->module~flow module~flow_field_object->module~flow module~flow_field_object->module~flow_primitive_compressible_multispecie module~flow_field_object->module~flow_field_scalar_vectorial module~flow_field_object->module~flow_conservative_object module~flow_field_object->module~flow_conservative_compressible module~flow_field_object->module~flow_primitive_compressible module~flow_field_object->module~flow_primitive_object module~flow_conservative_object->module~flow module~flow_conservative_object->module~flow_conservative_compressible module~flow_compressible_transformations->module~flow module~flow_eos_compressible->module~flow module~flow_conservative_compressible->module~flow module~flow_conservative_compressible->module~flow_compressible_transformations module~flow_primitive_compressible->module~flow module~flow_primitive_compressible->module~flow_compressible_transformations module~flow_primitive_object->module~flow module~flow_primitive_object->module~flow_primitive_compressible_multispecie module~flow_primitive_object->module~flow_primitive_compressible iso_fortran_env iso_fortran_env iso_fortran_env->module~vecfor iso_fortran_env->module~flow_conservative_compressible iso_fortran_env->module~flow_primitive_compressible module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf var panprogramflow_test_primitive_compressible_multispecie_divUsesGraph = svgPanZoom('#programflow_test_primitive_compressible_multispecie_divUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FLOw test. Calls program~~flow_test_primitive_compressible_multispecie_div~~CallsGraph program~flow_test_primitive_compressible_multispecie_div flow_test_primitive_compressible_multispecie_div proc~print_error~5 print_error program~flow_test_primitive_compressible_multispecie_div->proc~print_error~5 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Variables primitive1 primitive2 primitive3 test_passed velocity Subroutines print_error Source Code flow_test_primitive_compressible_multispecie_div Variables Type Attributes Name Initial type( primitive_compressible_multispecie ) :: primitive1 A primitive object. type( primitive_compressible_multispecie ) :: primitive2 A primitive object. type( primitive_compressible_multispecie ) :: primitive3 A primitive object. logical :: test_passed (3) List of passed tests. type(vector) :: velocity A vector object. Subroutines subroutine print_error (test, is_test_passed) Print error message if test is failed. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: test Test description. logical, intent(in) :: is_test_passed Test result. Source Code program flow_test_primitive_compressible_multispecie_div !< FLOw test. use flow , only : primitive_compressible_multispecie use penf , only : I4P , R8P use vecfor , only : vector implicit none type ( primitive_compressible_multispecie ) :: primitive1 !< A primitive object. type ( primitive_compressible_multispecie ) :: primitive2 !< A primitive object. type ( primitive_compressible_multispecie ) :: primitive3 !< A primitive object. type ( vector ) :: velocity !< A vector object. logical :: test_passed ( 3 ) !< List of passed tests. test_passed = . false . velocity = 1._R8P primitive1 = primitive_compressible_multispecie ( density = 0.125_R8P , & velocity = velocity , & pressure = 1._R8P , & partial_densities = [ 0.125_R8P / 2 , 0.125_R8P / 2 ]) velocity = 2._R8P primitive2 = primitive_compressible_multispecie ( density = 1._R8P , & velocity = velocity , & pressure = 1._R8P , & partial_densities = [ 1._R8P / 2 , 1._R8P / 2 ]) primitive3 = primitive1 / primitive2 test_passed ( 1 ) = primitive3 == ( primitive1 / primitive2 ) print \"(A,F6.3)\" , 'density   => 0.125  / 1   = ' , primitive3 % density print \"(A,3(F6.3,1X))\" , 'velocity  => 1      / 2   = ' , primitive3 % velocity print \"(A,F6.3)\" , 'pressure  => 1      / 1   = ' , primitive3 % pressure print \"(A,2(F7.4,1X))\" , 'densities => 0.0625 / 0.5 = ' , primitive3 % partial_densities ( 1 ), primitive3 % partial_densities ( 2 ) call print_error ( test = 'primitive3 = primitive1 / primitive2' , is_test_passed = test_passed ( 1 )) primitive3 = primitive1 / 2._R8P test_passed ( 2 ) = primitive3 == ( primitive1 / 2._R8P ) print \"(A)\" , '' print \"(A,F6.3)\" , 'density   => 0.125  / 2.0 = ' , primitive3 % density print \"(A,3(F6.3,1X))\" , 'velocity  => 1      / 2.0 = ' , primitive3 % velocity print \"(A,F6.3)\" , 'pressure  => 1      / 2.0 = ' , primitive3 % pressure print \"(A,2(F7.4,1X))\" , 'densities => 0.0625 / 2.0 = ' , primitive3 % partial_densities ( 1 ), primitive3 % partial_densities ( 2 ) call print_error ( test = 'primitive3 = primitive1 / 2.0' , is_test_passed = test_passed ( 2 )) primitive3 = primitive1 / 2_I4P test_passed ( 3 ) = primitive3 == ( primitive1 / 2_I4P ) print \"(A)\" , '' print \"(A,F6.3)\" , 'density   => 0.125  / 2 = ' , primitive3 % density print \"(A,3(F6.3,1X))\" , 'velocity  => 1      / 2 = ' , primitive3 % velocity print \"(A,F6.3)\" , 'pressure  => 1      / 2 = ' , primitive3 % pressure print \"(A,2(F7.4,1X))\" , 'densities => 0.0625 / 2 = ' , primitive3 % partial_densities ( 1 ), primitive3 % partial_densities ( 2 ) call print_error ( test = 'primitive3 = primitive1 / 2' , is_test_passed = test_passed ( 3 )) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) contains subroutine print_error ( test , is_test_passed ) !< Print error message if test is failed. character ( * ), intent ( in ) :: test !< Test description. logical , intent ( in ) :: is_test_passed !< Test result. if (. not . is_test_passed ) then print * , '\"' // test // '\" failed!' print * , 'primitive1:' print \"(A,F6.3)\" , '  density   = ' , primitive1 % density print \"(A,3(F6.3,1X))\" , '  velocity  = ' , primitive1 % velocity print \"(A,F6.3)\" , '  pressure  = ' , primitive1 % pressure print \"(A,2(F7.4,1X))\" , '  densities = ' , primitive1 % partial_densities ( 1 ), primitive1 % partial_densities ( 2 ) print * , 'primitive2:' print \"(A,F6.3)\" , '  density   = ' , primitive2 % density print \"(A,3(F6.3,1X))\" , '  velocity  = ' , primitive2 % velocity print \"(A,F6.3)\" , '  pressure  = ' , primitive2 % pressure print \"(A,2(F7.4,1X))\" , '  densities = ' , primitive2 % partial_densities ( 1 ), primitive2 % partial_densities ( 2 ) print * , 'primitive3:' print \"(A,F6.3)\" , '  density   = ' , primitive3 % density print \"(A,3(F6.3,1X))\" , '  velocity  = ' , primitive3 % velocity print \"(A,F6.3)\" , '  pressure  = ' , primitive3 % pressure print \"(A,2(F7.4,1X))\" , '  densities = ' , primitive3 % partial_densities ( 1 ), primitive3 % partial_densities ( 2 ) endif endsubroutine print_error endprogram flow_test_primitive_compressible_multispecie_div","tags":"","loc":"program/flow_test_primitive_compressible_multispecie_div.html","title":"flow_test_primitive_compressible_multispecie_div – FLOw"},{"text":"Uses: flow penf VecFor program~~flow_test_primitive_compressible_multispecie_eq~~UsesGraph program~flow_test_primitive_compressible_multispecie_eq flow_test_primitive_compressible_multispecie_eq module~flow flow module~flow->program~flow_test_primitive_compressible_multispecie_eq module~vecfor VecFor module~vecfor->program~flow_test_primitive_compressible_multispecie_eq module~flow_primitive_compressible_multispecie flow_primitive_compressible_multispecie module~vecfor->module~flow_primitive_compressible_multispecie module~flow_field_scalar_vectorial flow_field_scalar_vectorial module~vecfor->module~flow_field_scalar_vectorial module~flow_conservative_object flow_conservative_object module~vecfor->module~flow_conservative_object module~flow_compressible_transformations flow_compressible_transformations module~vecfor->module~flow_compressible_transformations module~flow_conservative_compressible flow_conservative_compressible module~vecfor->module~flow_conservative_compressible module~flow_primitive_compressible flow_primitive_compressible module~vecfor->module~flow_primitive_compressible module~flow_primitive_object flow_primitive_object module~vecfor->module~flow_primitive_object module~penf penf module~penf->program~flow_test_primitive_compressible_multispecie_eq module~penf->module~flow_primitive_compressible_multispecie module~flow_eos_object flow_eos_object module~penf->module~flow_eos_object module~penf->module~flow_field_scalar_vectorial module~flow_field_object flow_field_object module~penf->module~flow_field_object module~penf->module~flow_conservative_object module~penf->module~flow_compressible_transformations module~flow_eos_compressible flow_eos_compressible module~penf->module~flow_eos_compressible module~penf->module~flow_conservative_compressible module~penf->module~flow_primitive_compressible module~penf->module~flow_primitive_object module~flow_primitive_compressible_multispecie->module~flow module~flow_eos_object->module~flow module~flow_eos_object->module~flow_primitive_compressible_multispecie module~flow_eos_object->module~flow_conservative_object module~flow_eos_object->module~flow_compressible_transformations module~flow_eos_object->module~flow_eos_compressible module~flow_eos_object->module~flow_conservative_compressible module~flow_eos_object->module~flow_primitive_compressible module~flow_eos_object->module~flow_primitive_object module~flow_field_scalar_vectorial->module~flow module~flow_field_object->module~flow module~flow_field_object->module~flow_primitive_compressible_multispecie module~flow_field_object->module~flow_field_scalar_vectorial module~flow_field_object->module~flow_conservative_object module~flow_field_object->module~flow_conservative_compressible module~flow_field_object->module~flow_primitive_compressible module~flow_field_object->module~flow_primitive_object module~flow_conservative_object->module~flow module~flow_conservative_object->module~flow_conservative_compressible module~flow_compressible_transformations->module~flow module~flow_eos_compressible->module~flow module~flow_conservative_compressible->module~flow module~flow_conservative_compressible->module~flow_compressible_transformations module~flow_primitive_compressible->module~flow module~flow_primitive_compressible->module~flow_compressible_transformations module~flow_primitive_object->module~flow module~flow_primitive_object->module~flow_primitive_compressible_multispecie module~flow_primitive_object->module~flow_primitive_compressible iso_fortran_env iso_fortran_env iso_fortran_env->module~vecfor iso_fortran_env->module~flow_conservative_compressible iso_fortran_env->module~flow_primitive_compressible module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf var panprogramflow_test_primitive_compressible_multispecie_eqUsesGraph = svgPanZoom('#programflow_test_primitive_compressible_multispecie_eqUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FLOw test. Variables primitive1 primitive2 test_passed velocity Source Code flow_test_primitive_compressible_multispecie_eq Variables Type Attributes Name Initial type( primitive_compressible_multispecie ) :: primitive1 A primitive object. type( primitive_compressible_multispecie ) :: primitive2 A primitive object. logical :: test_passed (8) List of passed tests. type(vector) :: velocity A vector object. Source Code program flow_test_primitive_compressible_multispecie_eq !< FLOw test. use flow , only : primitive_compressible_multispecie use penf , only : R8P use vecfor , only : vector implicit none type ( primitive_compressible_multispecie ) :: primitive1 !< A primitive object. type ( primitive_compressible_multispecie ) :: primitive2 !< A primitive object. type ( vector ) :: velocity !< A vector object. logical :: test_passed ( 8 ) !< List of passed tests. test_passed = . false . velocity = 1._R8P primitive1 = primitive_compressible_multispecie ( density = 0.125_R8P , velocity = velocity , pressure = 1._R8P ) velocity = 1._R8P primitive2 = primitive_compressible_multispecie ( density = 1._R8P , velocity = velocity , pressure = 1._R8P ) test_passed ( 1 ) = ( primitive1 == primitive2 ). eqv .(. false .) print \"(A,L1)\" , 'density  => 0.125 /= 1 = ' , test_passed ( 1 ) velocity = 1._R8P primitive1 = primitive_compressible_multispecie ( density = 0.125_R8P , velocity = velocity , pressure = 1._R8P ) velocity = 2._R8P primitive2 = primitive_compressible_multispecie ( density = 0.125_R8P , velocity = velocity , pressure = 1._R8P ) test_passed ( 2 ) = ( primitive1 == primitive2 ). eqv .(. false .) print \"(A,L1)\" , 'velocity => 1     /= 2 = ' , test_passed ( 2 ) velocity = 1._R8P primitive1 = primitive_compressible_multispecie ( density = 0.125_R8P , velocity = velocity , pressure = 1._R8P ) velocity = 2._R8P primitive2 = primitive_compressible_multispecie ( density = 0.125_R8P , velocity = velocity , pressure = 2._R8P ) test_passed ( 3 ) = ( primitive1 == primitive2 ). eqv .(. false .) print \"(A,L1)\" , 'pressure => 1     /= 2 = ' , test_passed ( 3 ) velocity = 1._R8P primitive1 = primitive_compressible_multispecie ( density = 0.125_R8P , velocity = velocity , pressure = 1._R8P ) velocity = 2._R8P primitive2 = primitive_compressible_multispecie ( density = 1._R8P , velocity = velocity , pressure = 2._R8P ) test_passed ( 4 ) = ( primitive1 == primitive2 ). eqv .(. false .) print \"(A)\" , new_line ( 'a' ) // 'all together' print \"(A,L1)\" , 'density  => 0.125 /= 1 = ' , test_passed ( 4 ) print \"(A,L1)\" , 'velocity => 1     /= 2 = ' , test_passed ( 4 ) print \"(A,L1)\" , 'pressure => 1     /= 2 = ' , test_passed ( 4 ) velocity = 1._R8P primitive1 = primitive_compressible_multispecie ( density = 1._R8P , velocity = velocity , pressure = 1._R8P ) velocity = 1._R8P primitive2 = primitive_compressible_multispecie ( density = 1._R8P , velocity = velocity , pressure = 1._R8P ) test_passed ( 5 ) = ( primitive1 == primitive2 ). eqv .(. true .) print \"(A)\" , new_line ( 'a' ) // 'all together true' print \"(A,L1)\" , 'density  => 1 == 1 = ' , test_passed ( 5 ) print \"(A,L1)\" , 'velocity => 1 == 1 = ' , test_passed ( 5 ) print \"(A,L1)\" , 'pressure => 1 == 1 = ' , test_passed ( 5 ) velocity = 1._R8P primitive1 = primitive_compressible_multispecie ( density = 1._R8P , velocity = velocity , pressure = 1._R8P , partial_densities = [ 0.5_R8P ]) velocity = 1._R8P primitive2 = primitive_compressible_multispecie ( density = 1._R8P , velocity = velocity , pressure = 1._R8P ) test_passed ( 6 ) = ( primitive1 == primitive2 ). eqv .(. false .) print \"(A)\" , new_line ( 'a' ) // 'all together true with imcompatible densities' print \"(A,L1)\" , 'density   => 1   == 1    = ' , test_passed ( 6 ) print \"(A,L1)\" , 'velocity  => 1   == 1    = ' , test_passed ( 6 ) print \"(A,L1)\" , 'pressure  => 1   == 1    = ' , test_passed ( 6 ) print \"(A,L1)\" , 'densities => 0.5 /= null = ' , test_passed ( 6 ) velocity = 1._R8P primitive1 = primitive_compressible_multispecie ( density = 1._R8P , velocity = velocity , pressure = 1._R8P , partial_densities = [ 0.5_R8P ]) velocity = 1._R8P primitive2 = primitive_compressible_multispecie ( density = 1._R8P , velocity = velocity , pressure = 1._R8P , partial_densities = [ 0.1_R8P ]) test_passed ( 7 ) = ( primitive1 == primitive2 ). eqv .(. false .) print \"(A)\" , new_line ( 'a' ) // 'all together true with different densities' print \"(A,L1)\" , 'density   => 1   == 1   = ' , test_passed ( 7 ) print \"(A,L1)\" , 'velocity  => 1   == 1   = ' , test_passed ( 7 ) print \"(A,L1)\" , 'pressure  => 1   == 1   = ' , test_passed ( 7 ) print \"(A,L1)\" , 'densities => 0.5 /= 0.1 = ' , test_passed ( 7 ) velocity = 1._R8P primitive1 = primitive_compressible_multispecie ( density = 1._R8P , velocity = velocity , pressure = 1._R8P , partial_densities = [ 0.5_R8P ]) velocity = 1._R8P primitive2 = primitive_compressible_multispecie ( density = 1._R8P , velocity = velocity , pressure = 1._R8P , partial_densities = [ 0.5_R8P ]) test_passed ( 8 ) = ( primitive1 == primitive2 ). eqv .(. true .) print \"(A)\" , new_line ( 'a' ) // 'all together true with densities' print \"(A,L1)\" , 'density   => 1   == 1   = ' , test_passed ( 8 ) print \"(A,L1)\" , 'velocity  => 1   == 1   = ' , test_passed ( 8 ) print \"(A,L1)\" , 'pressure  => 1   == 1   = ' , test_passed ( 8 ) print \"(A,L1)\" , 'densities => 0.5 == 0.5 = ' , test_passed ( 8 ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram flow_test_primitive_compressible_multispecie_eq","tags":"","loc":"program/flow_test_primitive_compressible_multispecie_eq.html","title":"flow_test_primitive_compressible_multispecie_eq – FLOw"},{"text":"Uses: flow penf VecFor program~~flow_test_primitive_compressible_multispecie_mul~~UsesGraph program~flow_test_primitive_compressible_multispecie_mul flow_test_primitive_compressible_multispecie_mul module~flow flow module~flow->program~flow_test_primitive_compressible_multispecie_mul module~vecfor VecFor module~vecfor->program~flow_test_primitive_compressible_multispecie_mul module~flow_primitive_compressible_multispecie flow_primitive_compressible_multispecie module~vecfor->module~flow_primitive_compressible_multispecie module~flow_field_scalar_vectorial flow_field_scalar_vectorial module~vecfor->module~flow_field_scalar_vectorial module~flow_conservative_object flow_conservative_object module~vecfor->module~flow_conservative_object module~flow_compressible_transformations flow_compressible_transformations module~vecfor->module~flow_compressible_transformations module~flow_conservative_compressible flow_conservative_compressible module~vecfor->module~flow_conservative_compressible module~flow_primitive_compressible flow_primitive_compressible module~vecfor->module~flow_primitive_compressible module~flow_primitive_object flow_primitive_object module~vecfor->module~flow_primitive_object module~penf penf module~penf->program~flow_test_primitive_compressible_multispecie_mul module~penf->module~flow_primitive_compressible_multispecie module~flow_eos_object flow_eos_object module~penf->module~flow_eos_object module~penf->module~flow_field_scalar_vectorial module~flow_field_object flow_field_object module~penf->module~flow_field_object module~penf->module~flow_conservative_object module~penf->module~flow_compressible_transformations module~flow_eos_compressible flow_eos_compressible module~penf->module~flow_eos_compressible module~penf->module~flow_conservative_compressible module~penf->module~flow_primitive_compressible module~penf->module~flow_primitive_object module~flow_primitive_compressible_multispecie->module~flow module~flow_eos_object->module~flow module~flow_eos_object->module~flow_primitive_compressible_multispecie module~flow_eos_object->module~flow_conservative_object module~flow_eos_object->module~flow_compressible_transformations module~flow_eos_object->module~flow_eos_compressible module~flow_eos_object->module~flow_conservative_compressible module~flow_eos_object->module~flow_primitive_compressible module~flow_eos_object->module~flow_primitive_object module~flow_field_scalar_vectorial->module~flow module~flow_field_object->module~flow module~flow_field_object->module~flow_primitive_compressible_multispecie module~flow_field_object->module~flow_field_scalar_vectorial module~flow_field_object->module~flow_conservative_object module~flow_field_object->module~flow_conservative_compressible module~flow_field_object->module~flow_primitive_compressible module~flow_field_object->module~flow_primitive_object module~flow_conservative_object->module~flow module~flow_conservative_object->module~flow_conservative_compressible module~flow_compressible_transformations->module~flow module~flow_eos_compressible->module~flow module~flow_conservative_compressible->module~flow module~flow_conservative_compressible->module~flow_compressible_transformations module~flow_primitive_compressible->module~flow module~flow_primitive_compressible->module~flow_compressible_transformations module~flow_primitive_object->module~flow module~flow_primitive_object->module~flow_primitive_compressible_multispecie module~flow_primitive_object->module~flow_primitive_compressible iso_fortran_env iso_fortran_env iso_fortran_env->module~vecfor iso_fortran_env->module~flow_conservative_compressible iso_fortran_env->module~flow_primitive_compressible module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf var panprogramflow_test_primitive_compressible_multispecie_mulUsesGraph = svgPanZoom('#programflow_test_primitive_compressible_multispecie_mulUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FLOw test. Calls program~~flow_test_primitive_compressible_multispecie_mul~~CallsGraph program~flow_test_primitive_compressible_multispecie_mul flow_test_primitive_compressible_multispecie_mul proc~print_error~6 print_error program~flow_test_primitive_compressible_multispecie_mul->proc~print_error~6 Help × Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \n    arrows point from an interface to procedures which implement that interface.\n    This could include the module procedures in a generic interface or the\n    implementation in a submodule of an interface in a parent module. Variables primitive1 primitive2 primitive3 test_passed velocity Subroutines print_error Source Code flow_test_primitive_compressible_multispecie_mul Variables Type Attributes Name Initial type( primitive_compressible_multispecie ) :: primitive1 A primitive object. type( primitive_compressible_multispecie ) :: primitive2 A primitive object. type( primitive_compressible_multispecie ) :: primitive3 A primitive object. logical :: test_passed (5) List of passed tests. type(vector) :: velocity A vector object. Subroutines subroutine print_error (test, is_test_passed) Print error message if test is failed. Arguments Type Intent Optional Attributes Name character(len=*), intent(in) :: test Test description. logical, intent(in) :: is_test_passed Test result. Source Code program flow_test_primitive_compressible_multispecie_mul !< FLOw test. use flow , only : primitive_compressible_multispecie use penf , only : I4P , R8P use vecfor , only : vector implicit none type ( primitive_compressible_multispecie ) :: primitive1 !< A primitive object. type ( primitive_compressible_multispecie ) :: primitive2 !< A primitive object. type ( primitive_compressible_multispecie ) :: primitive3 !< A primitive object. type ( vector ) :: velocity !< A vector object. logical :: test_passed ( 5 ) !< List of passed tests. test_passed = . false . velocity = 1._R8P primitive1 = primitive_compressible_multispecie ( density = 0.125_R8P , & velocity = velocity , & pressure = 1._R8P , & partial_densities = [ 0.125_R8P / 2 , 0.125_R8P / 2 ]) velocity = 2._R8P primitive2 = primitive_compressible_multispecie ( density = 1._R8P , & velocity = velocity , & pressure = 1._R8P , & partial_densities = [ 1._R8P / 2 , 1._R8P / 2 ]) primitive3 = primitive1 * primitive2 test_passed ( 1 ) = primitive3 == ( primitive1 * primitive2 ) print \"(A,F6.3)\" , 'density   => 0.125  * 1 = ' , primitive3 % density print \"(A,3(F6.3,1X))\" , 'velocity  => 1      * 2 = ' , primitive3 % velocity print \"(A,F6.3)\" , 'pressure  => 1      * 1 = ' , primitive3 % pressure print \"(A,2(F7.4,1X))\" , 'densities => 0.0625 * 0.5 = ' , primitive3 % partial_densities ( 1 ), primitive3 % partial_densities ( 2 ) call print_error ( test = 'primitive3 = primitive1 * primitive2' , is_test_passed = test_passed ( 1 )) primitive3 = 2._R8P * primitive1 test_passed ( 2 ) = primitive3 == ( 2._R8P * primitive1 ) print \"(A)\" , '' print \"(A,F6.3)\" , 'density   => 2.0 * 0.125  = ' , primitive3 % density print \"(A,3(F6.3,1X))\" , 'velocity  => 2.0 * 1      = ' , primitive3 % velocity print \"(A,F6.3)\" , 'pressure  => 2.0 * 1      = ' , primitive3 % pressure print \"(A,2(F7.4,1X))\" , 'densities => 2.0 * 0.0625 = ' , primitive3 % partial_densities ( 1 ), primitive3 % partial_densities ( 2 ) call print_error ( test = 'primitive3 = 2.0 * primitive1' , is_test_passed = test_passed ( 2 )) primitive3 = primitive1 * 2._R8P test_passed ( 3 ) = primitive3 == ( primitive1 * 2._R8P ) print \"(A)\" , '' print \"(A,F6.3)\" , 'density   => 0.125  * 2.0 = ' , primitive3 % density print \"(A,3(F6.3,1X))\" , 'velocity  => 1      * 2.0 = ' , primitive3 % velocity print \"(A,F6.3)\" , 'pressure  => 1      * 2.0 = ' , primitive3 % pressure print \"(A,2(F7.4,1X))\" , 'densities => 0.0625 * 2.0 = ' , primitive3 % partial_densities ( 1 ), primitive3 % partial_densities ( 2 ) call print_error ( test = 'primitive3 = primitive1 * 2.0' , is_test_passed = test_passed ( 3 )) primitive3 = 2_I4P * primitive1 test_passed ( 4 ) = primitive3 == ( 2_I4P * primitive1 ) print \"(A)\" , '' print \"(A,F6.3)\" , 'density   => 2 * 0.125  = ' , primitive3 % density print \"(A,3(F6.3,1X))\" , 'velocity  => 2 * 1      = ' , primitive3 % velocity print \"(A,F6.3)\" , 'pressure  => 2 * 1      = ' , primitive3 % pressure print \"(A,2(F7.4,1X))\" , 'densities => 2 * 0.0625 = ' , primitive3 % partial_densities ( 1 ), primitive3 % partial_densities ( 2 ) call print_error ( test = 'primitive3 = 2 * primitive1' , is_test_passed = test_passed ( 4 )) primitive3 = primitive1 * 2_I4P test_passed ( 5 ) = primitive3 == ( primitive1 * 2_I4P ) print \"(A)\" , '' print \"(A,F6.3)\" , 'density   => 0.125  * 2 = ' , primitive3 % density print \"(A,3(F6.3,1X))\" , 'velocity  => 1      * 2 = ' , primitive3 % velocity print \"(A,F6.3)\" , 'pressure  => 1      * 2 = ' , primitive3 % pressure print \"(A,2(F7.4,1X))\" , 'densities => 0.0625 * 2 = ' , primitive3 % partial_densities ( 1 ), primitive3 % partial_densities ( 2 ) call print_error ( test = 'primitive3 = primitive1 * 2' , is_test_passed = test_passed ( 5 )) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) contains subroutine print_error ( test , is_test_passed ) !< Print error message if test is failed. character ( * ), intent ( in ) :: test !< Test description. logical , intent ( in ) :: is_test_passed !< Test result. if (. not . is_test_passed ) then print * , '\"' // test // '\" failed!' print * , 'primitive1:' print \"(A,F6.3)\" , '  density   = ' , primitive1 % density print \"(A,3(F6.3,1X))\" , '  velocity  = ' , primitive1 % velocity print \"(A,F6.3)\" , '  pressure  = ' , primitive1 % pressure print \"(A,2(F7.4,1X))\" , '  densities = ' , primitive1 % partial_densities ( 1 ), primitive1 % partial_densities ( 2 ) print * , 'primitive2:' print \"(A,F6.3)\" , '  density   = ' , primitive2 % density print \"(A,3(F6.3,1X))\" , '  velocity  = ' , primitive2 % velocity print \"(A,F6.3)\" , '  pressure  = ' , primitive2 % pressure print \"(A,2(F7.4,1X))\" , '  densities = ' , primitive2 % partial_densities ( 1 ), primitive2 % partial_densities ( 2 ) print * , 'primitive3:' print \"(A,F6.3)\" , '  density   = ' , primitive3 % density print \"(A,3(F6.3,1X))\" , '  velocity  = ' , primitive3 % velocity print \"(A,F6.3)\" , '  pressure  = ' , primitive3 % pressure print \"(A,2(F7.4,1X))\" , '  densities = ' , primitive3 % partial_densities ( 1 ), primitive3 % partial_densities ( 2 ) endif endsubroutine print_error endprogram flow_test_primitive_compressible_multispecie_mul","tags":"","loc":"program/flow_test_primitive_compressible_multispecie_mul.html","title":"flow_test_primitive_compressible_multispecie_mul – FLOw"},{"text":"Uses: flow penf VecFor program~~flow_test_primitive_compressible_multispecie_not_eq~~UsesGraph program~flow_test_primitive_compressible_multispecie_not_eq flow_test_primitive_compressible_multispecie_not_eq module~flow flow module~flow->program~flow_test_primitive_compressible_multispecie_not_eq module~vecfor VecFor module~vecfor->program~flow_test_primitive_compressible_multispecie_not_eq module~flow_primitive_compressible_multispecie flow_primitive_compressible_multispecie module~vecfor->module~flow_primitive_compressible_multispecie module~flow_field_scalar_vectorial flow_field_scalar_vectorial module~vecfor->module~flow_field_scalar_vectorial module~flow_conservative_object flow_conservative_object module~vecfor->module~flow_conservative_object module~flow_compressible_transformations flow_compressible_transformations module~vecfor->module~flow_compressible_transformations module~flow_conservative_compressible flow_conservative_compressible module~vecfor->module~flow_conservative_compressible module~flow_primitive_compressible flow_primitive_compressible module~vecfor->module~flow_primitive_compressible module~flow_primitive_object flow_primitive_object module~vecfor->module~flow_primitive_object module~penf penf module~penf->program~flow_test_primitive_compressible_multispecie_not_eq module~penf->module~flow_primitive_compressible_multispecie module~flow_eos_object flow_eos_object module~penf->module~flow_eos_object module~penf->module~flow_field_scalar_vectorial module~flow_field_object flow_field_object module~penf->module~flow_field_object module~penf->module~flow_conservative_object module~penf->module~flow_compressible_transformations module~flow_eos_compressible flow_eos_compressible module~penf->module~flow_eos_compressible module~penf->module~flow_conservative_compressible module~penf->module~flow_primitive_compressible module~penf->module~flow_primitive_object module~flow_primitive_compressible_multispecie->module~flow module~flow_eos_object->module~flow module~flow_eos_object->module~flow_primitive_compressible_multispecie module~flow_eos_object->module~flow_conservative_object module~flow_eos_object->module~flow_compressible_transformations module~flow_eos_object->module~flow_eos_compressible module~flow_eos_object->module~flow_conservative_compressible module~flow_eos_object->module~flow_primitive_compressible module~flow_eos_object->module~flow_primitive_object module~flow_field_scalar_vectorial->module~flow module~flow_field_object->module~flow module~flow_field_object->module~flow_primitive_compressible_multispecie module~flow_field_object->module~flow_field_scalar_vectorial module~flow_field_object->module~flow_conservative_object module~flow_field_object->module~flow_conservative_compressible module~flow_field_object->module~flow_primitive_compressible module~flow_field_object->module~flow_primitive_object module~flow_conservative_object->module~flow module~flow_conservative_object->module~flow_conservative_compressible module~flow_compressible_transformations->module~flow module~flow_eos_compressible->module~flow module~flow_conservative_compressible->module~flow module~flow_conservative_compressible->module~flow_compressible_transformations module~flow_primitive_compressible->module~flow module~flow_primitive_compressible->module~flow_compressible_transformations module~flow_primitive_object->module~flow module~flow_primitive_object->module~flow_primitive_compressible_multispecie module~flow_primitive_object->module~flow_primitive_compressible iso_fortran_env iso_fortran_env iso_fortran_env->module~vecfor iso_fortran_env->module~flow_conservative_compressible iso_fortran_env->module~flow_primitive_compressible module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf var panprogramflow_test_primitive_compressible_multispecie_not_eqUsesGraph = svgPanZoom('#programflow_test_primitive_compressible_multispecie_not_eqUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FLOw test. Variables primitive1 primitive2 test_passed velocity Source Code flow_test_primitive_compressible_multispecie_not_eq Variables Type Attributes Name Initial type( primitive_compressible_multispecie ) :: primitive1 A primitive object. type( primitive_compressible_multispecie ) :: primitive2 A primitive object. logical :: test_passed (8) List of passed tests. type(vector) :: velocity A vector object. Source Code program flow_test_primitive_compressible_multispecie_not_eq !< FLOw test. use flow , only : primitive_compressible_multispecie use penf , only : R8P use vecfor , only : vector implicit none type ( primitive_compressible_multispecie ) :: primitive1 !< A primitive object. type ( primitive_compressible_multispecie ) :: primitive2 !< A primitive object. type ( vector ) :: velocity !< A vector object. logical :: test_passed ( 8 ) !< List of passed tests. test_passed = . false . velocity = 1._R8P primitive1 = primitive_compressible_multispecie ( density = 0.125_R8P , velocity = velocity , pressure = 1._R8P ) velocity = 1._R8P primitive2 = primitive_compressible_multispecie ( density = 1._R8P , velocity = velocity , pressure = 1._R8P ) test_passed ( 1 ) = ( primitive1 /= primitive2 ). eqv .(. true .) print \"(A,L1)\" , 'density  => 0.125 /= 1 = ' , test_passed ( 1 ) velocity = 1._R8P primitive1 = primitive_compressible_multispecie ( density = 0.125_R8P , velocity = velocity , pressure = 1._R8P ) velocity = 2._R8P primitive2 = primitive_compressible_multispecie ( density = 0.125_R8P , velocity = velocity , pressure = 1._R8P ) test_passed ( 2 ) = ( primitive1 /= primitive2 ). eqv .(. true .) print \"(A,L1)\" , 'velocity => 1     /= 2 = ' , test_passed ( 2 ) velocity = 1._R8P primitive1 = primitive_compressible_multispecie ( density = 0.125_R8P , velocity = velocity , pressure = 1._R8P ) velocity = 2._R8P primitive2 = primitive_compressible_multispecie ( density = 0.125_R8P , velocity = velocity , pressure = 2._R8P ) test_passed ( 3 ) = ( primitive1 /= primitive2 ). eqv .(. true .) print \"(A,L1)\" , 'pressure => 1     /= 2 = ' , test_passed ( 3 ) velocity = 1._R8P primitive1 = primitive_compressible_multispecie ( density = 0.125_R8P , velocity = velocity , pressure = 1._R8P ) velocity = 2._R8P primitive2 = primitive_compressible_multispecie ( density = 1._R8P , velocity = velocity , pressure = 2._R8P ) test_passed ( 4 ) = ( primitive1 /= primitive2 ). eqv .(. true .) print \"(A)\" , new_line ( 'a' ) // 'all together' print \"(A,L1)\" , 'density  => 0.125 /= 1 = ' , test_passed ( 4 ) print \"(A,L1)\" , 'velocity => 1     /= 2 = ' , test_passed ( 4 ) print \"(A,L1)\" , 'pressure => 1     /= 2 = ' , test_passed ( 4 ) velocity = 1._R8P primitive1 = primitive_compressible_multispecie ( density = 1._R8P , velocity = velocity , pressure = 1._R8P ) velocity = 1._R8P primitive2 = primitive_compressible_multispecie ( density = 1._R8P , velocity = velocity , pressure = 1._R8P ) test_passed ( 5 ) = ( primitive1 /= primitive2 ). eqv .(. false .) print \"(A)\" , new_line ( 'a' ) // 'all together' print \"(A,L1)\" , 'density  => 0.125 /= 1 = ' , test_passed ( 5 ) print \"(A,L1)\" , 'velocity => 1     /= 2 = ' , test_passed ( 5 ) print \"(A,L1)\" , 'pressure => 1     /= 2 = ' , test_passed ( 5 ) velocity = 1._R8P primitive1 = primitive_compressible_multispecie ( density = 1._R8P , velocity = velocity , pressure = 1._R8P , partial_densities = [ 0.5_R8P ]) velocity = 1._R8P primitive2 = primitive_compressible_multispecie ( density = 1._R8P , velocity = velocity , pressure = 1._R8P ) test_passed ( 6 ) = ( primitive1 /= primitive2 ). eqv .(. true .) print \"(A)\" , new_line ( 'a' ) // 'all together true with densities' print \"(A,L1)\" , 'density   => 1   == 1    = ' , test_passed ( 6 ) print \"(A,L1)\" , 'velocity  => 1   == 1    = ' , test_passed ( 6 ) print \"(A,L1)\" , 'pressure  => 1   == 1    = ' , test_passed ( 6 ) print \"(A,L1)\" , 'densities => 0.5 /= null = ' , test_passed ( 6 ) velocity = 1._R8P primitive1 = primitive_compressible_multispecie ( density = 1._R8P , velocity = velocity , pressure = 1._R8P , partial_densities = [ 0.5_R8P ]) velocity = 1._R8P primitive2 = primitive_compressible_multispecie ( density = 1._R8P , velocity = velocity , pressure = 1._R8P , partial_densities = [ 0.1_R8P ]) test_passed ( 7 ) = ( primitive1 /= primitive2 ). eqv .(. true .) print \"(A)\" , new_line ( 'a' ) // 'all together true with densities' print \"(A,L1)\" , 'density   => 1   == 1   = ' , test_passed ( 7 ) print \"(A,L1)\" , 'velocity  => 1   == 1   = ' , test_passed ( 7 ) print \"(A,L1)\" , 'pressure  => 1   == 1   = ' , test_passed ( 7 ) print \"(A,L1)\" , 'densities => 0.5 /= 0.1 = ' , test_passed ( 7 ) velocity = 1._R8P primitive1 = primitive_compressible_multispecie ( density = 1._R8P , velocity = velocity , pressure = 1._R8P , partial_densities = [ 0.5_R8P ]) velocity = 1._R8P primitive2 = primitive_compressible_multispecie ( density = 1._R8P , velocity = velocity , pressure = 1._R8P , partial_densities = [ 0.5_R8P ]) test_passed ( 8 ) = ( primitive1 /= primitive2 ). eqv .(. false .) print \"(A)\" , new_line ( 'a' ) // 'all together true with densities' print \"(A,L1)\" , 'density   => 1   == 1   = ' , test_passed ( 8 ) print \"(A,L1)\" , 'velocity  => 1   == 1   = ' , test_passed ( 8 ) print \"(A,L1)\" , 'pressure  => 1   == 1   = ' , test_passed ( 8 ) print \"(A,L1)\" , 'densities => 0.5 == 0.5 = ' , test_passed ( 8 ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram flow_test_primitive_compressible_multispecie_not_eq","tags":"","loc":"program/flow_test_primitive_compressible_multispecie_not_eq.html","title":"flow_test_primitive_compressible_multispecie_not_eq – FLOw"},{"text":"Uses: flow penf VecFor program~~flow_test_primitive_compressible_multispecie_add~2~~UsesGraph program~flow_test_primitive_compressible_multispecie_add~2 flow_test_primitive_compressible_multispecie_add module~flow flow module~flow->program~flow_test_primitive_compressible_multispecie_add~2 module~vecfor VecFor module~vecfor->program~flow_test_primitive_compressible_multispecie_add~2 module~flow_primitive_compressible_multispecie flow_primitive_compressible_multispecie module~vecfor->module~flow_primitive_compressible_multispecie module~flow_field_scalar_vectorial flow_field_scalar_vectorial module~vecfor->module~flow_field_scalar_vectorial module~flow_conservative_object flow_conservative_object module~vecfor->module~flow_conservative_object module~flow_compressible_transformations flow_compressible_transformations module~vecfor->module~flow_compressible_transformations module~flow_conservative_compressible flow_conservative_compressible module~vecfor->module~flow_conservative_compressible module~flow_primitive_compressible flow_primitive_compressible module~vecfor->module~flow_primitive_compressible module~flow_primitive_object flow_primitive_object module~vecfor->module~flow_primitive_object module~penf penf module~penf->program~flow_test_primitive_compressible_multispecie_add~2 module~penf->module~flow_primitive_compressible_multispecie module~flow_eos_object flow_eos_object module~penf->module~flow_eos_object module~penf->module~flow_field_scalar_vectorial module~flow_field_object flow_field_object module~penf->module~flow_field_object module~penf->module~flow_conservative_object module~penf->module~flow_compressible_transformations module~flow_eos_compressible flow_eos_compressible module~penf->module~flow_eos_compressible module~penf->module~flow_conservative_compressible module~penf->module~flow_primitive_compressible module~penf->module~flow_primitive_object module~flow_primitive_compressible_multispecie->module~flow module~flow_eos_object->module~flow module~flow_eos_object->module~flow_primitive_compressible_multispecie module~flow_eos_object->module~flow_conservative_object module~flow_eos_object->module~flow_compressible_transformations module~flow_eos_object->module~flow_eos_compressible module~flow_eos_object->module~flow_conservative_compressible module~flow_eos_object->module~flow_primitive_compressible module~flow_eos_object->module~flow_primitive_object module~flow_field_scalar_vectorial->module~flow module~flow_field_object->module~flow module~flow_field_object->module~flow_primitive_compressible_multispecie module~flow_field_object->module~flow_field_scalar_vectorial module~flow_field_object->module~flow_conservative_object module~flow_field_object->module~flow_conservative_compressible module~flow_field_object->module~flow_primitive_compressible module~flow_field_object->module~flow_primitive_object module~flow_conservative_object->module~flow module~flow_conservative_object->module~flow_conservative_compressible module~flow_compressible_transformations->module~flow module~flow_eos_compressible->module~flow module~flow_conservative_compressible->module~flow module~flow_conservative_compressible->module~flow_compressible_transformations module~flow_primitive_compressible->module~flow module~flow_primitive_compressible->module~flow_compressible_transformations module~flow_primitive_object->module~flow module~flow_primitive_object->module~flow_primitive_compressible_multispecie module~flow_primitive_object->module~flow_primitive_compressible iso_fortran_env iso_fortran_env iso_fortran_env->module~vecfor iso_fortran_env->module~flow_conservative_compressible iso_fortran_env->module~flow_primitive_compressible module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf var panprogramflow_test_primitive_compressible_multispecie_add2UsesGraph = svgPanZoom('#programflow_test_primitive_compressible_multispecie_add2UsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FLOw test. Variables primitive1 primitive2 test_passed velocity Source Code flow_test_primitive_compressible_multispecie_add Variables Type Attributes Name Initial type( primitive_compressible_multispecie ) :: primitive1 A primitive object. type( primitive_compressible_multispecie ) :: primitive2 A primitive object. logical :: test_passed (4) List of passed tests. type(vector) :: velocity A vector object. Source Code program flow_test_primitive_compressible_multispecie_add !< FLOw test. use flow , only : primitive_compressible_multispecie use penf , only : I4P , R8P use vecfor , only : vector implicit none type ( primitive_compressible_multispecie ) :: primitive1 !< A primitive object. type ( primitive_compressible_multispecie ) :: primitive2 !< A primitive object. type ( vector ) :: velocity !< A vector object. logical :: test_passed ( 4 ) !< List of passed tests. test_passed = . false . velocity = 0.5_R8P primitive1 = primitive_compressible_multispecie ( density = 0.125_R8P , velocity = velocity , pressure = 1._R8P ) primitive2 = primitive1 ** 2_I4P print \"(A,F6.3)\" , 'density  => 0.125 ** 2 = ' , primitive2 % density print \"(A,3(F6.3,1X))\" , 'velocity => 0.5   ** 2 = ' , primitive2 % velocity print \"(A,F6.3)\" , 'pressure => 1     ** 2 = ' , primitive2 % pressure test_passed ( 1 ) = primitive2 % density == ( 0.125_R8P ** 2_I4P ) velocity = 0.5_R8P primitive1 = primitive_compressible_multispecie ( density = 0.125_R8P , & velocity = velocity , & pressure = 1._R8P , & partial_densities = [ 0.125_R8P , 0.125_R8P ]) primitive2 = primitive1 ** 2_I4P print \"(A,F6.3)\" , 'density   => 0.125 ** 2 = ' , primitive2 % density print \"(A,3(F6.3,1X))\" , 'velocity  => 0.5   ** 2 = ' , primitive2 % velocity print \"(A,F6.3)\" , 'pressure  => 1     ** 2 = ' , primitive2 % pressure print \"(A,2(F6.3,1X))\" , 'densities => 0.125 ** 2 = ' , primitive2 % partial_densities test_passed ( 2 ) = primitive2 % partial_densities ( 1 ) == ( 0.125_R8P ** 2_I4P ) velocity = 0.5_R8P primitive1 = primitive_compressible_multispecie ( density = 0.125_R8P , velocity = velocity , pressure = 1._R8P ) primitive2 = primitive1 ** 2._R8P print \"(A,F6.3)\" , 'density  => 0.125 ** 2.0 = ' , primitive2 % density print \"(A,3(F6.3,1X))\" , 'velocity => 0.5   ** 2.0 = ' , primitive2 % velocity print \"(A,F6.3)\" , 'pressure => 1     ** 2.0 = ' , primitive2 % pressure test_passed ( 3 ) = primitive2 % density == ( 0.125_R8P ** 2._R8P ) velocity = 0.5_R8P primitive1 = primitive_compressible_multispecie ( density = 0.125_R8P , & velocity = velocity , & pressure = 1._R8P , & partial_densities = [ 0.125_R8P , 0.125_R8P ]) primitive2 = primitive1 ** 2._R8P print \"(A,F6.3)\" , 'density   => 0.125 ** 2.0 = ' , primitive2 % density print \"(A,3(F6.3,1X))\" , 'velocity  => 0.5   ** 2.0 = ' , primitive2 % velocity print \"(A,F6.3)\" , 'pressure  => 1     ** 2.0 = ' , primitive2 % pressure print \"(A,2(F6.3,1X))\" , 'densities => 0.125 ** 2.0 = ' , primitive2 % partial_densities test_passed ( 4 ) = primitive2 % partial_densities ( 1 ) == ( 0.125_R8P ** 2._R8P ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram flow_test_primitive_compressible_multispecie_add","tags":"","loc":"program/flow_test_primitive_compressible_multispecie_add~2.html","title":"flow_test_primitive_compressible_multispecie_add – FLOw"},{"text":"Uses: flow penf VecFor program~~flow_test_primitive_compressible_multispecie_sub~~UsesGraph program~flow_test_primitive_compressible_multispecie_sub flow_test_primitive_compressible_multispecie_sub module~flow flow module~flow->program~flow_test_primitive_compressible_multispecie_sub module~vecfor VecFor module~vecfor->program~flow_test_primitive_compressible_multispecie_sub module~flow_primitive_compressible_multispecie flow_primitive_compressible_multispecie module~vecfor->module~flow_primitive_compressible_multispecie module~flow_field_scalar_vectorial flow_field_scalar_vectorial module~vecfor->module~flow_field_scalar_vectorial module~flow_conservative_object flow_conservative_object module~vecfor->module~flow_conservative_object module~flow_compressible_transformations flow_compressible_transformations module~vecfor->module~flow_compressible_transformations module~flow_conservative_compressible flow_conservative_compressible module~vecfor->module~flow_conservative_compressible module~flow_primitive_compressible flow_primitive_compressible module~vecfor->module~flow_primitive_compressible module~flow_primitive_object flow_primitive_object module~vecfor->module~flow_primitive_object module~penf penf module~penf->program~flow_test_primitive_compressible_multispecie_sub module~penf->module~flow_primitive_compressible_multispecie module~flow_eos_object flow_eos_object module~penf->module~flow_eos_object module~penf->module~flow_field_scalar_vectorial module~flow_field_object flow_field_object module~penf->module~flow_field_object module~penf->module~flow_conservative_object module~penf->module~flow_compressible_transformations module~flow_eos_compressible flow_eos_compressible module~penf->module~flow_eos_compressible module~penf->module~flow_conservative_compressible module~penf->module~flow_primitive_compressible module~penf->module~flow_primitive_object module~flow_primitive_compressible_multispecie->module~flow module~flow_eos_object->module~flow module~flow_eos_object->module~flow_primitive_compressible_multispecie module~flow_eos_object->module~flow_conservative_object module~flow_eos_object->module~flow_compressible_transformations module~flow_eos_object->module~flow_eos_compressible module~flow_eos_object->module~flow_conservative_compressible module~flow_eos_object->module~flow_primitive_compressible module~flow_eos_object->module~flow_primitive_object module~flow_field_scalar_vectorial->module~flow module~flow_field_object->module~flow module~flow_field_object->module~flow_primitive_compressible_multispecie module~flow_field_object->module~flow_field_scalar_vectorial module~flow_field_object->module~flow_conservative_object module~flow_field_object->module~flow_conservative_compressible module~flow_field_object->module~flow_primitive_compressible module~flow_field_object->module~flow_primitive_object module~flow_conservative_object->module~flow module~flow_conservative_object->module~flow_conservative_compressible module~flow_compressible_transformations->module~flow module~flow_eos_compressible->module~flow module~flow_conservative_compressible->module~flow module~flow_conservative_compressible->module~flow_compressible_transformations module~flow_primitive_compressible->module~flow module~flow_primitive_compressible->module~flow_compressible_transformations module~flow_primitive_object->module~flow module~flow_primitive_object->module~flow_primitive_compressible_multispecie module~flow_primitive_object->module~flow_primitive_compressible iso_fortran_env iso_fortran_env iso_fortran_env->module~vecfor iso_fortran_env->module~flow_conservative_compressible iso_fortran_env->module~flow_primitive_compressible module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf var panprogramflow_test_primitive_compressible_multispecie_subUsesGraph = svgPanZoom('#programflow_test_primitive_compressible_multispecie_subUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FLOw test. Variables primitive1 primitive2 primitive3 test_passed velocity Source Code flow_test_primitive_compressible_multispecie_sub Variables Type Attributes Name Initial type( primitive_compressible_multispecie ) :: primitive1 A primitive object. type( primitive_compressible_multispecie ) :: primitive2 A primitive object. type( primitive_compressible_multispecie ) :: primitive3 A primitive object. logical :: test_passed (2) List of passed tests. type(vector) :: velocity A vector object. Source Code program flow_test_primitive_compressible_multispecie_sub !< FLOw test. use flow , only : primitive_compressible_multispecie use penf , only : R8P use vecfor , only : vector implicit none type ( primitive_compressible_multispecie ) :: primitive1 !< A primitive object. type ( primitive_compressible_multispecie ) :: primitive2 !< A primitive object. type ( primitive_compressible_multispecie ) :: primitive3 !< A primitive object. type ( vector ) :: velocity !< A vector object. logical :: test_passed ( 2 ) !< List of passed tests. test_passed = . false . velocity = 1._R8P primitive1 = primitive_compressible_multispecie ( density = 0.125_R8P , & velocity = velocity , & pressure = 1._R8P , & partial_densities = [ 0.125_R8P / 2 , 0.125_R8P / 2 ]) velocity = 2._R8P primitive2 = primitive_compressible_multispecie ( density = 1._R8P , & velocity = velocity , & pressure = 1._R8P , & partial_densities = [ 1._R8P / 2 , 1._R8P / 2 ]) primitive3 = primitive1 - primitive2 test_passed ( 1 ) = primitive3 == ( primitive1 - primitive2 ) print \"(A,F6.3)\" , 'density   => 0.125  - 1   = ' , primitive3 % density print \"(A,3(F6.3,1X))\" , 'velocity  => 1      - 2   = ' , primitive3 % velocity print \"(A,F6.3)\" , 'pressure  => 1      - 1   = ' , primitive3 % pressure print \"(A,2(F7.4,1X))\" , 'densities => 0.0625 - 0.5 = ' , primitive3 % partial_densities ( 1 ), primitive3 % partial_densities ( 2 ) velocity = - 1._R8P primitive1 = primitive_compressible_multispecie ( density = 0.125_R8P , velocity = velocity , pressure = 1._R8P , & partial_densities = [ 0.125_R8P / 2 , 0.125_R8P / 2 ]) primitive2 = - primitive1 test_passed ( 2 ) = primitive2 == - primitive1 print \"(A,F6.3)\" , 'density   => - (0.125)  = ' , primitive2 % density print \"(A,3(F6.3,1X))\" , 'velocity  => - (-1)     = ' , primitive2 % velocity print \"(A,F6.3)\" , 'pressure  => - (1)      = ' , primitive2 % pressure print \"(A,2(F7.4,1X))\" , 'densities => - (0.0625) = ' , primitive2 % partial_densities print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram flow_test_primitive_compressible_multispecie_sub","tags":"","loc":"program/flow_test_primitive_compressible_multispecie_sub.html","title":"flow_test_primitive_compressible_multispecie_sub – FLOw"},{"text":"Uses: flow penf VecFor program~~flow_test_primitive_compressible_not_eq~~UsesGraph program~flow_test_primitive_compressible_not_eq flow_test_primitive_compressible_not_eq module~flow flow module~flow->program~flow_test_primitive_compressible_not_eq module~vecfor VecFor module~vecfor->program~flow_test_primitive_compressible_not_eq module~flow_primitive_compressible_multispecie flow_primitive_compressible_multispecie module~vecfor->module~flow_primitive_compressible_multispecie module~flow_field_scalar_vectorial flow_field_scalar_vectorial module~vecfor->module~flow_field_scalar_vectorial module~flow_conservative_object flow_conservative_object module~vecfor->module~flow_conservative_object module~flow_compressible_transformations flow_compressible_transformations module~vecfor->module~flow_compressible_transformations module~flow_conservative_compressible flow_conservative_compressible module~vecfor->module~flow_conservative_compressible module~flow_primitive_compressible flow_primitive_compressible module~vecfor->module~flow_primitive_compressible module~flow_primitive_object flow_primitive_object module~vecfor->module~flow_primitive_object module~penf penf module~penf->program~flow_test_primitive_compressible_not_eq module~penf->module~flow_primitive_compressible_multispecie module~flow_eos_object flow_eos_object module~penf->module~flow_eos_object module~penf->module~flow_field_scalar_vectorial module~flow_field_object flow_field_object module~penf->module~flow_field_object module~penf->module~flow_conservative_object module~penf->module~flow_compressible_transformations module~flow_eos_compressible flow_eos_compressible module~penf->module~flow_eos_compressible module~penf->module~flow_conservative_compressible module~penf->module~flow_primitive_compressible module~penf->module~flow_primitive_object module~flow_primitive_compressible_multispecie->module~flow module~flow_eos_object->module~flow module~flow_eos_object->module~flow_primitive_compressible_multispecie module~flow_eos_object->module~flow_conservative_object module~flow_eos_object->module~flow_compressible_transformations module~flow_eos_object->module~flow_eos_compressible module~flow_eos_object->module~flow_conservative_compressible module~flow_eos_object->module~flow_primitive_compressible module~flow_eos_object->module~flow_primitive_object module~flow_field_scalar_vectorial->module~flow module~flow_field_object->module~flow module~flow_field_object->module~flow_primitive_compressible_multispecie module~flow_field_object->module~flow_field_scalar_vectorial module~flow_field_object->module~flow_conservative_object module~flow_field_object->module~flow_conservative_compressible module~flow_field_object->module~flow_primitive_compressible module~flow_field_object->module~flow_primitive_object module~flow_conservative_object->module~flow module~flow_conservative_object->module~flow_conservative_compressible module~flow_compressible_transformations->module~flow module~flow_eos_compressible->module~flow module~flow_conservative_compressible->module~flow module~flow_conservative_compressible->module~flow_compressible_transformations module~flow_primitive_compressible->module~flow module~flow_primitive_compressible->module~flow_compressible_transformations module~flow_primitive_object->module~flow module~flow_primitive_object->module~flow_primitive_compressible_multispecie module~flow_primitive_object->module~flow_primitive_compressible iso_fortran_env iso_fortran_env iso_fortran_env->module~vecfor iso_fortran_env->module~flow_conservative_compressible iso_fortran_env->module~flow_primitive_compressible module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf var panprogramflow_test_primitive_compressible_not_eqUsesGraph = svgPanZoom('#programflow_test_primitive_compressible_not_eqUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FLOw test. Variables primitive1 primitive2 test_passed velocity Source Code flow_test_primitive_compressible_not_eq Variables Type Attributes Name Initial type( primitive_compressible ) :: primitive1 A primitive object. type( primitive_compressible ) :: primitive2 A primitive object. logical :: test_passed (5) List of passed tests. type(vector) :: velocity A vector object. Source Code program flow_test_primitive_compressible_not_eq !< FLOw test. use flow , only : primitive_compressible use penf , only : R8P use vecfor , only : vector implicit none type ( primitive_compressible ) :: primitive1 !< A primitive object. type ( primitive_compressible ) :: primitive2 !< A primitive object. type ( vector ) :: velocity !< A vector object. logical :: test_passed ( 5 ) !< List of passed tests. test_passed = . false . velocity = 1._R8P primitive1 = primitive_compressible ( density = 0.125_R8P , velocity = velocity , pressure = 1._R8P ) velocity = 1._R8P primitive2 = primitive_compressible ( density = 1._R8P , velocity = velocity , pressure = 1._R8P ) test_passed ( 1 ) = ( primitive1 /= primitive2 ). eqv .(. true .) print \"(A,L1)\" , 'density  => 0.125 /= 1 = ' , test_passed ( 1 ) velocity = 1._R8P primitive1 = primitive_compressible ( density = 0.125_R8P , velocity = velocity , pressure = 1._R8P ) velocity = 2._R8P primitive2 = primitive_compressible ( density = 0.125_R8P , velocity = velocity , pressure = 1._R8P ) test_passed ( 2 ) = ( primitive1 /= primitive2 ). eqv .(. true .) print \"(A,L1)\" , 'velocity => 1     /= 2 = ' , test_passed ( 2 ) velocity = 1._R8P primitive1 = primitive_compressible ( density = 0.125_R8P , velocity = velocity , pressure = 1._R8P ) velocity = 2._R8P primitive2 = primitive_compressible ( density = 0.125_R8P , velocity = velocity , pressure = 2._R8P ) test_passed ( 3 ) = ( primitive1 /= primitive2 ). eqv .(. true .) print \"(A,L1)\" , 'pressure => 1     /= 2 = ' , test_passed ( 3 ) velocity = 1._R8P primitive1 = primitive_compressible ( density = 0.125_R8P , velocity = velocity , pressure = 1._R8P ) velocity = 2._R8P primitive2 = primitive_compressible ( density = 1._R8P , velocity = velocity , pressure = 2._R8P ) test_passed ( 4 ) = ( primitive1 /= primitive2 ). eqv .(. true .) print \"(A)\" , new_line ( 'a' ) // 'all together' print \"(A,L1)\" , 'density  => 0.125 /= 1 = ' , test_passed ( 4 ) print \"(A,L1)\" , 'velocity => 1     /= 2 = ' , test_passed ( 4 ) print \"(A,L1)\" , 'pressure => 1     /= 2 = ' , test_passed ( 4 ) velocity = 1._R8P primitive1 = primitive_compressible ( density = 1._R8P , velocity = velocity , pressure = 1._R8P ) velocity = 1._R8P primitive2 = primitive_compressible ( density = 1._R8P , velocity = velocity , pressure = 1._R8P ) test_passed ( 5 ) = ( primitive1 /= primitive2 ). eqv .(. false .) print \"(A)\" , new_line ( 'a' ) // 'all together' print \"(A,L1)\" , 'density  => 0.125 /= 1 = ' , test_passed ( 5 ) print \"(A,L1)\" , 'velocity => 1     /= 2 = ' , test_passed ( 5 ) print \"(A,L1)\" , 'pressure => 1     /= 2 = ' , test_passed ( 5 ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram flow_test_primitive_compressible_not_eq","tags":"","loc":"program/flow_test_primitive_compressible_not_eq.html","title":"flow_test_primitive_compressible_not_eq – FLOw"},{"text":"Uses: flow penf VecFor program~~flow_test_primitive_compressible_add~2~~UsesGraph program~flow_test_primitive_compressible_add~2 flow_test_primitive_compressible_add module~flow flow module~flow->program~flow_test_primitive_compressible_add~2 module~vecfor VecFor module~vecfor->program~flow_test_primitive_compressible_add~2 module~flow_primitive_compressible_multispecie flow_primitive_compressible_multispecie module~vecfor->module~flow_primitive_compressible_multispecie module~flow_field_scalar_vectorial flow_field_scalar_vectorial module~vecfor->module~flow_field_scalar_vectorial module~flow_conservative_object flow_conservative_object module~vecfor->module~flow_conservative_object module~flow_compressible_transformations flow_compressible_transformations module~vecfor->module~flow_compressible_transformations module~flow_conservative_compressible flow_conservative_compressible module~vecfor->module~flow_conservative_compressible module~flow_primitive_compressible flow_primitive_compressible module~vecfor->module~flow_primitive_compressible module~flow_primitive_object flow_primitive_object module~vecfor->module~flow_primitive_object module~penf penf module~penf->program~flow_test_primitive_compressible_add~2 module~penf->module~flow_primitive_compressible_multispecie module~flow_eos_object flow_eos_object module~penf->module~flow_eos_object module~penf->module~flow_field_scalar_vectorial module~flow_field_object flow_field_object module~penf->module~flow_field_object module~penf->module~flow_conservative_object module~penf->module~flow_compressible_transformations module~flow_eos_compressible flow_eos_compressible module~penf->module~flow_eos_compressible module~penf->module~flow_conservative_compressible module~penf->module~flow_primitive_compressible module~penf->module~flow_primitive_object module~flow_primitive_compressible_multispecie->module~flow module~flow_eos_object->module~flow module~flow_eos_object->module~flow_primitive_compressible_multispecie module~flow_eos_object->module~flow_conservative_object module~flow_eos_object->module~flow_compressible_transformations module~flow_eos_object->module~flow_eos_compressible module~flow_eos_object->module~flow_conservative_compressible module~flow_eos_object->module~flow_primitive_compressible module~flow_eos_object->module~flow_primitive_object module~flow_field_scalar_vectorial->module~flow module~flow_field_object->module~flow module~flow_field_object->module~flow_primitive_compressible_multispecie module~flow_field_object->module~flow_field_scalar_vectorial module~flow_field_object->module~flow_conservative_object module~flow_field_object->module~flow_conservative_compressible module~flow_field_object->module~flow_primitive_compressible module~flow_field_object->module~flow_primitive_object module~flow_conservative_object->module~flow module~flow_conservative_object->module~flow_conservative_compressible module~flow_compressible_transformations->module~flow module~flow_eos_compressible->module~flow module~flow_conservative_compressible->module~flow module~flow_conservative_compressible->module~flow_compressible_transformations module~flow_primitive_compressible->module~flow module~flow_primitive_compressible->module~flow_compressible_transformations module~flow_primitive_object->module~flow module~flow_primitive_object->module~flow_primitive_compressible_multispecie module~flow_primitive_object->module~flow_primitive_compressible iso_fortran_env iso_fortran_env iso_fortran_env->module~vecfor iso_fortran_env->module~flow_conservative_compressible iso_fortran_env->module~flow_primitive_compressible module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf var panprogramflow_test_primitive_compressible_add2UsesGraph = svgPanZoom('#programflow_test_primitive_compressible_add2UsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FLOw test. Variables primitive1 primitive2 test_passed velocity Source Code flow_test_primitive_compressible_add Variables Type Attributes Name Initial type( primitive_compressible ) :: primitive1 A primitive object. type( primitive_compressible ) :: primitive2 A primitive object. logical :: test_passed (2) List of passed tests. type(vector) :: velocity A vector object. Source Code program flow_test_primitive_compressible_add !< FLOw test. use flow , only : primitive_compressible use penf , only : I4P , R8P use vecfor , only : vector implicit none type ( primitive_compressible ) :: primitive1 !< A primitive object. type ( primitive_compressible ) :: primitive2 !< A primitive object. type ( vector ) :: velocity !< A vector object. logical :: test_passed ( 2 ) !< List of passed tests. test_passed = . false . velocity = 0.5_R8P primitive1 = primitive_compressible ( density = 0.125_R8P , velocity = velocity , pressure = 1._R8P ) primitive2 = primitive1 ** 2_I4P print \"(A,F6.3)\" , 'density  => 0.125 ** 2 = ' , primitive2 % density print \"(A,3(F6.3,1X))\" , 'velocity => 0.5   ** 2 = ' , primitive2 % velocity print \"(A,F6.3)\" , 'pressure => 1     ** 2 = ' , primitive2 % pressure test_passed ( 1 ) = primitive2 % density == ( 0.125_R8P ** 2_I4P ) velocity = 0.5_R8P primitive1 = primitive_compressible ( density = 0.125_R8P , velocity = velocity , pressure = 1._R8P ) primitive2 = primitive1 ** 2._R8P print \"(A,F6.3)\" , 'density  => 0.125 ** 2.0 = ' , primitive2 % density print \"(A,3(F6.3,1X))\" , 'velocity => 0.5   ** 2.0 = ' , primitive2 % velocity print \"(A,F6.3)\" , 'pressure => 1     ** 2.0 = ' , primitive2 % pressure test_passed ( 2 ) = primitive2 % density == ( 0.125_R8P ** 2._R8P ) print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram flow_test_primitive_compressible_add","tags":"","loc":"program/flow_test_primitive_compressible_add~2.html","title":"flow_test_primitive_compressible_add – FLOw"},{"text":"Uses: flow penf VecFor program~~flow_test_primitive_compressible_sub~~UsesGraph program~flow_test_primitive_compressible_sub flow_test_primitive_compressible_sub module~flow flow module~flow->program~flow_test_primitive_compressible_sub module~vecfor VecFor module~vecfor->program~flow_test_primitive_compressible_sub module~flow_primitive_compressible_multispecie flow_primitive_compressible_multispecie module~vecfor->module~flow_primitive_compressible_multispecie module~flow_field_scalar_vectorial flow_field_scalar_vectorial module~vecfor->module~flow_field_scalar_vectorial module~flow_conservative_object flow_conservative_object module~vecfor->module~flow_conservative_object module~flow_compressible_transformations flow_compressible_transformations module~vecfor->module~flow_compressible_transformations module~flow_conservative_compressible flow_conservative_compressible module~vecfor->module~flow_conservative_compressible module~flow_primitive_compressible flow_primitive_compressible module~vecfor->module~flow_primitive_compressible module~flow_primitive_object flow_primitive_object module~vecfor->module~flow_primitive_object module~penf penf module~penf->program~flow_test_primitive_compressible_sub module~penf->module~flow_primitive_compressible_multispecie module~flow_eos_object flow_eos_object module~penf->module~flow_eos_object module~penf->module~flow_field_scalar_vectorial module~flow_field_object flow_field_object module~penf->module~flow_field_object module~penf->module~flow_conservative_object module~penf->module~flow_compressible_transformations module~flow_eos_compressible flow_eos_compressible module~penf->module~flow_eos_compressible module~penf->module~flow_conservative_compressible module~penf->module~flow_primitive_compressible module~penf->module~flow_primitive_object module~flow_primitive_compressible_multispecie->module~flow module~flow_eos_object->module~flow module~flow_eos_object->module~flow_primitive_compressible_multispecie module~flow_eos_object->module~flow_conservative_object module~flow_eos_object->module~flow_compressible_transformations module~flow_eos_object->module~flow_eos_compressible module~flow_eos_object->module~flow_conservative_compressible module~flow_eos_object->module~flow_primitive_compressible module~flow_eos_object->module~flow_primitive_object module~flow_field_scalar_vectorial->module~flow module~flow_field_object->module~flow module~flow_field_object->module~flow_primitive_compressible_multispecie module~flow_field_object->module~flow_field_scalar_vectorial module~flow_field_object->module~flow_conservative_object module~flow_field_object->module~flow_conservative_compressible module~flow_field_object->module~flow_primitive_compressible module~flow_field_object->module~flow_primitive_object module~flow_conservative_object->module~flow module~flow_conservative_object->module~flow_conservative_compressible module~flow_compressible_transformations->module~flow module~flow_eos_compressible->module~flow module~flow_conservative_compressible->module~flow module~flow_conservative_compressible->module~flow_compressible_transformations module~flow_primitive_compressible->module~flow module~flow_primitive_compressible->module~flow_compressible_transformations module~flow_primitive_object->module~flow module~flow_primitive_object->module~flow_primitive_compressible_multispecie module~flow_primitive_object->module~flow_primitive_compressible iso_fortran_env iso_fortran_env iso_fortran_env->module~vecfor iso_fortran_env->module~flow_conservative_compressible iso_fortran_env->module~flow_primitive_compressible module~penf_stringify penf_stringify iso_fortran_env->module~penf_stringify module~penf_global_parameters_variables penf_global_parameters_variables module~penf_global_parameters_variables->module~penf module~penf_b_size penf_b_size module~penf_global_parameters_variables->module~penf_b_size module~penf_global_parameters_variables->module~penf_stringify module~penf_b_size->module~penf module~penf_b_size->module~penf_stringify module~penf_stringify->module~penf var panprogramflow_test_primitive_compressible_subUsesGraph = svgPanZoom('#programflow_test_primitive_compressible_subUsesGraph', {\n                    zoomEnabled: true,\n                    controlIconsEnabled: true,\n                    fit: true,\n                    center: true,}); Help × Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a parent (sub)module to the submodule which is\n    descended from it. Dashed arrows point from a module being used to the\n    module or program unit using it. FLOw test. Variables primitive1 primitive2 primitive3 test_passed velocity Source Code flow_test_primitive_compressible_sub Variables Type Attributes Name Initial type( primitive_compressible ) :: primitive1 A primitive object. type( primitive_compressible ) :: primitive2 A primitive object. type( primitive_compressible ) :: primitive3 A primitive object. logical :: test_passed (2) List of passed tests. type(vector) :: velocity A vector object. Source Code program flow_test_primitive_compressible_sub !< FLOw test. use flow , only : primitive_compressible use penf , only : R8P use vecfor , only : vector implicit none type ( primitive_compressible ) :: primitive1 !< A primitive object. type ( primitive_compressible ) :: primitive2 !< A primitive object. type ( primitive_compressible ) :: primitive3 !< A primitive object. type ( vector ) :: velocity !< A vector object. logical :: test_passed ( 2 ) !< List of passed tests. test_passed = . false . velocity = 1._R8P primitive1 = primitive_compressible ( density = 0.125_R8P , velocity = velocity , pressure = 1._R8P ) velocity = 2._R8P primitive2 = primitive_compressible ( density = 1._R8P , velocity = velocity , pressure = 1._R8P ) primitive3 = primitive1 - primitive2 test_passed ( 1 ) = primitive3 == ( primitive1 - primitive2 ) print \"(A,F6.3)\" , 'density   => 0.125  - 1   = ' , primitive3 % density print \"(A,3(F6.3,1X))\" , 'velocity  => 1      - 2   = ' , primitive3 % velocity print \"(A,F6.3)\" , 'pressure  => 1      - 1   = ' , primitive3 % pressure velocity = - 1._R8P primitive1 = primitive_compressible ( density = 0.125_R8P , velocity = velocity , pressure = 1._R8P ) primitive2 = - primitive1 test_passed ( 2 ) = primitive2 == - primitive1 print \"(A,F6.3)\" , 'density   => - (0.125) = ' , primitive2 % density print \"(A,3(F6.3,1X))\" , 'velocity  => - (-1)    = ' , primitive2 % velocity print \"(A,F6.3)\" , 'pressure  => - (1)     = ' , primitive2 % pressure print \"(A,L1)\" , new_line ( 'a' ) // 'Are all tests passed? ' , all ( test_passed ) endprogram flow_test_primitive_compressible_sub","tags":"","loc":"program/flow_test_primitive_compressible_sub.html","title":"flow_test_primitive_compressible_sub – FLOw"}]}